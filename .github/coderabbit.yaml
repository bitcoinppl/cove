review:
  path_instructions:
    - path: "rust/**/*.rs"
      instructions: |
        - Verify correct functionality and logic consistency.
        - Check for idiomatic Rust usage and performance best practices.
        - Suggest improvements to error handling, unwraps, and Result handling.
        - Check for any potential memory leaks or unsafe code.
        - Check for any potential mutex deadlocks.
        - Check for potentail security issues, make sure Bitcoin wallets are handled securely.
        - Identify spelling mistakes in comments, string literals, and documentation
    - path: "ios/Cove/**/*.swift"
      instructions: |
        - Review SwiftUI view code for proper layout, best practices
        - Identify spelling mistakes in comments, string literals, and documentation
    - path: "android/app/src/main/java/org/bitcoinppl/cove/**/*.kt"
      instructions: |
        - Verify correct functionality and logic consistency.
        - Check for idiomatic Kotlin usage and performance best practices.
        - Ignore generated bindings code in android/app/src/main/java/org/bitcoinppl/cove_core/**

        IMPORTANT FFI/Threading Guidelines:
        - DO NOT suggest wrapping FFI calls in withContext(Dispatchers.IO) without evidence of UI blocking
        - The Rust core uses Tokio runtime and handles async internally
        - Simple database operations (redb) are fast and do not need threading changes
        - Only suggest Dispatchers.IO if there is profiling evidence of actual UI blocking

        FFI Resource Management:
        - Always verify that UniFFI objects implementing AutoCloseable call .close() before being nulled
        - Example: Mnemonic must call .close() to trigger zeroization of sensitive data
        - Use DisposableEffect for cleanup in Compose, never just null references

        Compose Best Practices:
        - LaunchedEffect should be keyed to actual dependencies, not Unit
        - Set loading states at the beginning of LaunchedEffect blocks
  general_guidelines: |
    - Check spelling and grammar in code comments and documentation across all files.
    - Look for consistent styling, formatting, and naming conventions.
    - Suggest improvements for readability, maintainability, and modularity.
    - Flag TODOs, FIXMEs, and commented-out code for potential cleanup.

knowledge_base:
  - |
    ## Cove Architecture Overview

    This project uses a Rust core with UniFFI-generated bindings for iOS (Swift) and Android (Kotlin).

    ### Core Architecture Principles

    1. **Rust Core is Single Source of Truth**
       - All wallet logic, networking, persistence, and hardware integrations in rust/
       - Wraps BDK, redb, NFC, and TapSigner support
       - UniFFI generates FFI bindings automatically

    2. **Async Runtime**
       - Rust core is async-first with Tokio runtime
       - Runtime initialized once via FfiApp::init_on_start
       - Background workloads use act-zero actors on Tokio runtime

    3. **State Reconciliation Pattern**
       - Rust emits typed reconciliation messages via flume channels
       - Platform managers listen for updates and update observable state
       - Flow: UI calls manager.dispatch(action) → Rust mutates state → reconciler updates UI

    4. **FFI Resource Management**
       - UniFFI objects implement AutoCloseable (Kotlin) with destroy() methods
       - Resources register cleanup via UniffiCleaner
       - Must call .close() before nulling to trigger proper cleanup and zeroization

    ### Android-Specific Architecture

    1. **Manager Pattern**
       - Managers extend BaseManager for lifecycle-aware coroutine scopes
       - Use Dispatchers.Main for UI updates
       - FFI calls from Rust are synchronous (not suspending)

    2. **Threading Model - CRITICAL**
       - Rust core handles threading internally via Tokio runtime
       - FFI calls are exposed as synchronous Kotlin functions
       - Database operations (redb) are fast and synchronous
       - DO NOT suggest withContext(Dispatchers.IO) for FFI calls without profiling evidence
       - The Rust side already handles async operations internally

    3. **UniFFI Type Mappings**
       - Rust errors ending in Error become Exception in Kotlin
       - Enum variants with unnamed fields use v1, v2, v3 in Kotlin
       - Enum variants with named fields preserve field names
