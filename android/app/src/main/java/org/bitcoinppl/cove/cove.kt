// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package org.bitcoinppl.cove

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import org.bitcoinppl.cove.device.FfiConverterTypeKeychainError
import org.bitcoinppl.cove.device.KeychainException
import org.bitcoinppl.cove.nfc.FfiConverterTypeNfcMessage
import org.bitcoinppl.cove.nfc.NfcMessage
import org.bitcoinppl.cove.tapcard.FfiConverterTypeTapCardParseError
import org.bitcoinppl.cove.tapcard.FfiConverterTypeTapSigner
import org.bitcoinppl.cove.tapcard.TapCardParseException
import org.bitcoinppl.cove.tapcard.TapSigner
import org.bitcoinppl.cove.types.Address
import org.bitcoinppl.cove.types.AddressAndAmount
import org.bitcoinppl.cove.types.AddressException
import org.bitcoinppl.cove.types.AddressIndex
import org.bitcoinppl.cove.types.AddressInfo
import org.bitcoinppl.cove.types.AddressInfoWithDerivation
import org.bitcoinppl.cove.types.AddressWithNetwork
import org.bitcoinppl.cove.types.Amount
import org.bitcoinppl.cove.types.BitcoinUnit
import org.bitcoinppl.cove.types.BlockSizeLast
import org.bitcoinppl.cove.types.ColorSchemeSelection
import org.bitcoinppl.cove.types.ConfirmDetails
import org.bitcoinppl.cove.types.FeeRate
import org.bitcoinppl.cove.types.FeeRateOptionWithTotalFee
import org.bitcoinppl.cove.types.FeeRateOptions
import org.bitcoinppl.cove.types.FeeRateOptionsWithTotalFee
import org.bitcoinppl.cove.types.FeeSpeed
import org.bitcoinppl.cove.types.FfiColor
import org.bitcoinppl.cove.types.FfiColorScheme
import org.bitcoinppl.cove.types.FfiConverterTypeAddress
import org.bitcoinppl.cove.types.FfiConverterTypeAddressAndAmount
import org.bitcoinppl.cove.types.FfiConverterTypeAddressError
import org.bitcoinppl.cove.types.FfiConverterTypeAddressIndex
import org.bitcoinppl.cove.types.FfiConverterTypeAddressInfo
import org.bitcoinppl.cove.types.FfiConverterTypeAddressInfoWithDerivation
import org.bitcoinppl.cove.types.FfiConverterTypeAddressWithNetwork
import org.bitcoinppl.cove.types.FfiConverterTypeAmount
import org.bitcoinppl.cove.types.FfiConverterTypeBitcoinUnit
import org.bitcoinppl.cove.types.FfiConverterTypeBlockSizeLast
import org.bitcoinppl.cove.types.FfiConverterTypeColorSchemeSelection
import org.bitcoinppl.cove.types.FfiConverterTypeConfirmDetails
import org.bitcoinppl.cove.types.FfiConverterTypeFeeRate
import org.bitcoinppl.cove.types.FfiConverterTypeFeeRateOptionWithTotalFee
import org.bitcoinppl.cove.types.FfiConverterTypeFeeRateOptions
import org.bitcoinppl.cove.types.FfiConverterTypeFeeRateOptionsWithTotalFee
import org.bitcoinppl.cove.types.FfiConverterTypeFeeSpeed
import org.bitcoinppl.cove.types.FfiConverterTypeFfiColor
import org.bitcoinppl.cove.types.FfiConverterTypeFfiColorScheme
import org.bitcoinppl.cove.types.FfiConverterTypeNetwork
import org.bitcoinppl.cove.types.FfiConverterTypeOutPoint
import org.bitcoinppl.cove.types.FfiConverterTypePsbt
import org.bitcoinppl.cove.types.FfiConverterTypeSentAndReceived
import org.bitcoinppl.cove.types.FfiConverterTypeSplitOutput
import org.bitcoinppl.cove.types.FfiConverterTypeTransactionDirection
import org.bitcoinppl.cove.types.FfiConverterTypeTxId
import org.bitcoinppl.cove.types.FfiConverterTypeUtxo
import org.bitcoinppl.cove.types.FfiConverterTypeUtxoList
import org.bitcoinppl.cove.types.FfiConverterTypeUtxoType
import org.bitcoinppl.cove.types.FfiConverterTypeWalletId
import org.bitcoinppl.cove.types.Network
import org.bitcoinppl.cove.types.OutPoint
import org.bitcoinppl.cove.types.Psbt
import org.bitcoinppl.cove.types.SentAndReceived
import org.bitcoinppl.cove.types.SplitOutput
import org.bitcoinppl.cove.types.TransactionDirection
import org.bitcoinppl.cove.types.TxId
import org.bitcoinppl.cove.types.Utxo
import org.bitcoinppl.cove.types.UtxoList
import org.bitcoinppl.cove.types.UtxoType
import org.bitcoinppl.cove.types.WalletId
import org.bitcoinppl.cove.device.RustBuffer as RustBufferKeychainError
import org.bitcoinppl.cove.nfc.RustBuffer as RustBufferNfcMessage
import org.bitcoinppl.cove.tapcard.RustBuffer as RustBufferTapCardParseError
import org.bitcoinppl.cove.tapcard.RustBuffer as RustBufferTapSigner
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddress
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddressAndAmount
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddressError
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddressIndex
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddressInfo
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddressInfoWithDerivation
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAddressWithNetwork
import org.bitcoinppl.cove.types.RustBuffer as RustBufferAmount
import org.bitcoinppl.cove.types.RustBuffer as RustBufferBitcoinUnit
import org.bitcoinppl.cove.types.RustBuffer as RustBufferBlockSizeLast
import org.bitcoinppl.cove.types.RustBuffer as RustBufferColorSchemeSelection
import org.bitcoinppl.cove.types.RustBuffer as RustBufferConfirmDetails
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFeeRate
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFeeRateOptionWithTotalFee
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFeeRateOptions
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFeeRateOptionsWithTotalFee
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFeeSpeed
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFfiColor
import org.bitcoinppl.cove.types.RustBuffer as RustBufferFfiColorScheme
import org.bitcoinppl.cove.types.RustBuffer as RustBufferNetwork
import org.bitcoinppl.cove.types.RustBuffer as RustBufferOutPoint
import org.bitcoinppl.cove.types.RustBuffer as RustBufferPsbt
import org.bitcoinppl.cove.types.RustBuffer as RustBufferSentAndReceived
import org.bitcoinppl.cove.types.RustBuffer as RustBufferSplitOutput
import org.bitcoinppl.cove.types.RustBuffer as RustBufferTransactionDirection
import org.bitcoinppl.cove.types.RustBuffer as RustBufferTxId
import org.bitcoinppl.cove.types.RustBuffer as RustBufferUtxo
import org.bitcoinppl.cove.types.RustBuffer as RustBufferUtxoList
import org.bitcoinppl.cove.types.RustBuffer as RustBufferUtxoType
import org.bitcoinppl.cove.types.RustBuffer as RustBufferWalletId

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_cove_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_cove_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Initial value and increment amount for handles. 
// These ensure that Kotlin-generated handles always have the lowest bit set
private const val UNIFFI_HANDLEMAP_INITIAL = 1.toLong()
private const val UNIFFI_HANDLEMAP_DELTA = 2.toLong()

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    // Start 
    private val counter = java.util.concurrent.atomic.AtomicLong(UNIFFI_HANDLEMAP_INITIAL)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(UNIFFI_HANDLEMAP_DELTA)
        map.put(handle, obj)
        return handle
    }

    // Clone a handle, creating a new one
    fun clone(handle: Long): Long {
        val obj = map.get(handle) ?: throw InternalException("UniffiHandleMap.clone: Invalid handle")
        return insert(obj)
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "coveffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureDroppedCallback : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceClone : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
    : Long
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFutureDroppedCallbackStruct(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureDroppedCallback? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureDroppedCallback? = null,
    ): UniffiForeignFutureDroppedCallbackStruct(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureDroppedCallbackStruct) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureResultVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultVoid.UniffiByValue,)
}
internal interface UniffiCallbackInterfaceAuthManagerReconcilerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceCoinControlManagerReconcilerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceCoinControlManagerReconcilerMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`messages`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceFfiReconcileMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceImportWalletManagerReconcilerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfacePendingWalletManagerReconcilerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSendFlowManagerReconcilerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceSendFlowManagerReconcilerMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`messages`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceTapcardTransportProtocolMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceTapcardTransportProtocolMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceTapcardTransportProtocolMethod2 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`commandApdu`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutDroppedCallback`: UniffiForeignFutureDroppedCallbackStruct,)
}
internal interface UniffiCallbackInterfaceWalletManagerReconcilerMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceWalletManagerReconcilerMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`messages`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceAutoCompleteMethod0 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`word`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,)
}
internal interface UniffiCallbackInterfaceAutoCompleteMethod1 : com.sun.jna.Callback {
    fun callback(`uniffiHandle`: Long,`word`: RustBuffer.ByValue,`uniffiOutReturn`: ByteByReference,uniffiCallStatus: UniffiRustCallStatus,)
}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile")
internal open class UniffiVTableCallbackInterfaceAuthManagerReconciler(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfaceAuthManagerReconcilerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfaceAuthManagerReconcilerMethod0? = null,
    ): UniffiVTableCallbackInterfaceAuthManagerReconciler(`uniffiFree`,`uniffiClone`,`reconcile`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceAuthManagerReconciler) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile", "reconcileMany")
internal open class UniffiVTableCallbackInterfaceCoinControlManagerReconciler(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfaceCoinControlManagerReconcilerMethod0? = null,
    @JvmField internal var `reconcileMany`: UniffiCallbackInterfaceCoinControlManagerReconcilerMethod1? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfaceCoinControlManagerReconcilerMethod0? = null,
        `reconcileMany`: UniffiCallbackInterfaceCoinControlManagerReconcilerMethod1? = null,
    ): UniffiVTableCallbackInterfaceCoinControlManagerReconciler(`uniffiFree`,`uniffiClone`,`reconcile`,`reconcileMany`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceCoinControlManagerReconciler) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
        `reconcileMany` = other.`reconcileMany`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile")
internal open class UniffiVTableCallbackInterfaceFfiReconcile(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfaceFfiReconcileMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfaceFfiReconcileMethod0? = null,
    ): UniffiVTableCallbackInterfaceFfiReconcile(`uniffiFree`,`uniffiClone`,`reconcile`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceFfiReconcile) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile")
internal open class UniffiVTableCallbackInterfaceImportWalletManagerReconciler(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfaceImportWalletManagerReconcilerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfaceImportWalletManagerReconcilerMethod0? = null,
    ): UniffiVTableCallbackInterfaceImportWalletManagerReconciler(`uniffiFree`,`uniffiClone`,`reconcile`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceImportWalletManagerReconciler) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile")
internal open class UniffiVTableCallbackInterfacePendingWalletManagerReconciler(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfacePendingWalletManagerReconcilerMethod0? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfacePendingWalletManagerReconcilerMethod0? = null,
    ): UniffiVTableCallbackInterfacePendingWalletManagerReconciler(`uniffiFree`,`uniffiClone`,`reconcile`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfacePendingWalletManagerReconciler) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile", "reconcileMany")
internal open class UniffiVTableCallbackInterfaceSendFlowManagerReconciler(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfaceSendFlowManagerReconcilerMethod0? = null,
    @JvmField internal var `reconcileMany`: UniffiCallbackInterfaceSendFlowManagerReconcilerMethod1? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfaceSendFlowManagerReconcilerMethod0? = null,
        `reconcileMany`: UniffiCallbackInterfaceSendFlowManagerReconcilerMethod1? = null,
    ): UniffiVTableCallbackInterfaceSendFlowManagerReconciler(`uniffiFree`,`uniffiClone`,`reconcile`,`reconcileMany`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceSendFlowManagerReconciler) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
        `reconcileMany` = other.`reconcileMany`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "setMessage", "appendMessage", "transmitApdu")
internal open class UniffiVTableCallbackInterfaceTapcardTransportProtocol(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `setMessage`: UniffiCallbackInterfaceTapcardTransportProtocolMethod0? = null,
    @JvmField internal var `appendMessage`: UniffiCallbackInterfaceTapcardTransportProtocolMethod1? = null,
    @JvmField internal var `transmitApdu`: UniffiCallbackInterfaceTapcardTransportProtocolMethod2? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `setMessage`: UniffiCallbackInterfaceTapcardTransportProtocolMethod0? = null,
        `appendMessage`: UniffiCallbackInterfaceTapcardTransportProtocolMethod1? = null,
        `transmitApdu`: UniffiCallbackInterfaceTapcardTransportProtocolMethod2? = null,
    ): UniffiVTableCallbackInterfaceTapcardTransportProtocol(`uniffiFree`,`uniffiClone`,`setMessage`,`appendMessage`,`transmitApdu`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceTapcardTransportProtocol) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `setMessage` = other.`setMessage`
        `appendMessage` = other.`appendMessage`
        `transmitApdu` = other.`transmitApdu`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "reconcile", "reconcileMany")
internal open class UniffiVTableCallbackInterfaceWalletManagerReconciler(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `reconcile`: UniffiCallbackInterfaceWalletManagerReconcilerMethod0? = null,
    @JvmField internal var `reconcileMany`: UniffiCallbackInterfaceWalletManagerReconcilerMethod1? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `reconcile`: UniffiCallbackInterfaceWalletManagerReconcilerMethod0? = null,
        `reconcileMany`: UniffiCallbackInterfaceWalletManagerReconcilerMethod1? = null,
    ): UniffiVTableCallbackInterfaceWalletManagerReconciler(`uniffiFree`,`uniffiClone`,`reconcile`,`reconcileMany`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceWalletManagerReconciler) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `reconcile` = other.`reconcile`
        `reconcileMany` = other.`reconcileMany`
    }

}
@Structure.FieldOrder("uniffiFree", "uniffiClone", "autocomplete", "isValidWord")
internal open class UniffiVTableCallbackInterfaceAutoComplete(
    @JvmField internal var `uniffiFree`: UniffiCallbackInterfaceFree? = null,
    @JvmField internal var `uniffiClone`: UniffiCallbackInterfaceClone? = null,
    @JvmField internal var `autocomplete`: UniffiCallbackInterfaceAutoCompleteMethod0? = null,
    @JvmField internal var `isValidWord`: UniffiCallbackInterfaceAutoCompleteMethod1? = null,
) : Structure() {
    class UniffiByValue(
        `uniffiFree`: UniffiCallbackInterfaceFree? = null,
        `uniffiClone`: UniffiCallbackInterfaceClone? = null,
        `autocomplete`: UniffiCallbackInterfaceAutoCompleteMethod0? = null,
        `isValidWord`: UniffiCallbackInterfaceAutoCompleteMethod1? = null,
    ): UniffiVTableCallbackInterfaceAutoComplete(`uniffiFree`,`uniffiClone`,`autocomplete`,`isValidWord`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiVTableCallbackInterfaceAutoComplete) {
        `uniffiFree` = other.`uniffiFree`
        `uniffiClone` = other.`uniffiClone`
        `autocomplete` = other.`autocomplete`
        `isValidWord` = other.`isValidWord`
    }

}

// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is 
// rather `InterfaceTooLargeException`, caused by too many methods 
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib 
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
// 
// The `ffi_uniffi_contract_version` method and all checksum methods are put 
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
    // Integrity check functions only
    fun uniffi_cove_checksum_func_address_error_to_alert_state(
): Short
fun uniffi_cove_checksum_func_after_pin_action_user_message(
): Short
fun uniffi_cove_checksum_func_all_fiat_currencies(
): Short
fun uniffi_cove_checksum_func_coin_control_list_sort_key_to_string(
): Short
fun uniffi_cove_checksum_func_create_transport_error_from_code(
): Short
fun uniffi_cove_checksum_func_default_node_selection(
): Short
fun uniffi_cove_checksum_func_default_wallet_colors(
): Short
fun uniffi_cove_checksum_func_describe_auth_manager_error(
): Short
fun uniffi_cove_checksum_func_describe_multi_format_error(
): Short
fun uniffi_cove_checksum_func_describe_send_flow_error(
): Short
fun uniffi_cove_checksum_func_describe_send_flow_fiat_on_change_error(
): Short
fun uniffi_cove_checksum_func_describe_tap_signer_reader_error(
): Short
fun uniffi_cove_checksum_func_describe_transport_error(
): Short
fun uniffi_cove_checksum_func_describe_wallet_error(
): Short
fun uniffi_cove_checksum_func_describe_wallet_manager_error(
): Short
fun uniffi_cove_checksum_func_discovery_state_is_equal(
): Short
fun uniffi_cove_checksum_func_ffi_min_send_amount(
): Short
fun uniffi_cove_checksum_func_ffi_min_send_sats(
): Short
fun uniffi_cove_checksum_func_fiat_amount_preview_new(
): Short
fun uniffi_cove_checksum_func_fiat_currency_emoji(
): Short
fun uniffi_cove_checksum_func_fiat_currency_suffix(
): Short
fun uniffi_cove_checksum_func_fiat_currency_symbol(
): Short
fun uniffi_cove_checksum_func_fiat_currency_to_string(
): Short
fun uniffi_cove_checksum_func_grouped_plain_words_of(
): Short
fun uniffi_cove_checksum_func_hardware_wallet_is_tap_signer(
): Short
fun uniffi_cove_checksum_func_hash_route(
): Short
fun uniffi_cove_checksum_func_is_fiat_currency_symbol(
): Short
fun uniffi_cove_checksum_func_is_route_equal(
): Short
fun uniffi_cove_checksum_func_is_tap_signer_route_equal(
): Short
fun uniffi_cove_checksum_func_is_valid_chain_code(
): Short
fun uniffi_cove_checksum_func_multi_format_try_from_nfc_message(
): Short
fun uniffi_cove_checksum_func_node_selection_to_node(
): Short
fun uniffi_cove_checksum_func_number_of_words_in_groups(
): Short
fun uniffi_cove_checksum_func_number_of_words_to_word_count(
): Short
fun uniffi_cove_checksum_func_preview_new_legacy_found_address(
): Short
fun uniffi_cove_checksum_func_preview_new_wrapped_found_address(
): Short
fun uniffi_cove_checksum_func_prices_are_equal(
): Short
fun uniffi_cove_checksum_func_string_or_data_try_into_multi_format(
): Short
fun uniffi_cove_checksum_func_tap_signer_confirm_pin_args_new_from_new_pin(
): Short
fun uniffi_cove_checksum_func_tap_signer_error_is_auth_error(
): Short
fun uniffi_cove_checksum_func_tap_signer_error_is_no_backup_error(
): Short
fun uniffi_cove_checksum_func_tap_signer_response_backup_response(
): Short
fun uniffi_cove_checksum_func_tap_signer_response_change_response(
): Short
fun uniffi_cove_checksum_func_tap_signer_response_derive_response(
): Short
fun uniffi_cove_checksum_func_tap_signer_response_setup_response(
): Short
fun uniffi_cove_checksum_func_tap_signer_response_sign_response(
): Short
fun uniffi_cove_checksum_func_tap_signer_setup_complete_new(
): Short
fun uniffi_cove_checksum_func_tap_signer_setup_retry_continue_cmd(
): Short
fun uniffi_cove_checksum_func_transaction_preview_confirmed_new(
): Short
fun uniffi_cove_checksum_func_transaction_preview_unconfirmed_new(
): Short
fun uniffi_cove_checksum_func_transactions_preview_new(
): Short
fun uniffi_cove_checksum_func_update_prices_if_needed(
): Short
fun uniffi_cove_checksum_func_wallet_address_type_less_than(
): Short
fun uniffi_cove_checksum_func_wallet_address_type_to_string(
): Short
fun uniffi_cove_checksum_func_wallet_metadata_hash(
): Short
fun uniffi_cove_checksum_func_wallet_metadata_is_equal(
): Short
fun uniffi_cove_checksum_func_wallet_metadata_preview(
): Short
fun uniffi_cove_checksum_func_wallet_state_is_equal(
): Short
fun uniffi_cove_checksum_func_wallet_type_to_string(
): Short
fun uniffi_cove_checksum_method_authpin_check(
): Short
fun uniffi_cove_checksum_method_autocomplete_autocomplete(
): Short
fun uniffi_cove_checksum_method_autocomplete_is_valid_word(
): Short
fun uniffi_cove_checksum_method_balance_spendable(
): Short
fun uniffi_cove_checksum_method_bbqrjoinresult_final_result(
): Short
fun uniffi_cove_checksum_method_bbqrjoinresult_is_complete(
): Short
fun uniffi_cove_checksum_method_bbqrjoinresult_parts_left(
): Short
fun uniffi_cove_checksum_method_bbqrjoined_get_grouped_words(
): Short
fun uniffi_cove_checksum_method_bbqrjoined_get_seed_words(
): Short
fun uniffi_cove_checksum_method_bip39autocomplete_autocomplete(
): Short
fun uniffi_cove_checksum_method_bip39autocomplete_is_valid_word(
): Short
fun uniffi_cove_checksum_method_bip39autocomplete_next_field_number(
): Short
fun uniffi_cove_checksum_method_bip39wordspecificautocomplete_autocomplete(
): Short
fun uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_bip39_word(
): Short
fun uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_valid_word(
): Short
fun uniffi_cove_checksum_method_bip39wordspecificautocomplete_next_field_number(
): Short
fun uniffi_cove_checksum_method_bitcointransaction_normalize_tx_id(
): Short
fun uniffi_cove_checksum_method_bitcointransaction_tx_id(
): Short
fun uniffi_cove_checksum_method_bitcointransaction_tx_id_hash(
): Short
fun uniffi_cove_checksum_method_boxedroute_route(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_block_height(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_block_height_fmt(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_confirmed_at(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt_with_time(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_fiat_amount(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_id(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_label(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_label_opt(
): Short
fun uniffi_cove_checksum_method_confirmedtransaction_sent_and_received(
): Short
fun uniffi_cove_checksum_method_converter_parse_fiat_str(
): Short
fun uniffi_cove_checksum_method_converter_remove_fiat_suffix(
): Short
fun uniffi_cove_checksum_method_database_dangerous_reset_all_data(
): Short
fun uniffi_cove_checksum_method_database_global_config(
): Short
fun uniffi_cove_checksum_method_database_global_flag(
): Short
fun uniffi_cove_checksum_method_database_historical_prices(
): Short
fun uniffi_cove_checksum_method_database_unsigned_transactions(
): Short
fun uniffi_cove_checksum_method_database_wallets(
): Short
fun uniffi_cove_checksum_method_ffiapp_auth_type(
): Short
fun uniffi_cove_checksum_method_ffiapp_dangerous_wipe_all_data(
): Short
fun uniffi_cove_checksum_method_ffiapp_debug_or_release(
): Short
fun uniffi_cove_checksum_method_ffiapp_dispatch(
): Short
fun uniffi_cove_checksum_method_ffiapp_email_mailto(
): Short
fun uniffi_cove_checksum_method_ffiapp_fees(
): Short
fun uniffi_cove_checksum_method_ffiapp_find_tap_signer_wallet(
): Short
fun uniffi_cove_checksum_method_ffiapp_get_tap_signer_backup(
): Short
fun uniffi_cove_checksum_method_ffiapp_git_short_hash(
): Short
fun uniffi_cove_checksum_method_ffiapp_go_to_selected_wallet(
): Short
fun uniffi_cove_checksum_method_ffiapp_has_wallets(
): Short
fun uniffi_cove_checksum_method_ffiapp_init_on_start(
): Short
fun uniffi_cove_checksum_method_ffiapp_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route(
): Short
fun uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route_after(
): Short
fun uniffi_cove_checksum_method_ffiapp_network(
): Short
fun uniffi_cove_checksum_method_ffiapp_num_wallets(
): Short
fun uniffi_cove_checksum_method_ffiapp_prices(
): Short
fun uniffi_cove_checksum_method_ffiapp_reset_default_route_to(
): Short
fun uniffi_cove_checksum_method_ffiapp_reset_nested_routes_to(
): Short
fun uniffi_cove_checksum_method_ffiapp_save_tap_signer_backup(
): Short
fun uniffi_cove_checksum_method_ffiapp_select_wallet(
): Short
fun uniffi_cove_checksum_method_ffiapp_state(
): Short
fun uniffi_cove_checksum_method_ffiapp_unverified_wallet_ids(
): Short
fun uniffi_cove_checksum_method_ffiapp_version(
): Short
fun uniffi_cove_checksum_method_filehandler_read(
): Short
fun uniffi_cove_checksum_method_fingerprint_as_lowercase(
): Short
fun uniffi_cove_checksum_method_fingerprint_as_uppercase(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_authtype(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_clear_selected_wallet(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_colorscheme(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_delete(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_delete_hashed_pin_code(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_get(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_hashed_pin_code(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_is_in_decoy_mode(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_is_in_main_mode(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_select_wallet(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_selectedfiatcurrency(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_selected_network(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_selected_node(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_selected_wallet(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_set(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_setcolorscheme(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_set_hashed_pin_code(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_set_selected_network(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_set_selected_node(
): Short
fun uniffi_cove_checksum_method_globalconfigtable_wallet_mode(
): Short
fun uniffi_cove_checksum_method_globalflagtable_get(
): Short
fun uniffi_cove_checksum_method_globalflagtable_get_bool_config(
): Short
fun uniffi_cove_checksum_method_globalflagtable_is_terms_accepted(
): Short
fun uniffi_cove_checksum_method_globalflagtable_set(
): Short
fun uniffi_cove_checksum_method_globalflagtable_set_bool_config(
): Short
fun uniffi_cove_checksum_method_globalflagtable_toggle_bool_config(
): Short
fun uniffi_cove_checksum_method_headericonpresenter_background_color(
): Short
fun uniffi_cove_checksum_method_headericonpresenter_icon_color(
): Short
fun uniffi_cove_checksum_method_headericonpresenter_ring_color(
): Short
fun uniffi_cove_checksum_method_labelmanager_delete_labels_for_txn(
): Short
fun uniffi_cove_checksum_method_labelmanager_export(
): Short
fun uniffi_cove_checksum_method_labelmanager_export_default_file_name(
): Short
fun uniffi_cove_checksum_method_labelmanager_has_labels(
): Short
fun uniffi_cove_checksum_method_labelmanager_import(
): Short
fun uniffi_cove_checksum_method_labelmanager_importlabels(
): Short
fun uniffi_cove_checksum_method_labelmanager_insert_or_update_labels_for_txn(
): Short
fun uniffi_cove_checksum_method_labelmanager_transaction_label(
): Short
fun uniffi_cove_checksum_method_mnemonic_all_words(
): Short
fun uniffi_cove_checksum_method_mnemonic_words(
): Short
fun uniffi_cove_checksum_method_multiqr_add_part(
): Short
fun uniffi_cove_checksum_method_multiqr_get_grouped_words(
): Short
fun uniffi_cove_checksum_method_multiqr_handle_scan_result(
): Short
fun uniffi_cove_checksum_method_multiqr_is_bbqr(
): Short
fun uniffi_cove_checksum_method_multiqr_is_seed_qr(
): Short
fun uniffi_cove_checksum_method_multiqr_total_parts(
): Short
fun uniffi_cove_checksum_method_nodeselector_check_and_save_node(
): Short
fun uniffi_cove_checksum_method_nodeselector_check_selected_node(
): Short
fun uniffi_cove_checksum_method_nodeselector_node_list(
): Short
fun uniffi_cove_checksum_method_nodeselector_parse_custom_node(
): Short
fun uniffi_cove_checksum_method_nodeselector_select_preset_node(
): Short
fun uniffi_cove_checksum_method_nodeselector_selected_node(
): Short
fun uniffi_cove_checksum_method_priceresponse_get(
): Short
fun uniffi_cove_checksum_method_priceresponse_get_for_currency(
): Short
fun uniffi_cove_checksum_method_routefactory_coin_control_send(
): Short
fun uniffi_cove_checksum_method_routefactory_cold_wallet_import(
): Short
fun uniffi_cove_checksum_method_routefactory_hot_wallet(
): Short
fun uniffi_cove_checksum_method_routefactory_hot_wallet_import_from_scan(
): Short
fun uniffi_cove_checksum_method_routefactory_is_same_parent_route(
): Short
fun uniffi_cove_checksum_method_routefactory_load_and_reset_nested_to(
): Short
fun uniffi_cove_checksum_method_routefactory_load_and_reset_to(
): Short
fun uniffi_cove_checksum_method_routefactory_load_and_reset_to_after(
): Short
fun uniffi_cove_checksum_method_routefactory_main_wallet_settings(
): Short
fun uniffi_cove_checksum_method_routefactory_nested_settings(
): Short
fun uniffi_cove_checksum_method_routefactory_nested_wallet_settings(
): Short
fun uniffi_cove_checksum_method_routefactory_new_hot_wallet(
): Short
fun uniffi_cove_checksum_method_routefactory_new_wallet_select(
): Short
fun uniffi_cove_checksum_method_routefactory_qr_import(
): Short
fun uniffi_cove_checksum_method_routefactory_secret_words(
): Short
fun uniffi_cove_checksum_method_routefactory_send(
): Short
fun uniffi_cove_checksum_method_routefactory_send_confirm(
): Short
fun uniffi_cove_checksum_method_routefactory_send_hardware_export(
): Short
fun uniffi_cove_checksum_method_routefactory_send_set_amount(
): Short
fun uniffi_cove_checksum_method_routefactory_wallet_settings(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_auth_type(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_checkdecoypin(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_checkwipedatapin(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_delete_decoy_pin(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_delete_wipe_data_pin(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_dispatch(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_is_decoy_pin_enabled(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_is_in_decoy_mode(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_is_wipe_data_pin_enabled(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_locked_at(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_send(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_set_auth_type(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_set_decoy_pin(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_set_locked_at(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_set_wipe_data_pin(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_switch_to_decoy_mode(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_switch_to_main_mode(
): Short
fun uniffi_cove_checksum_method_rustauthmanager_validate_pin_settings(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_button_presentation(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_dispatch(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_id(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_reload_labels(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_selected_utxos(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_unit(
): Short
fun uniffi_cove_checksum_method_rustcoincontrolmanager_utxos(
): Short
fun uniffi_cove_checksum_method_rustimportwalletmanager_dispatch(
): Short
fun uniffi_cove_checksum_method_rustimportwalletmanager_import_wallet(
): Short
fun uniffi_cove_checksum_method_rustimportwalletmanager_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words_grouped(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_card_indexes(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_dispatch(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_get_state(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_number_of_words_count(
): Short
fun uniffi_cove_checksum_method_rustpendingwalletmanager_save_wallet(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_amount(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_amount_sats(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_dispatch(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_display_fiat_amount(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_entering_fiat_amount(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_get_custom_fee_option(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_maxsendminusfees(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_maxsendminusfeesandsmallutxo(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_sanitize_btc_entering_amount(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_sanitize_fiat_entering_amount(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_send_amount_btc(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_send_amount_fiat(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_total_fee_string(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_total_spent_in_btc(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_total_spent_in_fiat(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_utxos(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_validate_address(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_validate_amount(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_validate_fee_percentage(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_wait_for_init(
): Short
fun uniffi_cove_checksum_method_rustsendflowmanager_wallet_id(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_address_at(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_amount_in_fiat(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_balance(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_balance_in_fiat(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_broadcast_transaction(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_convert_and_display_fiat(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_convert_from_fiat_string(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_convert_to_fiat(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_create_transactions_with_fiat_export(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_current_block_height(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_delete_unsigned_transaction(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_delete_wallet(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_dispatch(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_display_amount(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_display_fiat_amount(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_display_sent_and_received_amount(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_fee_rate_options(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_fees(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_finalize_psbt(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_first_address(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_force_update_height(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_force_wallet_scan(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_get_fee_options(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_get_transactions(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_get_unsigned_transactions(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_label_manager(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_listen_for_updates(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_mark_wallet_as_verified(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_master_fingerprint(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_new_coin_control_manager(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_new_send_flow_manager(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_next_address(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations_fmt(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_save_unsigned_transaction(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_selected_fiat_currency(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_sent_and_received_fiat(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_set_wallet_metadata(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_sign_and_broadcast_transaction(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_split_transaction_outputs(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_start_wallet_scan(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_switch_to_different_wallet_address_type(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_transaction_details(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_validate_metadata(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_wallet_metadata(
): Short
fun uniffi_cove_checksum_method_rustwalletmanager_word_validator(
): Short
fun uniffi_cove_checksum_method_seedqr_get_words(
): Short
fun uniffi_cove_checksum_method_seedqr_grouped_plain_words(
): Short
fun uniffi_cove_checksum_method_tapsignerreader_continue_setup(
): Short
fun uniffi_cove_checksum_method_tapsignerreader_last_response(
): Short
fun uniffi_cove_checksum_method_tapsignerreader_run(
): Short
fun uniffi_cove_checksum_method_tapsignerreader_setup(
): Short
fun uniffi_cove_checksum_method_tapsignerreader_sign(
): Short
fun uniffi_cove_checksum_method_transactiondetails_address(
): Short
fun uniffi_cove_checksum_method_transactiondetails_address_spaced_out(
): Short
fun uniffi_cove_checksum_method_transactiondetails_amount(
): Short
fun uniffi_cove_checksum_method_transactiondetails_amount_fiat(
): Short
fun uniffi_cove_checksum_method_transactiondetails_amount_fiat_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_amount_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_block_number(
): Short
fun uniffi_cove_checksum_method_transactiondetails_block_number_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_confirmation_date_time(
): Short
fun uniffi_cove_checksum_method_transactiondetails_fee_fiat_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_fee_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_is_confirmed(
): Short
fun uniffi_cove_checksum_method_transactiondetails_is_received(
): Short
fun uniffi_cove_checksum_method_transactiondetails_is_sent(
): Short
fun uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fiat_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fmt(
): Short
fun uniffi_cove_checksum_method_transactiondetails_transaction_label(
): Short
fun uniffi_cove_checksum_method_transactiondetails_transaction_url(
): Short
fun uniffi_cove_checksum_method_transactiondetails_tx_id(
): Short
fun uniffi_cove_checksum_method_unconfirmedtransaction_fiat_amount(
): Short
fun uniffi_cove_checksum_method_unconfirmedtransaction_id(
): Short
fun uniffi_cove_checksum_method_unconfirmedtransaction_label(
): Short
fun uniffi_cove_checksum_method_unconfirmedtransaction_last_seen(
): Short
fun uniffi_cove_checksum_method_unconfirmedtransaction_sent_and_received(
): Short
fun uniffi_cove_checksum_method_unsignedtransaction_details(
): Short
fun uniffi_cove_checksum_method_unsignedtransaction_id(
): Short
fun uniffi_cove_checksum_method_unsignedtransaction_label(
): Short
fun uniffi_cove_checksum_method_unsignedtransaction_sending_amount(
): Short
fun uniffi_cove_checksum_method_unsignedtransaction_spending_amount(
): Short
fun uniffi_cove_checksum_method_unsignedtransactionrecord_confirm_details(
): Short
fun uniffi_cove_checksum_method_unsignedtransactionrecord_created_at(
): Short
fun uniffi_cove_checksum_method_unsignedtransactionrecord_tx_id(
): Short
fun uniffi_cove_checksum_method_unsignedtransactionrecord_wallet_id(
): Short
fun uniffi_cove_checksum_method_unsignedtransactionstable_gettx(
): Short
fun uniffi_cove_checksum_method_unsignedtransactionstable_gettxthrow(
): Short
fun uniffi_cove_checksum_method_wallet_id(
): Short
fun uniffi_cove_checksum_method_walletstable_all(
): Short
fun uniffi_cove_checksum_method_walletstable_all_sorted_active(
): Short
fun uniffi_cove_checksum_method_walletstable_is_empty(
): Short
fun uniffi_cove_checksum_method_walletstable_len(
): Short
fun uniffi_cove_checksum_method_wordvalidator_is_complete(
): Short
fun uniffi_cove_checksum_method_wordvalidator_is_word_correct(
): Short
fun uniffi_cove_checksum_method_wordvalidator_possible_words(
): Short
fun uniffi_cove_checksum_constructor_addressargs_new(
): Short
fun uniffi_cove_checksum_constructor_authpin_new(
): Short
fun uniffi_cove_checksum_constructor_balance_zero(
): Short
fun uniffi_cove_checksum_constructor_bip39autocomplete_new(
): Short
fun uniffi_cove_checksum_constructor_bip39wordspecificautocomplete_new(
): Short
fun uniffi_cove_checksum_constructor_bitcointransaction_new(
): Short
fun uniffi_cove_checksum_constructor_bitcointransaction_tryfromdata(
): Short
fun uniffi_cove_checksum_constructor_bitcointransaction_tryfromnfcmessage(
): Short
fun uniffi_cove_checksum_constructor_bitcointransaction_tryfromstringordata(
): Short
fun uniffi_cove_checksum_constructor_boxedroute_new(
): Short
fun uniffi_cove_checksum_constructor_coincontrolmanagerstate_preview_new(
): Short
fun uniffi_cove_checksum_constructor_converter_new(
): Short
fun uniffi_cove_checksum_constructor_database_new(
): Short
fun uniffi_cove_checksum_constructor_ffiapp_new(
): Short
fun uniffi_cove_checksum_constructor_filehandler_new(
): Short
fun uniffi_cove_checksum_constructor_fingerprint_new(
): Short
fun uniffi_cove_checksum_constructor_headericonpresenter_new(
): Short
fun uniffi_cove_checksum_constructor_labelmanager_new(
): Short
fun uniffi_cove_checksum_constructor_mnemonic_new(
): Short
fun uniffi_cove_checksum_constructor_mnemonic_preview(
): Short
fun uniffi_cove_checksum_constructor_multiqr_new_from_string(
): Short
fun uniffi_cove_checksum_constructor_multiqr_try_new(
): Short
fun uniffi_cove_checksum_constructor_multiqr_try_new_from_data(
): Short
fun uniffi_cove_checksum_constructor_nodeselector_new(
): Short
fun uniffi_cove_checksum_constructor_routefactory_new(
): Short
fun uniffi_cove_checksum_constructor_rustauthmanager_new(
): Short
fun uniffi_cove_checksum_constructor_rustcoincontrolmanager_preview_new(
): Short
fun uniffi_cove_checksum_constructor_rustimportwalletmanager_new(
): Short
fun uniffi_cove_checksum_constructor_rustpendingwalletmanager_new(
): Short
fun uniffi_cove_checksum_constructor_rustwalletmanager_new(
): Short
fun uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet(
): Short
fun uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet_with_metadata(
): Short
fun uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_tap_signer(
): Short
fun uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_xpub(
): Short
fun uniffi_cove_checksum_constructor_seedqr_new_from_data(
): Short
fun uniffi_cove_checksum_constructor_seedqr_new_from_str(
): Short
fun uniffi_cove_checksum_constructor_setupcmd_try_new(
): Short
fun uniffi_cove_checksum_constructor_tapsignerreader_new(
): Short
fun uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_received(
): Short
fun uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_sent(
): Short
fun uniffi_cove_checksum_constructor_transactiondetails_preview_new_confirmed(
): Short
fun uniffi_cove_checksum_constructor_transactiondetails_preview_new_with_label(
): Short
fun uniffi_cove_checksum_constructor_transactiondetails_preview_pending_received(
): Short
fun uniffi_cove_checksum_constructor_transactiondetails_preview_pending_sent(
): Short
fun uniffi_cove_checksum_constructor_unsignedtransaction_preview_new(
): Short
fun uniffi_cove_checksum_constructor_wallet_new_from_export(
): Short
fun uniffi_cove_checksum_constructor_wallet_new_from_xpub(
): Short
fun uniffi_cove_checksum_constructor_wallet_previewnewwallet(
): Short
fun uniffi_cove_checksum_constructor_wordvalidator_preview(
): Short
fun uniffi_cove_checksum_method_authmanagerreconciler_reconcile(
): Short
fun uniffi_cove_checksum_method_coincontrolmanagerreconciler_reconcile(
): Short
fun uniffi_cove_checksum_method_coincontrolmanagerreconciler_reconcile_many(
): Short
fun uniffi_cove_checksum_method_ffireconcile_reconcile(
): Short
fun uniffi_cove_checksum_method_importwalletmanagerreconciler_reconcile(
): Short
fun uniffi_cove_checksum_method_pendingwalletmanagerreconciler_reconcile(
): Short
fun uniffi_cove_checksum_method_sendflowmanagerreconciler_reconcile(
): Short
fun uniffi_cove_checksum_method_sendflowmanagerreconciler_reconcile_many(
): Short
fun uniffi_cove_checksum_method_tapcardtransportprotocol_set_message(
): Short
fun uniffi_cove_checksum_method_tapcardtransportprotocol_append_message(
): Short
fun uniffi_cove_checksum_method_tapcardtransportprotocol_transmit_apdu(
): Short
fun uniffi_cove_checksum_method_walletmanagerreconciler_reconcile(
): Short
fun uniffi_cove_checksum_method_walletmanagerreconciler_reconcile_many(
): Short
fun ffi_cove_uniffi_contract_version(
): Int

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            val componentName = "cove"
            // For large crates we prevent `MethodTooLargeException` (see #2340)
            // N.B. the name of the extension is very misleading, since it is 
            // rather `InterfaceTooLargeException`, caused by too many methods 
            // in the interface for large crates.
            //
            // By splitting the otherwise huge interface into two parts
            // * UniffiLib (this)
            // * IntegrityCheckingUniffiLib
            // And all checksum methods are put into `IntegrityCheckingUniffiLib`
            // we allow for ~2x as many methods in the UniffiLib interface.
            // 
            // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
            // so that we can (optionally!) call `uniffiCheckApiChecksums`...
            loadIndirect<IntegrityCheckingUniffiLib>(componentName)
                .also { lib: IntegrityCheckingUniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
            // ... and then we load the library as `UniffiLib`
            // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
            // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
            // error. So we must call `loadIndirect` twice. For crates large enough
            // to trigger this issue, the performance impact is negligible, running on
            // a macOS M1 machine the `loadIndirect` call takes ~50ms.
            val lib = loadIndirect<UniffiLib>(componentName)
            // No need to check the contract version and checksums, since 
            // we already did that with `IntegrityCheckingUniffiLib` above.
            uniffiCallbackInterfaceAutoComplete.register(lib)
            uniffiCallbackInterfaceAuthManagerReconciler.register(lib)
            uniffiCallbackInterfaceCoinControlManagerReconciler.register(lib)
            uniffiCallbackInterfaceFfiReconcile.register(lib)
            uniffiCallbackInterfaceImportWalletManagerReconciler.register(lib)
            uniffiCallbackInterfacePendingWalletManagerReconciler.register(lib)
            uniffiCallbackInterfaceSendFlowManagerReconciler.register(lib)
            uniffiCallbackInterfaceTapcardTransportProtocol.register(lib)
            uniffiCallbackInterfaceWalletManagerReconciler.register(lib)
            org.bitcoinppl.cove.tapcard.uniffiEnsureInitialized()
            org.bitcoinppl.cove.device.uniffiEnsureInitialized()
            org.bitcoinppl.cove.nfc.uniffiEnsureInitialized()
            org.bitcoinppl.cove.types.uniffiEnsureInitialized()
            // Loading of library with integrity check done.
            lib
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    // FFI functions
    fun uniffi_cove_fn_clone_addressargs(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_addressargs(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_addressargs_new(`address`: Long,`changeAddress`: RustBuffer.ByValue,`direction`: RustBufferTransactionDirection.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_authpin(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_authpin(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_authpin_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_authpin_check(`ptr`: Long,`pin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_clone_autocomplete(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_autocomplete(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_init_callback_vtable_autocomplete(`vtable`: UniffiVTableCallbackInterfaceAutoComplete,
): Unit
fun uniffi_cove_fn_method_autocomplete_autocomplete(`ptr`: Long,`word`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_autocomplete_is_valid_word(`ptr`: Long,`word`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_clone_balance(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_balance(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_balance_zero(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_balance_spendable(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_bbqrjoinresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_bbqrjoinresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_bbqrjoinresult_final_result(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_bbqrjoinresult_is_complete(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_bbqrjoinresult_parts_left(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_cove_fn_clone_bbqrjoined(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_bbqrjoined(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_bbqrjoined_get_grouped_words(`ptr`: Long,`chunks`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_bbqrjoined_get_seed_words(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_bip329labels(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_bip329labels(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_bip39autocomplete(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_bip39autocomplete(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_bip39autocomplete_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_bip39autocomplete_autocomplete(`ptr`: Long,`word`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_bip39autocomplete_is_valid_word(`ptr`: Long,`word`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_bip39autocomplete_next_field_number(`ptr`: Long,`currentFieldNumber`: Byte,`enteredWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_clone_bip39wordspecificautocomplete(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_bip39wordspecificautocomplete(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_bip39wordspecificautocomplete_new(`wordNumber`: Short,`numberOfWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_bip39wordspecificautocomplete_autocomplete(`ptr`: Long,`word`: RustBuffer.ByValue,`allWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_bip39wordspecificautocomplete_is_bip39_word(`ptr`: Long,`word`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_bip39wordspecificautocomplete_is_valid_word(`ptr`: Long,`word`: RustBuffer.ByValue,`allWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_bip39wordspecificautocomplete_next_field_number(`ptr`: Long,`currentFieldNumber`: Byte,`enteredWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_clone_bitcointransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_bitcointransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_bitcointransaction_new(`txHex`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_bitcointransaction_tryfromdata(`data`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_bitcointransaction_tryfromnfcmessage(`nfcMessage`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_bitcointransaction_tryfromstringordata(`stringOrData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_bitcointransaction_normalize_tx_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_bitcointransaction_tx_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_bitcointransaction_tx_id_hash(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_boxedroute(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_boxedroute(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_boxedroute_new(`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_boxedroute_route(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_coincontrolmanagerstate(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_coincontrolmanagerstate(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_coincontrolmanagerstate_preview_new(`outputCount`: Byte,`changeCount`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_confirmedtransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_confirmedtransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_confirmedtransaction_block_height(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_cove_fn_method_confirmedtransaction_block_height_fmt(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_confirmedtransaction_confirmed_at(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt_with_time(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_confirmedtransaction_fiat_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_confirmedtransaction_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_confirmedtransaction_label(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_confirmedtransaction_label_opt(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_confirmedtransaction_sent_and_received(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_converter(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_converter(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_converter_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_converter_parse_fiat_str(`ptr`: Long,`fiatAmount`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun uniffi_cove_fn_method_converter_remove_fiat_suffix(`ptr`: Long,`fiatAmount`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_database(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_database(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_database_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_database_dangerous_reset_all_data(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_database_global_config(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_database_global_flag(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_database_historical_prices(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_database_unsigned_transactions(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_database_wallets(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_ffiapp(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_ffiapp(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_ffiapp_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_ffiapp_auth_type(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_dangerous_wipe_all_data(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_debug_or_release(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_email_mailto(`ptr`: Long,`ios`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_fees(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_find_tap_signer_wallet(`ptr`: Long,`tapSigner`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_get_tap_signer_backup(`ptr`: Long,`tapSigner`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_git_short_hash(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_go_to_selected_wallet(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_has_wallets(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_ffiapp_init_on_start(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_ffiapp_listen_for_updates(`ptr`: Long,`updater`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_load_and_reset_default_route(`ptr`: Long,`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_load_and_reset_default_route_after(`ptr`: Long,`route`: RustBuffer.ByValue,`afterMillis`: Int,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_network(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferNetwork.ByValue
fun uniffi_cove_fn_method_ffiapp_num_wallets(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun uniffi_cove_fn_method_ffiapp_prices(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_ffiapp_reset_default_route_to(`ptr`: Long,`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_reset_nested_routes_to(`ptr`: Long,`defaultRoute`: RustBuffer.ByValue,`nestedRoutes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_save_tap_signer_backup(`ptr`: Long,`tapSigner`: Long,`backup`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_ffiapp_select_wallet(`ptr`: Long,`id`: RustBufferWalletId.ByValue,`nextRoute`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_ffiapp_state(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_unverified_wallet_ids(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_ffiapp_version(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_fiatclient(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_fiatclient(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_filehandler(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_filehandler(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_filehandler_new(`filePath`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_filehandler_read(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_filteredutxos(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_filteredutxos(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_fingerprint(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_fingerprint(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_fingerprint_new(`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_fingerprint_as_lowercase(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_fingerprint_as_uppercase(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_foundjson(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_foundjson(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_globalconfigtable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_globalconfigtable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_authtype(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_globalconfigtable_clear_selected_wallet(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_colorscheme(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferColorSchemeSelection.ByValue
fun uniffi_cove_fn_method_globalconfigtable_delete(`ptr`: Long,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_delete_hashed_pin_code(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_get(`ptr`: Long,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_globalconfigtable_hashed_pin_code(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_globalconfigtable_is_in_decoy_mode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_globalconfigtable_is_in_main_mode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_globalconfigtable_select_wallet(`ptr`: Long,`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_selectedfiatcurrency(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_globalconfigtable_selected_network(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferNetwork.ByValue
fun uniffi_cove_fn_method_globalconfigtable_selected_node(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_globalconfigtable_selected_wallet(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_globalconfigtable_set(`ptr`: Long,`key`: RustBuffer.ByValue,`value`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_setcolorscheme(`ptr`: Long,`colorScheme`: RustBufferColorSchemeSelection.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_set_hashed_pin_code(`ptr`: Long,`hashedPinCode`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_set_selected_network(`ptr`: Long,`network`: RustBufferNetwork.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_set_selected_node(`ptr`: Long,`node`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalconfigtable_wallet_mode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_globalflagtable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_globalflagtable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalflagtable_get(`ptr`: Long,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_globalflagtable_get_bool_config(`ptr`: Long,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_globalflagtable_is_terms_accepted(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_globalflagtable_set(`ptr`: Long,`key`: RustBuffer.ByValue,`value`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalflagtable_set_bool_config(`ptr`: Long,`key`: RustBuffer.ByValue,`value`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_globalflagtable_toggle_bool_config(`ptr`: Long,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_hardwareexport(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_hardwareexport(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_headericonpresenter(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_headericonpresenter(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_headericonpresenter_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_headericonpresenter_background_color(`ptr`: Long,`state`: RustBuffer.ByValue,`direction`: RustBufferTransactionDirection.ByValue,`colorScheme`: RustBufferFfiColorScheme.ByValue,`confirmationCount`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferFfiColor.ByValue
fun uniffi_cove_fn_method_headericonpresenter_icon_color(`ptr`: Long,`state`: RustBuffer.ByValue,`direction`: RustBufferTransactionDirection.ByValue,`colorScheme`: RustBufferFfiColorScheme.ByValue,`confirmationCount`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferFfiColor.ByValue
fun uniffi_cove_fn_method_headericonpresenter_ring_color(`ptr`: Long,`state`: RustBuffer.ByValue,`colorScheme`: RustBufferFfiColorScheme.ByValue,`direction`: RustBufferTransactionDirection.ByValue,`confirmations`: Long,`ringNumber`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferFfiColor.ByValue
fun uniffi_cove_fn_clone_historicalpricetable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_historicalpricetable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_historicalpricesresponse(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_historicalpricesresponse(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_labelmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_labelmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_labelmanager_new(`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_labelmanager_delete_labels_for_txn(`ptr`: Long,`txId`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_labelmanager_export(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_labelmanager_export_default_file_name(`ptr`: Long,`name`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_labelmanager_has_labels(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_labelmanager_import(`ptr`: Long,`jsonl`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_labelmanager_importlabels(`ptr`: Long,`labels`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_labelmanager_insert_or_update_labels_for_txn(`ptr`: Long,`details`: Long,`label`: RustBuffer.ByValue,`origin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_labelmanager_transaction_label(`ptr`: Long,`txId`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_labelstable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_labelstable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_mnemonic(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_mnemonic(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_mnemonic_new(`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_mnemonic_preview(`numberOfBip39Words`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_mnemonic_all_words(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_mnemonic_words(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_multiqr(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_multiqr(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_multiqr_new_from_string(`qr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_multiqr_try_new(`qr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_multiqr_try_new_from_data(`data`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_multiqr_add_part(`ptr`: Long,`qr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_multiqr_get_grouped_words(`ptr`: Long,`qr`: RustBuffer.ByValue,`groupsOf`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_multiqr_handle_scan_result(`ptr`: Long,`qr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_multiqr_is_bbqr(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_multiqr_is_seed_qr(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_multiqr_total_parts(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_cove_fn_clone_nodeselector(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_nodeselector(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_nodeselector_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_nodeselector_check_and_save_node(`ptr`: Long,`node`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_method_nodeselector_check_selected_node(`ptr`: Long,`node`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_method_nodeselector_node_list(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_nodeselector_parse_custom_node(`ptr`: Long,`url`: RustBuffer.ByValue,`name`: RustBuffer.ByValue,`enteredName`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_nodeselector_select_preset_node(`ptr`: Long,`name`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_nodeselector_selected_node(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_pendingwallet(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_pendingwallet(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_priceresponse(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_priceresponse(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_priceresponse_get(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_priceresponse_get_for_currency(`ptr`: Long,`currency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_pushtx(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_pushtx(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_routefactory(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_routefactory(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_routefactory_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_routefactory_coin_control_send(`ptr`: Long,`id`: RustBufferWalletId.ByValue,`utxos`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_cold_wallet_import(`ptr`: Long,`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_hot_wallet(`ptr`: Long,`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_hot_wallet_import_from_scan(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_is_same_parent_route(`ptr`: Long,`route`: RustBuffer.ByValue,`routeToCheck`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_routefactory_load_and_reset_nested_to(`ptr`: Long,`defaultRoute`: RustBuffer.ByValue,`nestedRoutes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_load_and_reset_to(`ptr`: Long,`resetTo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_load_and_reset_to_after(`ptr`: Long,`resetTo`: RustBuffer.ByValue,`time`: Int,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_main_wallet_settings(`ptr`: Long,`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_nested_settings(`ptr`: Long,`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_nested_wallet_settings(`ptr`: Long,`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_new_hot_wallet(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_new_wallet_select(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_qr_import(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_secret_words(`ptr`: Long,`walletId`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_send(`ptr`: Long,`send`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_send_confirm(`ptr`: Long,`id`: RustBufferWalletId.ByValue,`details`: Long,`signedTransaction`: RustBuffer.ByValue,`signedPsbt`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_send_hardware_export(`ptr`: Long,`id`: RustBufferWalletId.ByValue,`details`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_send_set_amount(`ptr`: Long,`id`: RustBufferWalletId.ByValue,`address`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_routefactory_wallet_settings(`ptr`: Long,`id`: RustBufferWalletId.ByValue,`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_rustauthmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_rustauthmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_rustauthmanager_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustauthmanager_auth_type(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustauthmanager_checkdecoypin(`ptr`: Long,`pin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustauthmanager_checkwipedatapin(`ptr`: Long,`pin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustauthmanager_delete_decoy_pin(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_delete_wipe_data_pin(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_is_decoy_pin_enabled(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustauthmanager_is_in_decoy_mode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustauthmanager_is_wipe_data_pin_enabled(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustauthmanager_listen_for_updates(`ptr`: Long,`reconciler`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_locked_at(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustauthmanager_send(`ptr`: Long,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_set_auth_type(`ptr`: Long,`authType`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_set_decoy_pin(`ptr`: Long,`pin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_set_locked_at(`ptr`: Long,`lockedAt`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_set_wipe_data_pin(`ptr`: Long,`pin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_switch_to_decoy_mode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_switch_to_main_mode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustauthmanager_validate_pin_settings(`ptr`: Long,`pin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_rustcoincontrolmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_rustcoincontrolmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_rustcoincontrolmanager_preview_new(`outputCount`: Byte,`changeCount`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustcoincontrolmanager_button_presentation(`ptr`: Long,`button`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustcoincontrolmanager_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustcoincontrolmanager_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferWalletId.ByValue
fun uniffi_cove_fn_method_rustcoincontrolmanager_listen_for_updates(`ptr`: Long,`reconciler`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustcoincontrolmanager_reload_labels(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustcoincontrolmanager_selected_utxos(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustcoincontrolmanager_unit(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferBitcoinUnit.ByValue
fun uniffi_cove_fn_method_rustcoincontrolmanager_utxos(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_rustimportwalletmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_rustimportwalletmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_rustimportwalletmanager_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustimportwalletmanager_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustimportwalletmanager_import_wallet(`ptr`: Long,`enteredWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustimportwalletmanager_listen_for_updates(`ptr`: Long,`reconciler`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_rustpendingwalletmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_rustpendingwalletmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_rustpendingwalletmanager_new(`numberOfWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words_grouped(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustpendingwalletmanager_card_indexes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustpendingwalletmanager_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustpendingwalletmanager_get_state(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustpendingwalletmanager_listen_for_updates(`ptr`: Long,`reconciler`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustpendingwalletmanager_number_of_words_count(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustpendingwalletmanager_save_wallet(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_rustsendflowmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_rustsendflowmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustsendflowmanager_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustsendflowmanager_amount_sats(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustsendflowmanager_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustsendflowmanager_display_fiat_amount(`ptr`: Long,`amount`: Double,`withSuffix`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_entering_fiat_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_get_custom_fee_option(`ptr`: Long,`feeRate`: Long,`feeSpeed`: RustBufferFeeSpeed.ByValue,
): Long
fun uniffi_cove_fn_method_rustsendflowmanager_listen_for_updates(`ptr`: Long,`reconciler`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustsendflowmanager_maxsendminusfees(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_maxsendminusfeesandsmallutxo(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_sanitize_btc_entering_amount(`ptr`: Long,`oldValue`: RustBuffer.ByValue,`newValue`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_sanitize_fiat_entering_amount(`ptr`: Long,`oldValue`: RustBuffer.ByValue,`newValue`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_send_amount_btc(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_send_amount_fiat(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_total_fee_string(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_total_spent_in_btc(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_total_spent_in_fiat(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_utxos(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustsendflowmanager_validate_address(`ptr`: Long,`displayAlert`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustsendflowmanager_validate_amount(`ptr`: Long,`displayAlert`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustsendflowmanager_validate_fee_percentage(`ptr`: Long,`displayAlert`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_rustsendflowmanager_wait_for_init(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustsendflowmanager_wallet_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferWalletId.ByValue
fun uniffi_cove_fn_clone_rustwalletmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_rustwalletmanager(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_rustwalletmanager_new(`id`: RustBufferWalletId.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet_with_metadata(`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_tap_signer(`tapSigner`: Long,`deriveInfo`: RustBuffer.ByValue,`backup`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_xpub(`xpub`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustwalletmanager_address_at(`ptr`: Long,`index`: Int,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_amount_in_fiat(`ptr`: Long,`amount`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_balance(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_balance_in_fiat(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_broadcast_transaction(`ptr`: Long,`signedTransaction`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_convert_and_display_fiat(`ptr`: Long,`amount`: Long,`prices`: Long,`withSuffix`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_convert_from_fiat_string(`ptr`: Long,`fiatAmount`: RustBuffer.ByValue,`prices`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustwalletmanager_convert_to_fiat(`ptr`: Long,`amount`: Long,`prices`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun uniffi_cove_fn_method_rustwalletmanager_create_transactions_with_fiat_export(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_current_block_height(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_delete_unsigned_transaction(`ptr`: Long,`txId`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_delete_wallet(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_dispatch(`ptr`: Long,`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_display_amount(`ptr`: Long,`amount`: Long,`showUnit`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_display_fiat_amount(`ptr`: Long,`amount`: Double,`withSuffix`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_display_sent_and_received_amount(`ptr`: Long,`sentAndReceived`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_fee_rate_options(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_fees(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_finalize_psbt(`ptr`: Long,`psbt`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_first_address(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_force_update_height(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_force_wallet_scan(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_get_fee_options(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_get_transactions(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_get_unsigned_transactions(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_label_manager(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustwalletmanager_listen_for_updates(`ptr`: Long,`reconciler`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_mark_wallet_as_verified(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_master_fingerprint(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_new_coin_control_manager(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_new_send_flow_manager(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_rustwalletmanager_next_address(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations(`ptr`: Long,`blockHeight`: Int,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations_fmt(`ptr`: Long,`blockHeight`: Int,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_save_unsigned_transaction(`ptr`: Long,`details`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_selected_fiat_currency(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_sent_and_received_fiat(`ptr`: Long,`sentAndReceived`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_set_wallet_metadata(`ptr`: Long,`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_sign_and_broadcast_transaction(`ptr`: Long,`psbt`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_split_transaction_outputs(`ptr`: Long,`outputs`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_start_wallet_scan(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_switch_to_different_wallet_address_type(`ptr`: Long,`walletAddressType`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_transaction_details(`ptr`: Long,`txId`: Long,
): Long
fun uniffi_cove_fn_method_rustwalletmanager_validate_metadata(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_rustwalletmanager_wallet_metadata(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_rustwalletmanager_word_validator(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_seedqr(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_seedqr(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_seedqr_new_from_data(`data`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_seedqr_new_from_str(`qr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_seedqr_get_words(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_seedqr_grouped_plain_words(`ptr`: Long,`groupsOf`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_clone_sendflowmanagerstate(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_sendflowmanagerstate(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_setupcmd(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_setupcmd(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_setupcmd_try_new(`factoryPin`: RustBuffer.ByValue,`newPin`: RustBuffer.ByValue,`chainCode`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_tapsignerreader(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_tapsignerreader(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_tapsignerreader_new(`transport`: Long,`cmd`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_method_tapsignerreader_continue_setup(`ptr`: Long,`response`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_method_tapsignerreader_last_response(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_tapsignerreader_run(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_tapsignerreader_setup(`ptr`: Long,`cmd`: Long,
): Long
fun uniffi_cove_fn_method_tapsignerreader_sign(`ptr`: Long,`psbt`: Long,`pin`: RustBuffer.ByValue,
): Long
fun uniffi_cove_fn_clone_transactiondetails(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_transactiondetails(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_received(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_sent(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_transactiondetails_preview_new_confirmed(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_transactiondetails_preview_new_with_label(`label`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_transactiondetails_preview_pending_received(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_transactiondetails_preview_pending_sent(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_transactiondetails_address(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_transactiondetails_address_spaced_out(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_transactiondetails_amount_fiat(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_transactiondetails_amount_fiat_fmt(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_transactiondetails_amount_fmt(`ptr`: Long,`unit`: RustBufferBitcoinUnit.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_block_number(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_block_number_fmt(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_confirmation_date_time(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_fee_fiat_fmt(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_transactiondetails_fee_fmt(`ptr`: Long,`unit`: RustBufferBitcoinUnit.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_is_confirmed(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_transactiondetails_is_received(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_transactiondetails_is_sent(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fiat_fmt(`ptr`: Long,
): Long
fun uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fmt(`ptr`: Long,`unit`: RustBufferBitcoinUnit.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_transaction_label(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_transaction_url(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_transactiondetails_tx_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_unconfirmedtransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_unconfirmedtransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_unconfirmedtransaction_fiat_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_unconfirmedtransaction_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unconfirmedtransaction_label(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_unconfirmedtransaction_last_seen(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unconfirmedtransaction_sent_and_received(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_unsignedtransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_unsignedtransaction(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_unsignedtransaction_preview_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransaction_details(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransaction_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransaction_label(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_unsignedtransaction_sending_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransaction_spending_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_unsignedtransactionrecord(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_unsignedtransactionrecord(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_unsignedtransactionrecord_confirm_details(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransactionrecord_created_at(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransactionrecord_tx_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_unsignedtransactionrecord_wallet_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferWalletId.ByValue
fun uniffi_cove_fn_clone_unsignedtransactionstable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_unsignedtransactionstable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_unsignedtransactionstable_gettx(`ptr`: Long,`txId`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_unsignedtransactionstable_gettxthrow(`ptr`: Long,`txId`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_clone_wallet(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_wallet(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_wallet_new_from_export(`export`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_wallet_new_from_xpub(`xpub`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_constructor_wallet_previewnewwallet(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_wallet_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBufferWalletId.ByValue
fun uniffi_cove_fn_clone_walletdatadb(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_walletdatadb(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_walletkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_walletkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_clone_walletstable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_walletstable(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_method_walletstable_all(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_walletstable_all_sorted_active(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_method_walletstable_is_empty(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_walletstable_len(`ptr`: Long,`network`: RustBufferNetwork.ByValue,`mode`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun uniffi_cove_fn_clone_wordvalidator(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_free_wordvalidator(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_cove_fn_constructor_wordvalidator_preview(`preview`: Byte,`numberOfWords`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_method_wordvalidator_is_complete(`ptr`: Long,`wordNumber`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_wordvalidator_is_word_correct(`ptr`: Long,`word`: RustBuffer.ByValue,`for`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_method_wordvalidator_possible_words(`ptr`: Long,`for`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_init_callback_vtable_authmanagerreconciler(`vtable`: UniffiVTableCallbackInterfaceAuthManagerReconciler,
): Unit
fun uniffi_cove_fn_init_callback_vtable_coincontrolmanagerreconciler(`vtable`: UniffiVTableCallbackInterfaceCoinControlManagerReconciler,
): Unit
fun uniffi_cove_fn_init_callback_vtable_ffireconcile(`vtable`: UniffiVTableCallbackInterfaceFfiReconcile,
): Unit
fun uniffi_cove_fn_init_callback_vtable_importwalletmanagerreconciler(`vtable`: UniffiVTableCallbackInterfaceImportWalletManagerReconciler,
): Unit
fun uniffi_cove_fn_init_callback_vtable_pendingwalletmanagerreconciler(`vtable`: UniffiVTableCallbackInterfacePendingWalletManagerReconciler,
): Unit
fun uniffi_cove_fn_init_callback_vtable_sendflowmanagerreconciler(`vtable`: UniffiVTableCallbackInterfaceSendFlowManagerReconciler,
): Unit
fun uniffi_cove_fn_init_callback_vtable_tapcardtransportprotocol(`vtable`: UniffiVTableCallbackInterfaceTapcardTransportProtocol,
): Unit
fun uniffi_cove_fn_init_callback_vtable_walletmanagerreconciler(`vtable`: UniffiVTableCallbackInterfaceWalletManagerReconciler,
): Unit
fun uniffi_cove_fn_func_address_error_to_alert_state(`error`: RustBufferAddressError.ByValue,`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_after_pin_action_user_message(`action`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_all_fiat_currencies(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_coin_control_list_sort_key_to_string(`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_create_transport_error_from_code(`code`: Short,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_default_node_selection(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_default_wallet_colors(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_auth_manager_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_multi_format_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_send_flow_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_send_flow_fiat_on_change_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_tap_signer_reader_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_transport_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_wallet_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_describe_wallet_manager_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_discovery_state_is_equal(`lhs`: RustBuffer.ByValue,`rhs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_ffi_min_send_amount(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_func_ffi_min_send_sats(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_func_fiat_amount_preview_new(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_fiat_currency_emoji(`fiatCurrency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_fiat_currency_suffix(`fiatCurrency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_fiat_currency_symbol(`fiatCurrency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_fiat_currency_to_string(`fiatCurrency`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_grouped_plain_words_of(`mnemonic`: RustBuffer.ByValue,`groups`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_hardware_wallet_is_tap_signer(`hardwareWallet`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_hash_route(`route`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_func_is_fiat_currency_symbol(`symbol`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_is_route_equal(`route`: RustBuffer.ByValue,`routeToCheck`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_is_tap_signer_route_equal(`lhs`: RustBuffer.ByValue,`rhs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_is_valid_chain_code(`chainCode`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_multi_format_try_from_nfc_message(`nfcMessage`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_node_selection_to_node(`node`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_number_of_words_in_groups(`me`: RustBuffer.ByValue,`of`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_number_of_words_to_word_count(`me`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_preview_new_legacy_found_address(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_preview_new_wrapped_found_address(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_prices_are_equal(`lhs`: Long,`rhs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_string_or_data_try_into_multi_format(`stringOrData`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_confirm_pin_args_new_from_new_pin(`args`: RustBuffer.ByValue,`newPin`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_error_is_auth_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_tap_signer_error_is_no_backup_error(`error`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_tap_signer_response_backup_response(`response`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_response_change_response(`response`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_tap_signer_response_derive_response(`response`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_response_setup_response(`response`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_response_sign_response(`response`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_setup_complete_new(`preview`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_tap_signer_setup_retry_continue_cmd(`preview`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_transaction_preview_confirmed_new(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_transaction_preview_unconfirmed_new(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_transactions_preview_new(`confirmed`: Byte,`unconfirmed`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_update_prices_if_needed(
): Long
fun uniffi_cove_fn_func_wallet_address_type_less_than(`lhs`: RustBuffer.ByValue,`rhs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_wallet_address_type_to_string(`walletAddressType`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_wallet_metadata_hash(`metadata`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_cove_fn_func_wallet_metadata_is_equal(`lhs`: RustBuffer.ByValue,`rhs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_wallet_metadata_preview(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_cove_fn_func_wallet_state_is_equal(`lhs`: RustBuffer.ByValue,`rhs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_cove_fn_func_wallet_type_to_string(`walletType`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_cove_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_cove_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_cove_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_cove_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_cove_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_u8(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_u8(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_cove_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_i8(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_i8(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_cove_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_u16(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_u16(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_cove_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_i16(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_i16(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_cove_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_u32(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_u32(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_cove_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_i32(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_i32(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_cove_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_u64(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_u64(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_cove_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_i64(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_i64(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_cove_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_f32(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_f32(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
fun ffi_cove_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_f64(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_f64(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun ffi_cove_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_rust_buffer(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_cove_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_cove_rust_future_cancel_void(`handle`: Long,
): Unit
fun ffi_cove_rust_future_free_void(`handle`: Long,
): Unit
fun ffi_cove_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_cove_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_cove_checksum_func_address_error_to_alert_state() != 20331.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_after_pin_action_user_message() != 26922.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_all_fiat_currencies() != 51329.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_coin_control_list_sort_key_to_string() != 57975.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_create_transport_error_from_code() != 58675.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_default_node_selection() != 14665.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_default_wallet_colors() != 39034.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_auth_manager_error() != 9186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_multi_format_error() != 25386.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_send_flow_error() != 40406.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_send_flow_fiat_on_change_error() != 38097.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_tap_signer_reader_error() != 18001.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_transport_error() != 49523.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_wallet_error() != 7428.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_describe_wallet_manager_error() != 13784.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_discovery_state_is_equal() != 12390.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_ffi_min_send_amount() != 9250.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_ffi_min_send_sats() != 5524.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_fiat_amount_preview_new() != 6422.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_fiat_currency_emoji() != 7081.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_fiat_currency_suffix() != 50079.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_fiat_currency_symbol() != 58040.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_fiat_currency_to_string() != 50490.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_grouped_plain_words_of() != 45802.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_hardware_wallet_is_tap_signer() != 55324.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_hash_route() != 32817.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_is_fiat_currency_symbol() != 27192.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_is_route_equal() != 25732.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_is_tap_signer_route_equal() != 46761.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_is_valid_chain_code() != 48052.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_multi_format_try_from_nfc_message() != 9847.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_node_selection_to_node() != 57209.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_number_of_words_in_groups() != 14214.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_number_of_words_to_word_count() != 24846.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_preview_new_legacy_found_address() != 36773.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_preview_new_wrapped_found_address() != 57500.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_prices_are_equal() != 41102.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_string_or_data_try_into_multi_format() != 34953.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_confirm_pin_args_new_from_new_pin() != 45606.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_error_is_auth_error() != 29742.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_error_is_no_backup_error() != 60157.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_response_backup_response() != 38008.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_response_change_response() != 53410.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_response_derive_response() != 27872.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_response_setup_response() != 1061.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_response_sign_response() != 40167.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_setup_complete_new() != 48955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_tap_signer_setup_retry_continue_cmd() != 32514.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_transaction_preview_confirmed_new() != 43706.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_transaction_preview_unconfirmed_new() != 49725.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_transactions_preview_new() != 60166.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_update_prices_if_needed() != 27986.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_address_type_less_than() != 14566.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_address_type_to_string() != 36064.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_metadata_hash() != 62639.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_metadata_is_equal() != 19369.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_metadata_preview() != 1229.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_state_is_equal() != 27037.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_func_wallet_type_to_string() != 18258.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_authpin_check() != 17948.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_autocomplete_autocomplete() != 4748.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_autocomplete_is_valid_word() != 18021.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_balance_spendable() != 18496.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bbqrjoinresult_final_result() != 44157.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bbqrjoinresult_is_complete() != 4119.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bbqrjoinresult_parts_left() != 39828.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bbqrjoined_get_grouped_words() != 36018.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bbqrjoined_get_seed_words() != 64693.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39autocomplete_autocomplete() != 21847.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39autocomplete_is_valid_word() != 19081.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39autocomplete_next_field_number() != 24967.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39wordspecificautocomplete_autocomplete() != 34680.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_bip39_word() != 59249.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_valid_word() != 4400.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bip39wordspecificautocomplete_next_field_number() != 39232.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bitcointransaction_normalize_tx_id() != 15620.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bitcointransaction_tx_id() != 48931.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_bitcointransaction_tx_id_hash() != 59940.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_boxedroute_route() != 26050.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_block_height() != 62845.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_block_height_fmt() != 22839.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_confirmed_at() != 21481.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt() != 28835.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt_with_time() != 36703.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_fiat_amount() != 31522.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_id() != 12001.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_label() != 17010.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_label_opt() != 1648.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_confirmedtransaction_sent_and_received() != 59599.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_converter_parse_fiat_str() != 5358.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_converter_remove_fiat_suffix() != 50019.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_database_dangerous_reset_all_data() != 31513.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_database_global_config() != 4476.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_database_global_flag() != 4877.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_database_historical_prices() != 14167.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_database_unsigned_transactions() != 8913.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_database_wallets() != 38115.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_auth_type() != 34438.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_dangerous_wipe_all_data() != 63122.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_debug_or_release() != 37153.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_dispatch() != 48712.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_email_mailto() != 16522.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_fees() != 4920.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_find_tap_signer_wallet() != 59228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_get_tap_signer_backup() != 49269.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_git_short_hash() != 10133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_go_to_selected_wallet() != 5364.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_has_wallets() != 3792.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_init_on_start() != 44630.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_listen_for_updates() != 48795.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route() != 16043.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route_after() != 14335.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_network() != 11705.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_num_wallets() != 28903.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_prices() != 60317.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_reset_default_route_to() != 40613.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_reset_nested_routes_to() != 13093.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_save_tap_signer_backup() != 59132.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_select_wallet() != 61129.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_state() != 19551.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_unverified_wallet_ids() != 31327.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffiapp_version() != 12247.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_filehandler_read() != 31508.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_fingerprint_as_lowercase() != 25321.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_fingerprint_as_uppercase() != 11522.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_authtype() != 38700.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_clear_selected_wallet() != 22146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_colorscheme() != 52955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_delete() != 13364.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_delete_hashed_pin_code() != 4238.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_get() != 52128.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_hashed_pin_code() != 15707.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_is_in_decoy_mode() != 20658.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_is_in_main_mode() != 45671.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_select_wallet() != 8095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_selectedfiatcurrency() != 8392.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_selected_network() != 42948.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_selected_node() != 31353.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_selected_wallet() != 51431.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_set() != 31033.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_setcolorscheme() != 11460.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_set_hashed_pin_code() != 36127.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_set_selected_network() != 31093.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_set_selected_node() != 35090.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalconfigtable_wallet_mode() != 13805.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalflagtable_get() != 42810.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalflagtable_get_bool_config() != 34785.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalflagtable_is_terms_accepted() != 21446.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalflagtable_set() != 23016.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalflagtable_set_bool_config() != 3447.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_globalflagtable_toggle_bool_config() != 12062.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_headericonpresenter_background_color() != 37889.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_headericonpresenter_icon_color() != 50119.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_headericonpresenter_ring_color() != 10146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_delete_labels_for_txn() != 25078.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_export() != 53996.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_export_default_file_name() != 49133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_has_labels() != 1029.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_import() != 22916.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_importlabels() != 51697.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_insert_or_update_labels_for_txn() != 19492.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_labelmanager_transaction_label() != 43320.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_mnemonic_all_words() != 45039.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_mnemonic_words() != 35319.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_multiqr_add_part() != 11179.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_multiqr_get_grouped_words() != 21029.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_multiqr_handle_scan_result() != 3857.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_multiqr_is_bbqr() != 22296.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_multiqr_is_seed_qr() != 10256.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_multiqr_total_parts() != 51119.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_nodeselector_check_and_save_node() != 48519.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_nodeselector_check_selected_node() != 19872.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_nodeselector_node_list() != 23402.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_nodeselector_parse_custom_node() != 54190.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_nodeselector_select_preset_node() != 36330.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_nodeselector_selected_node() != 29849.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_priceresponse_get() != 7353.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_priceresponse_get_for_currency() != 7349.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_coin_control_send() != 12083.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_cold_wallet_import() != 14120.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_hot_wallet() != 7846.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_hot_wallet_import_from_scan() != 63262.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_is_same_parent_route() != 43168.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_load_and_reset_nested_to() != 36095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_load_and_reset_to() != 41201.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_load_and_reset_to_after() != 39743.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_main_wallet_settings() != 49503.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_nested_settings() != 56664.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_nested_wallet_settings() != 12964.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_new_hot_wallet() != 51032.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_new_wallet_select() != 21343.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_qr_import() != 17980.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_secret_words() != 37405.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_send() != 62083.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_send_confirm() != 8941.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_send_hardware_export() != 30298.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_send_set_amount() != 7155.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_routefactory_wallet_settings() != 4563.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_auth_type() != 13301.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_checkdecoypin() != 58987.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_checkwipedatapin() != 25594.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_delete_decoy_pin() != 43659.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_delete_wipe_data_pin() != 30374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_dispatch() != 58198.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_is_decoy_pin_enabled() != 21960.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_is_in_decoy_mode() != 46889.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_is_wipe_data_pin_enabled() != 29022.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_listen_for_updates() != 6029.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_locked_at() != 46905.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_send() != 55296.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_set_auth_type() != 20435.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_set_decoy_pin() != 2272.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_set_locked_at() != 12721.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_set_wipe_data_pin() != 20226.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_switch_to_decoy_mode() != 54579.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_switch_to_main_mode() != 17037.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustauthmanager_validate_pin_settings() != 46433.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_button_presentation() != 38676.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_dispatch() != 16991.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_id() != 50563.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_listen_for_updates() != 58980.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_reload_labels() != 40133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_selected_utxos() != 6695.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_unit() != 91.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustcoincontrolmanager_utxos() != 48699.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustimportwalletmanager_dispatch() != 61781.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustimportwalletmanager_import_wallet() != 11259.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustimportwalletmanager_listen_for_updates() != 20416.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words() != 45973.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words_grouped() != 16310.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_card_indexes() != 62341.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_dispatch() != 51484.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_get_state() != 18821.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_listen_for_updates() != 33763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_number_of_words_count() != 15545.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustpendingwalletmanager_save_wallet() != 15246.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_amount() != 53892.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_amount_sats() != 20712.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_dispatch() != 29847.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_display_fiat_amount() != 62099.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_entering_fiat_amount() != 65483.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_get_custom_fee_option() != 55244.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_listen_for_updates() != 19115.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_maxsendminusfees() != 54180.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_maxsendminusfeesandsmallutxo() != 14164.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_sanitize_btc_entering_amount() != 24133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_sanitize_fiat_entering_amount() != 727.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_send_amount_btc() != 62416.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_send_amount_fiat() != 26629.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_total_fee_string() != 6643.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_total_spent_in_btc() != 5900.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_total_spent_in_fiat() != 50902.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_utxos() != 37154.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_validate_address() != 9975.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_validate_amount() != 60234.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_validate_fee_percentage() != 14879.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_wait_for_init() != 16306.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustsendflowmanager_wallet_id() != 31818.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_address_at() != 57971.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_amount_in_fiat() != 42993.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_balance() != 59906.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_balance_in_fiat() != 47457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_broadcast_transaction() != 32181.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_convert_and_display_fiat() != 57471.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_convert_from_fiat_string() != 49604.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_convert_to_fiat() != 36192.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_create_transactions_with_fiat_export() != 53701.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_current_block_height() != 4472.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_delete_unsigned_transaction() != 65432.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_delete_wallet() != 52855.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_dispatch() != 24198.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_display_amount() != 32412.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_display_fiat_amount() != 15362.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_display_sent_and_received_amount() != 9766.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_fee_rate_options() != 24113.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_fees() != 1824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_finalize_psbt() != 10780.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_first_address() != 55623.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_force_update_height() != 23832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_force_wallet_scan() != 44725.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_get_fee_options() != 64948.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_get_transactions() != 31100.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_get_unsigned_transactions() != 63072.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_label_manager() != 20510.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_listen_for_updates() != 14977.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_mark_wallet_as_verified() != 7383.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_master_fingerprint() != 64933.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_new_coin_control_manager() != 56861.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_new_send_flow_manager() != 50164.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_next_address() != 58685.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations() != 50545.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations_fmt() != 58278.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_save_unsigned_transaction() != 39162.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_selected_fiat_currency() != 3087.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_sent_and_received_fiat() != 17783.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_set_wallet_metadata() != 43968.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_sign_and_broadcast_transaction() != 1951.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_split_transaction_outputs() != 39849.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_start_wallet_scan() != 17019.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_switch_to_different_wallet_address_type() != 22577.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_transaction_details() != 23048.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_validate_metadata() != 50071.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_wallet_metadata() != 65131.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_rustwalletmanager_word_validator() != 64012.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_seedqr_get_words() != 64188.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_seedqr_grouped_plain_words() != 5692.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapsignerreader_continue_setup() != 43346.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapsignerreader_last_response() != 39609.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapsignerreader_run() != 2710.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapsignerreader_setup() != 7185.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapsignerreader_sign() != 27496.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_address() != 44323.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_address_spaced_out() != 61966.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_amount() != 51220.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_amount_fiat() != 34436.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_amount_fiat_fmt() != 60211.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_amount_fmt() != 37638.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_block_number() != 61262.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_block_number_fmt() != 52006.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_confirmation_date_time() != 54859.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_fee_fiat_fmt() != 62198.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_fee_fmt() != 21035.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_is_confirmed() != 54031.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_is_received() != 54839.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_is_sent() != 7556.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fiat_fmt() != 62275.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fmt() != 32923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_transaction_label() != 1186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_transaction_url() != 12235.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_transactiondetails_tx_id() != 53353.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unconfirmedtransaction_fiat_amount() != 59016.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unconfirmedtransaction_id() != 8735.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unconfirmedtransaction_label() != 12913.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unconfirmedtransaction_last_seen() != 29089.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unconfirmedtransaction_sent_and_received() != 30241.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransaction_details() != 8690.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransaction_id() != 41003.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransaction_label() != 12609.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransaction_sending_amount() != 39036.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransaction_spending_amount() != 16734.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransactionrecord_confirm_details() != 62061.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransactionrecord_created_at() != 62407.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransactionrecord_tx_id() != 62136.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransactionrecord_wallet_id() != 24383.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransactionstable_gettx() != 56572.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_unsignedtransactionstable_gettxthrow() != 57009.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_wallet_id() != 31704.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_walletstable_all() != 19569.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_walletstable_all_sorted_active() != 16744.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_walletstable_is_empty() != 57763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_walletstable_len() != 7095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_wordvalidator_is_complete() != 18257.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_wordvalidator_is_word_correct() != 39689.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_wordvalidator_possible_words() != 25098.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_addressargs_new() != 49212.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_authpin_new() != 39860.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_balance_zero() != 55253.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_bip39autocomplete_new() != 41839.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_bip39wordspecificautocomplete_new() != 49814.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_bitcointransaction_new() != 54397.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_bitcointransaction_tryfromdata() != 16116.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_bitcointransaction_tryfromnfcmessage() != 45955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_bitcointransaction_tryfromstringordata() != 18512.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_boxedroute_new() != 62486.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_coincontrolmanagerstate_preview_new() != 20353.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_converter_new() != 25365.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_database_new() != 41458.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_ffiapp_new() != 11955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_filehandler_new() != 50695.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_fingerprint_new() != 38537.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_headericonpresenter_new() != 10425.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_labelmanager_new() != 9520.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_mnemonic_new() != 49454.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_mnemonic_preview() != 3882.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_multiqr_new_from_string() != 2028.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_multiqr_try_new() != 18617.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_multiqr_try_new_from_data() != 36957.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_nodeselector_new() != 61659.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_routefactory_new() != 4959.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustauthmanager_new() != 30134.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustcoincontrolmanager_preview_new() != 16481.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustimportwalletmanager_new() != 63844.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustpendingwalletmanager_new() != 12185.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustwalletmanager_new() != 167.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet() != 14132.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet_with_metadata() != 31333.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_tap_signer() != 33510.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_xpub() != 28304.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_seedqr_new_from_data() != 13640.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_seedqr_new_from_str() != 6520.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_setupcmd_try_new() != 26732.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_tapsignerreader_new() != 50818.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_received() != 6979.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_sent() != 20500.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_transactiondetails_preview_new_confirmed() != 2385.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_transactiondetails_preview_new_with_label() != 21517.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_transactiondetails_preview_pending_received() != 1731.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_transactiondetails_preview_pending_sent() != 378.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_unsignedtransaction_preview_new() != 1909.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_wallet_new_from_export() != 11192.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_wallet_new_from_xpub() != 31726.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_wallet_previewnewwallet() != 56877.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_constructor_wordvalidator_preview() != 4651.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_authmanagerreconciler_reconcile() != 44010.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_coincontrolmanagerreconciler_reconcile() != 34248.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_coincontrolmanagerreconciler_reconcile_many() != 41554.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_ffireconcile_reconcile() != 54238.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_importwalletmanagerreconciler_reconcile() != 37305.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_pendingwalletmanagerreconciler_reconcile() != 39280.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_sendflowmanagerreconciler_reconcile() != 9770.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_sendflowmanagerreconciler_reconcile_many() != 404.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapcardtransportprotocol_set_message() != 41763.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapcardtransportprotocol_append_message() != 6492.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_tapcardtransportprotocol_transmit_apdu() != 5326.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_walletmanagerreconciler_reconcile() != 42803.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_checksum_method_walletmanagerreconciler_reconcile_many() != 61181.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    UniffiLib.INSTANCE
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_WAKE = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl: UniffiRustFutureContinuationCallback {
    override fun callback(data: Long, pollResult: Byte) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun<T, F, E: kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>
): T {
    try {
        do {
            val pollResult = suspendCancellableCoroutine<Byte> { continuation ->
                pollFunc(
                    rustFuture,
                    uniffiRustFutureContinuationCallbackImpl,
                    uniffiContinuationHandleMap.insert(continuation)
                )
            }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) })
        )
    } finally {
        freeFunc(rustFuture)
    }
}
internal inline fun<T> uniffiTraitInterfaceCallAsync(
    crossinline makeCall: suspend () -> T,
    crossinline handleSuccess: (T) -> Unit,
    crossinline handleError: (UniffiRustCallStatus.ByValue) -> Unit,
    uniffiOutDroppedCallback: UniffiForeignFutureDroppedCallbackStruct,
) {
    // Using `GlobalScope` is labeled as a "delicate API" and generally discouraged in Kotlin programs, since it breaks structured concurrency.
    // However, our parent task is a Rust future, so we're going to need to break structure concurrency in any case.
    //
    // Uniffi does its best to support structured concurrency across the FFI.
    // If the Rust future is dropped, `uniffiForeignFutureDroppedCallbackImpl` is called, which will cancel the Kotlin coroutine if it's still running.
    @OptIn(DelicateCoroutinesApi::class)
    val job = GlobalScope.launch {
        try {
            handleSuccess(makeCall())
        } catch(e: kotlin.Exception) {
            handleError(
                UniffiRustCallStatus.create(
                    UNIFFI_CALL_UNEXPECTED_ERROR,
                    FfiConverterString.lower(e.toString()),
                )
            )
        }
    }
    val handle = uniffiForeignFutureHandleMap.insert(job)
    uniffiOutDroppedCallback.uniffiSetValue(UniffiForeignFutureDroppedCallbackStruct(handle, uniffiForeignFutureDroppedCallbackImpl))
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallAsyncWithError(
    crossinline makeCall: suspend () -> T,
    crossinline handleSuccess: (T) -> Unit,
    crossinline handleError: (UniffiRustCallStatus.ByValue) -> Unit,
    crossinline lowerError: (E) -> RustBuffer.ByValue,
    uniffiOutDroppedCallback: UniffiForeignFutureDroppedCallbackStruct,
) {
    // See uniffiTraitInterfaceCallAsync for details on `DelicateCoroutinesApi`
    @OptIn(DelicateCoroutinesApi::class)
    val job = GlobalScope.launch {
        try {
            handleSuccess(makeCall())
        } catch(e: kotlin.Exception) {
            if (e is E) {
                handleError(
                    UniffiRustCallStatus.create(
                        UNIFFI_CALL_ERROR,
                        lowerError(e),
                    )
                )
            } else {
                handleError(
                    UniffiRustCallStatus.create(
                        UNIFFI_CALL_UNEXPECTED_ERROR,
                        FfiConverterString.lower(e.toString()),
                    )
                )
            }
        }
    }
    val handle = uniffiForeignFutureHandleMap.insert(job)
    uniffiOutDroppedCallback.uniffiSetValue(UniffiForeignFutureDroppedCallbackStruct(handle, uniffiForeignFutureDroppedCallbackImpl))
}

internal val uniffiForeignFutureHandleMap = UniffiHandleMap<Job>()

internal object uniffiForeignFutureDroppedCallbackImpl: UniffiForeignFutureDroppedCallback {
    override fun callback(handle: Long) {
        val job = uniffiForeignFutureHandleMap.remove(handle)
        if (!job.isCompleted) {
            job.cancel()
        }
    }
}

// For testing
public fun uniffiForeignFutureHandleCount() = uniffiForeignFutureHandleMap.size

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Placeholder object used to signal that we're constructing an interface with a FFI handle.
 *
 * This is the first argument for interface constructors that input a raw handle. It exists is that
 * so we can avoid signature conflicts when an interface has a regular constructor than inputs a
 * Long.
 *
 * @suppress
 * */
object UniffiWithHandle

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoHandle// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

/**
 * @suppress
 */
public abstract class FfiConverterCallbackInterface<CallbackInterface: Any>: FfiConverter<CallbackInterface, Long> {
    internal val handleMap = UniffiHandleMap<CallbackInterface>()

    internal fun drop(handle: Long) {
        handleMap.remove(handle)
    }

    override fun lift(value: Long): CallbackInterface {
        return handleMap.get(value)
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) = handleMap.insert(value)

    override fun allocationSize(value: CallbackInterface) = 8UL

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8UL

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterFloat: FfiConverter<Float, Float> {
    override fun lift(value: Float): Float {
        return value
    }

    override fun read(buf: ByteBuffer): Float {
        return buf.getFloat()
    }

    override fun lower(value: Float): Float {
        return value
    }

    override fun allocationSize(value: Float) = 4UL

    override fun write(value: Float, buf: ByteBuffer) {
        buf.putFloat(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


/**
 * @suppress
 */
public object FfiConverterDuration: FfiConverterRustBuffer<java.time.Duration> {
    override fun read(buf: ByteBuffer): java.time.Duration {
        // Type mismatch (should be u64) but we check for overflow/underflow below
        val seconds = buf.getLong()
        // Type mismatch (should be u32) but we check for overflow/underflow below
        val nanoseconds = buf.getInt().toLong()
        if (seconds < 0) {
            throw java.time.DateTimeException("Duration exceeds minimum or maximum value supported by uniffi")
        }
        if (nanoseconds < 0) {
            throw java.time.DateTimeException("Duration nanoseconds exceed minimum or maximum supported by uniffi")
        }
        return java.time.Duration.ofSeconds(seconds, nanoseconds)
    }

    // 8 bytes for seconds, 4 bytes for nanoseconds
    override fun allocationSize(value: java.time.Duration) = 12UL

    override fun write(value: java.time.Duration, buf: ByteBuffer) {
        if (value.seconds < 0) {
            // Rust does not support negative Durations
            throw IllegalArgumentException("Invalid duration, must be non-negative")
        }

        if (value.nano < 0) {
            // Java docs provide guarantee that nano will always be positive, so this should be impossible
            // See: https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html
            throw IllegalArgumentException("Invalid duration, nano value must be non-negative")
        }

        // Type mismatch (should be u64) but since Rust doesn't support negative durations we should be OK
        buf.putLong(value.seconds)
        // Type mismatch (should be u32) but since values will always be between 0 and 999,999,999 it should be OK
        buf.putInt(value.nano)
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface AddressArgsInterface {
    
    companion object
}

open class AddressArgs: Disposable, AutoCloseable, AddressArgsInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`address`: Address, `changeAddress`: Address?, `direction`: TransactionDirection) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_addressargs_new(
    
        FfiConverterTypeAddress.lower(`address`),FfiConverterOptionalTypeAddress.lower(`changeAddress`),FfiConverterTypeTransactionDirection.lower(`direction`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_addressargs(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_addressargs(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAddressArgs: FfiConverter<AddressArgs, Long> {
    override fun lower(value: AddressArgs): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): AddressArgs {
        return AddressArgs(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): AddressArgs {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AddressArgs) = 8UL

    override fun write(value: AddressArgs, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface AuthPinInterface {
    
    fun `check`(`pin`: kotlin.String): kotlin.Boolean
    
    companion object
}

open class AuthPin: Disposable, AutoCloseable, AuthPinInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_authpin_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_authpin(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_authpin(handle, status)
        }
    }

    override fun `check`(`pin`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_authpin_check(
        it,
        FfiConverterString.lower(`pin`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAuthPin: FfiConverter<AuthPin, Long> {
    override fun lower(value: AuthPin): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): AuthPin {
        return AuthPin(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): AuthPin {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AuthPin) = 8UL

    override fun write(value: AuthPin, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface AutoComplete {
    
    fun `autocomplete`(`word`: kotlin.String): List<kotlin.String>
    
    fun `isValidWord`(`word`: kotlin.String): kotlin.Boolean
    
    companion object
}

open class AutoCompleteImpl: Disposable, AutoCloseable, AutoComplete
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_autocomplete(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_autocomplete(handle, status)
        }
    }

    override fun `autocomplete`(`word`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_autocomplete_autocomplete(
        it,
        FfiConverterString.lower(`word`),_status)
}
    }
    )
    }
    

    override fun `isValidWord`(`word`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_autocomplete_is_valid_word(
        it,
        FfiConverterString.lower(`word`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceAutoComplete {
    internal object `autocomplete`: UniffiCallbackInterfaceAutoCompleteMethod0 {
        override fun callback(`uniffiHandle`: Long,`word`: RustBuffer.ByValue,`uniffiOutReturn`: RustBuffer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeAutoComplete.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`autocomplete`(
                    FfiConverterString.lift(`word`),
                )
            }
            val writeReturn = { value: List<kotlin.String> -> uniffiOutReturn.setValue(FfiConverterSequenceString.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `isValidWord`: UniffiCallbackInterfaceAutoCompleteMethod1 {
        override fun callback(`uniffiHandle`: Long,`word`: RustBuffer.ByValue,`uniffiOutReturn`: ByteByReference,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeAutoComplete.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`isValidWord`(
                    FfiConverterString.lift(`word`),
                )
            }
            val writeReturn = { value: kotlin.Boolean -> uniffiOutReturn.setValue(FfiConverterBoolean.lower(value)) }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeAutoComplete.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeAutoComplete.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceAutoComplete.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `autocomplete`,
        `isValidWord`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_autocomplete(vtable)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeAutoComplete: FfiConverter<AutoComplete, Long> {
    internal val handleMap = UniffiHandleMap<AutoComplete>()

    override fun lower(value: AutoComplete): Long {
        if (value is AutoCompleteImpl) {
             // Rust-implemented object.  Clone the handle and return it
            return value.uniffiCloneHandle()
         } else {
            // Kotlin object, generate a new vtable handle and return that.
            return handleMap.insert(value)
         }
    }

    override fun lift(value: Long): AutoComplete {
        if ((value and 1.toLong()) == 0.toLong()) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return AutoCompleteImpl(UniffiWithHandle, value)
        } else {
            // Kotlin-generated handle, get the object from the handle map
            return handleMap.remove(value)
        }
    }

    override fun read(buf: ByteBuffer): AutoComplete {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AutoComplete) = 8UL

    override fun write(value: AutoComplete, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface BalanceInterface {
    
    fun `spendable`(): Amount
    
    companion object
}

open class Balance: Disposable, AutoCloseable, BalanceInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_balance(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_balance(handle, status)
        }
    }

    override fun `spendable`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_balance_spendable(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `zero`(): Balance {
            return FfiConverterTypeBalance.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_balance_zero(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBalance: FfiConverter<Balance, Long> {
    override fun lower(value: Balance): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Balance {
        return Balance(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Balance {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Balance) = 8UL

    override fun write(value: Balance, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface BbqrJoinResultInterface {
    
    fun `finalResult`(): kotlin.String
    
    fun `isComplete`(): kotlin.Boolean
    
    fun `partsLeft`(): kotlin.UInt
    
    companion object
}

open class BbqrJoinResult: Disposable, AutoCloseable, BbqrJoinResultInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_bbqrjoinresult(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_bbqrjoinresult(handle, status)
        }
    }

    
    @Throws(MultiQrException::class)override fun `finalResult`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bbqrjoinresult_final_result(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isComplete`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bbqrjoinresult_is_complete(
        it,
        _status)
}
    }
    )
    }
    

    override fun `partsLeft`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bbqrjoinresult_parts_left(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBbqrJoinResult: FfiConverter<BbqrJoinResult, Long> {
    override fun lower(value: BbqrJoinResult): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): BbqrJoinResult {
        return BbqrJoinResult(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): BbqrJoinResult {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: BbqrJoinResult) = 8UL

    override fun write(value: BbqrJoinResult, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface BbqrJoinedInterface {
    
    fun `getGroupedWords`(`chunks`: kotlin.UByte): List<List<kotlin.String>>
    
    fun `getSeedWords`(): List<kotlin.String>
    
    companion object
}

open class BbqrJoined: Disposable, AutoCloseable, BbqrJoinedInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_bbqrjoined(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_bbqrjoined(handle, status)
        }
    }

    
    @Throws(MultiQrException::class)override fun `getGroupedWords`(`chunks`: kotlin.UByte): List<List<kotlin.String>> {
            return FfiConverterSequenceSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bbqrjoined_get_grouped_words(
        it,
        FfiConverterUByte.lower(`chunks`),_status)
}
    }
    )
    }
    

    
    @Throws(MultiQrException::class)override fun `getSeedWords`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bbqrjoined_get_seed_words(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBbqrJoined: FfiConverter<BbqrJoined, Long> {
    override fun lower(value: BbqrJoined): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): BbqrJoined {
        return BbqrJoined(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): BbqrJoined {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: BbqrJoined) = 8UL

    override fun write(value: BbqrJoined, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface Bip329LabelsInterface {
    
    companion object
}

open class Bip329Labels: Disposable, AutoCloseable, Bip329LabelsInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_bip329labels(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_bip329labels(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBip329Labels: FfiConverter<Bip329Labels, Long> {
    override fun lower(value: Bip329Labels): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Bip329Labels {
        return Bip329Labels(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Bip329Labels {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Bip329Labels) = 8UL

    override fun write(value: Bip329Labels, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface Bip39AutoCompleteInterface {
    
    fun `autocomplete`(`word`: kotlin.String): List<kotlin.String>
    
    fun `isValidWord`(`word`: kotlin.String): kotlin.Boolean
    
    /**
     * Find the next invalid or empty field number
     */
    fun `nextFieldNumber`(`currentFieldNumber`: kotlin.UByte, `enteredWords`: List<kotlin.String>): kotlin.UByte
    
    companion object
}

open class Bip39AutoComplete: Disposable, AutoCloseable, Bip39AutoCompleteInterface
, AutoComplete

{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_bip39autocomplete_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_bip39autocomplete(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_bip39autocomplete(handle, status)
        }
    }

    override fun `autocomplete`(`word`: kotlin.String): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39autocomplete_autocomplete(
        it,
        FfiConverterString.lower(`word`),_status)
}
    }
    )
    }
    

    override fun `isValidWord`(`word`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39autocomplete_is_valid_word(
        it,
        FfiConverterString.lower(`word`),_status)
}
    }
    )
    }
    

    
    /**
     * Find the next invalid or empty field number
     */override fun `nextFieldNumber`(`currentFieldNumber`: kotlin.UByte, `enteredWords`: List<kotlin.String>): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39autocomplete_next_field_number(
        it,
        FfiConverterUByte.lower(`currentFieldNumber`),FfiConverterSequenceString.lower(`enteredWords`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBip39AutoComplete: FfiConverter<Bip39AutoComplete, Long> {
    override fun lower(value: Bip39AutoComplete): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Bip39AutoComplete {
        return Bip39AutoComplete(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Bip39AutoComplete {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Bip39AutoComplete) = 8UL

    override fun write(value: Bip39AutoComplete, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface Bip39WordSpecificAutocompleteInterface {
    
    fun `autocomplete`(`word`: kotlin.String, `allWords`: List<List<kotlin.String>>): List<kotlin.String>
    
    fun `isBip39Word`(`word`: kotlin.String): kotlin.Boolean
    
    fun `isValidWord`(`word`: kotlin.String, `allWords`: List<List<kotlin.String>>): kotlin.Boolean
    
    fun `nextFieldNumber`(`currentFieldNumber`: kotlin.UByte, `enteredWords`: List<kotlin.String>): kotlin.UByte
    
    companion object
}

open class Bip39WordSpecificAutocomplete: Disposable, AutoCloseable, Bip39WordSpecificAutocompleteInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`wordNumber`: kotlin.UShort, `numberOfWords`: NumberOfBip39Words) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_bip39wordspecificautocomplete_new(
    
        FfiConverterUShort.lower(`wordNumber`),FfiConverterTypeNumberOfBip39Words.lower(`numberOfWords`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_bip39wordspecificautocomplete(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_bip39wordspecificautocomplete(handle, status)
        }
    }

    override fun `autocomplete`(`word`: kotlin.String, `allWords`: List<List<kotlin.String>>): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39wordspecificautocomplete_autocomplete(
        it,
        FfiConverterString.lower(`word`),FfiConverterSequenceSequenceString.lower(`allWords`),_status)
}
    }
    )
    }
    

    override fun `isBip39Word`(`word`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39wordspecificautocomplete_is_bip39_word(
        it,
        FfiConverterString.lower(`word`),_status)
}
    }
    )
    }
    

    override fun `isValidWord`(`word`: kotlin.String, `allWords`: List<List<kotlin.String>>): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39wordspecificautocomplete_is_valid_word(
        it,
        FfiConverterString.lower(`word`),FfiConverterSequenceSequenceString.lower(`allWords`),_status)
}
    }
    )
    }
    

    override fun `nextFieldNumber`(`currentFieldNumber`: kotlin.UByte, `enteredWords`: List<kotlin.String>): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bip39wordspecificautocomplete_next_field_number(
        it,
        FfiConverterUByte.lower(`currentFieldNumber`),FfiConverterSequenceString.lower(`enteredWords`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBip39WordSpecificAutocomplete: FfiConverter<Bip39WordSpecificAutocomplete, Long> {
    override fun lower(value: Bip39WordSpecificAutocomplete): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Bip39WordSpecificAutocomplete {
        return Bip39WordSpecificAutocomplete(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Bip39WordSpecificAutocomplete {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Bip39WordSpecificAutocomplete) = 8UL

    override fun write(value: Bip39WordSpecificAutocomplete, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface BitcoinTransactionInterface {
    
    fun `normalizeTxId`(): kotlin.String
    
    fun `txId`(): TxId
    
    fun `txIdHash`(): kotlin.String
    
    companion object
}

open class BitcoinTransaction: Disposable, AutoCloseable, BitcoinTransactionInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`txHex`: kotlin.String) :
        this(UniffiWithHandle, 
    uniffiRustCallWithError(BitcoinTransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_bitcointransaction_new(
    
        FfiConverterString.lower(`txHex`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_bitcointransaction(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_bitcointransaction(handle, status)
        }
    }

    override fun `normalizeTxId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bitcointransaction_normalize_tx_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txId`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bitcointransaction_tx_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txIdHash`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_bitcointransaction_tx_id_hash(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
        
    @Throws(BitcoinTransactionException::class) fun `tryFromData`(`data`: kotlin.ByteArray): BitcoinTransaction {
            return FfiConverterTypeBitcoinTransaction.lift(
    uniffiRustCallWithError(BitcoinTransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_bitcointransaction_tryfromdata(
    
        FfiConverterByteArray.lower(`data`),_status)
}
    )
    }
    

        
    @Throws(BitcoinTransactionException::class) fun `tryFromNfcMessage`(`nfcMessage`: NfcMessage): BitcoinTransaction {
            return FfiConverterTypeBitcoinTransaction.lift(
    uniffiRustCallWithError(BitcoinTransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_bitcointransaction_tryfromnfcmessage(
    
        FfiConverterTypeNfcMessage.lower(`nfcMessage`),_status)
}
    )
    }
    

        
    @Throws(BitcoinTransactionException::class) fun `tryFromStringOrData`(`stringOrData`: StringOrData): BitcoinTransaction {
            return FfiConverterTypeBitcoinTransaction.lift(
    uniffiRustCallWithError(BitcoinTransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_bitcointransaction_tryfromstringordata(
    
        FfiConverterTypeStringOrData.lower(`stringOrData`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBitcoinTransaction: FfiConverter<BitcoinTransaction, Long> {
    override fun lower(value: BitcoinTransaction): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): BitcoinTransaction {
        return BitcoinTransaction(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): BitcoinTransaction {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: BitcoinTransaction) = 8UL

    override fun write(value: BitcoinTransaction, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface BoxedRouteInterface {
    
    fun `route`(): Route
    
    companion object
}

open class BoxedRoute: Disposable, AutoCloseable, BoxedRouteInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`route`: Route) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_boxedroute_new(
    
        FfiConverterTypeRoute.lower(`route`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_boxedroute(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_boxedroute(handle, status)
        }
    }

    override fun `route`(): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_boxedroute_route(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeBoxedRoute: FfiConverter<BoxedRoute, Long> {
    override fun lower(value: BoxedRoute): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): BoxedRoute {
        return BoxedRoute(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): BoxedRoute {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: BoxedRoute) = 8UL

    override fun write(value: BoxedRoute, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface CoinControlManagerStateInterface {
    
    companion object
}

open class CoinControlManagerState: Disposable, AutoCloseable, CoinControlManagerStateInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_coincontrolmanagerstate(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_coincontrolmanagerstate(handle, status)
        }
    }

    

    


    
    companion object {
         fun `previewNew`(`outputCount`: kotlin.UByte = 20u, `changeCount`: kotlin.UByte = 4u): CoinControlManagerState {
            return FfiConverterTypeCoinControlManagerState.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_coincontrolmanagerstate_preview_new(
    
        FfiConverterUByte.lower(`outputCount`),FfiConverterUByte.lower(`changeCount`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeCoinControlManagerState: FfiConverter<CoinControlManagerState, Long> {
    override fun lower(value: CoinControlManagerState): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): CoinControlManagerState {
        return CoinControlManagerState(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): CoinControlManagerState {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: CoinControlManagerState) = 8UL

    override fun write(value: CoinControlManagerState, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface ConfirmedTransactionInterface {
    
    fun `blockHeight`(): kotlin.UInt
    
    fun `blockHeightFmt`(): kotlin.String
    
    fun `confirmedAt`(): kotlin.ULong
    
    fun `confirmedAtFmt`(): kotlin.String
    
    fun `confirmedAtFmtWithTime`(): kotlin.String
    
    fun `fiatAmount`(): FiatAmount?
    
    fun `id`(): TxId
    
    fun `label`(): kotlin.String
    
    fun `labelOpt`(): kotlin.String?
    
    fun `sentAndReceived`(): SentAndReceived
    
    companion object
}

open class ConfirmedTransaction: Disposable, AutoCloseable, ConfirmedTransactionInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_confirmedtransaction(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_confirmedtransaction(handle, status)
        }
    }

    override fun `blockHeight`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_block_height(
        it,
        _status)
}
    }
    )
    }
    

    override fun `blockHeightFmt`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_block_height_fmt(
        it,
        _status)
}
    }
    )
    }
    

    override fun `confirmedAt`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_confirmed_at(
        it,
        _status)
}
    }
    )
    }
    

    override fun `confirmedAtFmt`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt(
        it,
        _status)
}
    }
    )
    }
    

    override fun `confirmedAtFmtWithTime`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt_with_time(
        it,
        _status)
}
    }
    )
    }
    

    override fun `fiatAmount`(): FiatAmount? {
            return FfiConverterOptionalTypeFiatAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_fiat_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `id`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `label`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_label(
        it,
        _status)
}
    }
    )
    }
    

    override fun `labelOpt`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_label_opt(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sentAndReceived`(): SentAndReceived {
            return FfiConverterTypeSentAndReceived.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_confirmedtransaction_sent_and_received(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeConfirmedTransaction: FfiConverter<ConfirmedTransaction, Long> {
    override fun lower(value: ConfirmedTransaction): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): ConfirmedTransaction {
        return ConfirmedTransaction(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): ConfirmedTransaction {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ConfirmedTransaction) = 8UL

    override fun write(value: ConfirmedTransaction, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface ConverterInterface {
    
    fun `parseFiatStr`(`fiatAmount`: kotlin.String): kotlin.Double
    
    fun `removeFiatSuffix`(`fiatAmount`: kotlin.String): kotlin.String
    
    companion object
}

open class Converter: Disposable, AutoCloseable, ConverterInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_converter_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_converter(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_converter(handle, status)
        }
    }

    
    @Throws(ConverterException::class)override fun `parseFiatStr`(`fiatAmount`: kotlin.String): kotlin.Double {
            return FfiConverterDouble.lift(
    callWithHandle {
    uniffiRustCallWithError(ConverterException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_converter_parse_fiat_str(
        it,
        FfiConverterString.lower(`fiatAmount`),_status)
}
    }
    )
    }
    

    override fun `removeFiatSuffix`(`fiatAmount`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_converter_remove_fiat_suffix(
        it,
        FfiConverterString.lower(`fiatAmount`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeConverter: FfiConverter<Converter, Long> {
    override fun lower(value: Converter): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Converter {
        return Converter(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Converter {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Converter) = 8UL

    override fun write(value: Converter, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface DatabaseInterface {
    
    fun `dangerousResetAllData`()
    
    fun `globalConfig`(): GlobalConfigTable
    
    fun `globalFlag`(): GlobalFlagTable
    
    fun `historicalPrices`(): HistoricalPriceTable
    
    fun `unsignedTransactions`(): UnsignedTransactionsTable
    
    fun `wallets`(): WalletsTable
    
    companion object
}

open class Database: Disposable, AutoCloseable, DatabaseInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_database_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_database(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_database(handle, status)
        }
    }

    override fun `dangerousResetAllData`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_database_dangerous_reset_all_data(
        it,
        _status)
}
    }
    
    

    override fun `globalConfig`(): GlobalConfigTable {
            return FfiConverterTypeGlobalConfigTable.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_database_global_config(
        it,
        _status)
}
    }
    )
    }
    

    override fun `globalFlag`(): GlobalFlagTable {
            return FfiConverterTypeGlobalFlagTable.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_database_global_flag(
        it,
        _status)
}
    }
    )
    }
    

    override fun `historicalPrices`(): HistoricalPriceTable {
            return FfiConverterTypeHistoricalPriceTable.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_database_historical_prices(
        it,
        _status)
}
    }
    )
    }
    

    override fun `unsignedTransactions`(): UnsignedTransactionsTable {
            return FfiConverterTypeUnsignedTransactionsTable.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_database_unsigned_transactions(
        it,
        _status)
}
    }
    )
    }
    

    override fun `wallets`(): WalletsTable {
            return FfiConverterTypeWalletsTable.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_database_wallets(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeDatabase: FfiConverter<Database, Long> {
    override fun lower(value: Database): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Database {
        return Database(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Database {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Database) = 8UL

    override fun write(value: Database, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Representation of our app over FFI. Essenially a wrapper of [`App`].
 */
public interface FfiAppInterface {
    
    /**
     * Get the auth type for the app
     */
    fun `authType`(): AuthType
    
    /**
     * DANGER: This will wipe all wallet data on this device
     */
    fun `dangerousWipeAllData`()
    
    fun `debugOrRelease`(): kotlin.String
    
    /**
     * Frontend calls this method to send events to the rust application logic
     */
    fun `dispatch`(`action`: AppAction)
    
    fun `emailMailto`(`ios`: kotlin.String): kotlin.String
    
    fun `fees`(): FeeResponse
    
    /**
     * Find tapsigner wallet by card ident
     * Get the backup for the tap signer
     */
    fun `findTapSignerWallet`(`tapSigner`: TapSigner): WalletMetadata?
    
    /**
     * Get the backup for the tap signer
     */
    fun `getTapSignerBackup`(`tapSigner`: TapSigner): kotlin.ByteArray?
    
    fun `gitShortHash`(): kotlin.String
    
    /**
     * Get the selected wallet
     */
    fun `goToSelectedWallet`(): WalletId?
    
    /**
     * Check if there's any wallets
     */
    fun `hasWallets`(): kotlin.Boolean
    
    /**
     * run all initialization tasks here, only called once
     */
    suspend fun `initOnStart`()
    
    fun `listenForUpdates`(`updater`: FfiReconcile)
    
    /**
     * Load and reset the default route after 800ms delay
     */
    fun `loadAndResetDefaultRoute`(`route`: Route)
    
    /**
     * Load and reset the default route
     * Shows a laoding screen, and then resets the default route
     */
    fun `loadAndResetDefaultRouteAfter`(`route`: Route, `afterMillis`: kotlin.UInt)
    
    fun `network`(): Network
    
    /**
     * Number of wallets
     */
    fun `numWallets`(): kotlin.UShort
    
    fun `prices`(): PriceResponse
    
    /**
     * Change the default route, and reset the routes
     */
    fun `resetDefaultRouteTo`(`route`: Route)
    
    /**
     * Reset the default route, with a nested route
     */
    fun `resetNestedRoutesTo`(`defaultRoute`: Route, `nestedRoutes`: List<Route>)
    
    /**
     * Save the backup for the tap signer in the keychain
     */
    fun `saveTapSignerBackup`(`tapSigner`: TapSigner, `backup`: kotlin.ByteArray): kotlin.Boolean
    
    /**
     * Select a wallet
     */
    fun `selectWallet`(`id`: WalletId, `nextRoute`: Route? = null)
    
    fun `state`(): AppState
    
    /**
     * Get wallets that have not been backed up and verified
     */
    fun `unverifiedWalletIds`(): List<WalletId>
    
    fun `version`(): kotlin.String
    
    companion object
}

/**
 * Representation of our app over FFI. Essenially a wrapper of [`App`].
 */
open class FfiApp: Disposable, AutoCloseable, FfiAppInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * FFI constructor which wraps in an Arc
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_ffiapp_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_ffiapp(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_ffiapp(handle, status)
        }
    }

    
    /**
     * Get the auth type for the app
     */override fun `authType`(): AuthType {
            return FfiConverterTypeAuthType.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_auth_type(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * DANGER: This will wipe all wallet data on this device
     */override fun `dangerousWipeAllData`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_dangerous_wipe_all_data(
        it,
        _status)
}
    }
    
    

    override fun `debugOrRelease`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_debug_or_release(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Frontend calls this method to send events to the rust application logic
     */override fun `dispatch`(`action`: AppAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_dispatch(
        it,
        FfiConverterTypeAppAction.lower(`action`),_status)
}
    }
    
    

    override fun `emailMailto`(`ios`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_email_mailto(
        it,
        FfiConverterString.lower(`ios`),_status)
}
    }
    )
    }
    

    
    @Throws(AppException::class)override fun `fees`(): FeeResponse {
            return FfiConverterTypeFeeResponse.lift(
    callWithHandle {
    uniffiRustCallWithError(AppException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_fees(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Find tapsigner wallet by card ident
     * Get the backup for the tap signer
     */override fun `findTapSignerWallet`(`tapSigner`: TapSigner): WalletMetadata? {
            return FfiConverterOptionalTypeWalletMetadata.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_find_tap_signer_wallet(
        it,
        FfiConverterTypeTapSigner.lower(`tapSigner`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the backup for the tap signer
     */override fun `getTapSignerBackup`(`tapSigner`: TapSigner): kotlin.ByteArray? {
            return FfiConverterOptionalByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_get_tap_signer_backup(
        it,
        FfiConverterTypeTapSigner.lower(`tapSigner`),_status)
}
    }
    )
    }
    

    override fun `gitShortHash`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_git_short_hash(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Get the selected wallet
     */override fun `goToSelectedWallet`(): WalletId? {
            return FfiConverterOptionalTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_go_to_selected_wallet(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Check if there's any wallets
     */override fun `hasWallets`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_has_wallets(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * run all initialization tasks here, only called once
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `initOnStart`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_init_on_start(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `listenForUpdates`(`updater`: FfiReconcile)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_listen_for_updates(
        it,
        FfiConverterTypeFfiReconcile.lower(`updater`),_status)
}
    }
    
    

    
    /**
     * Load and reset the default route after 800ms delay
     */override fun `loadAndResetDefaultRoute`(`route`: Route)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_load_and_reset_default_route(
        it,
        FfiConverterTypeRoute.lower(`route`),_status)
}
    }
    
    

    
    /**
     * Load and reset the default route
     * Shows a laoding screen, and then resets the default route
     */override fun `loadAndResetDefaultRouteAfter`(`route`: Route, `afterMillis`: kotlin.UInt)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_load_and_reset_default_route_after(
        it,
        FfiConverterTypeRoute.lower(`route`),FfiConverterUInt.lower(`afterMillis`),_status)
}
    }
    
    

    override fun `network`(): Network {
            return FfiConverterTypeNetwork.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_network(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Number of wallets
     */override fun `numWallets`(): kotlin.UShort {
            return FfiConverterUShort.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_num_wallets(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(AppException::class)override fun `prices`(): PriceResponse {
            return FfiConverterTypePriceResponse.lift(
    callWithHandle {
    uniffiRustCallWithError(AppException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_prices(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Change the default route, and reset the routes
     */override fun `resetDefaultRouteTo`(`route`: Route)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_reset_default_route_to(
        it,
        FfiConverterTypeRoute.lower(`route`),_status)
}
    }
    
    

    
    /**
     * Reset the default route, with a nested route
     */override fun `resetNestedRoutesTo`(`defaultRoute`: Route, `nestedRoutes`: List<Route>)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_reset_nested_routes_to(
        it,
        FfiConverterTypeRoute.lower(`defaultRoute`),FfiConverterSequenceTypeRoute.lower(`nestedRoutes`),_status)
}
    }
    
    

    
    /**
     * Save the backup for the tap signer in the keychain
     */override fun `saveTapSignerBackup`(`tapSigner`: TapSigner, `backup`: kotlin.ByteArray): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_save_tap_signer_backup(
        it,
        FfiConverterTypeTapSigner.lower(`tapSigner`),FfiConverterByteArray.lower(`backup`),_status)
}
    }
    )
    }
    

    
    /**
     * Select a wallet
     */
    @Throws(DatabaseException::class)override fun `selectWallet`(`id`: WalletId, `nextRoute`: Route?)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_select_wallet(
        it,
        FfiConverterTypeWalletId.lower(`id`),FfiConverterOptionalTypeRoute.lower(`nextRoute`),_status)
}
    }
    
    

    override fun `state`(): AppState {
            return FfiConverterTypeAppState.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_state(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Get wallets that have not been backed up and verified
     */override fun `unverifiedWalletIds`(): List<WalletId> {
            return FfiConverterSequenceTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_unverified_wallet_ids(
        it,
        _status)
}
    }
    )
    }
    

    override fun `version`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_ffiapp_version(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFfiApp: FfiConverter<FfiApp, Long> {
    override fun lower(value: FfiApp): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FfiApp {
        return FfiApp(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FfiApp {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FfiApp) = 8UL

    override fun write(value: FfiApp, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface FiatClientInterface {
    
    companion object
}

open class FiatClient: Disposable, AutoCloseable, FiatClientInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_fiatclient(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_fiatclient(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFiatClient: FfiConverter<FiatClient, Long> {
    override fun lower(value: FiatClient): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FiatClient {
        return FiatClient(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FiatClient {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FiatClient) = 8UL

    override fun write(value: FiatClient, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface FileHandlerInterface {
    
    fun `read`(): MultiFormat
    
    companion object
}

open class FileHandler: Disposable, AutoCloseable, FileHandlerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`filePath`: kotlin.String) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_filehandler_new(
    
        FfiConverterString.lower(`filePath`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_filehandler(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_filehandler(handle, status)
        }
    }

    
    @Throws(FileHandlerException::class)override fun `read`(): MultiFormat {
            return FfiConverterTypeMultiFormat.lift(
    callWithHandle {
    uniffiRustCallWithError(FileHandlerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_filehandler_read(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFileHandler: FfiConverter<FileHandler, Long> {
    override fun lower(value: FileHandler): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FileHandler {
        return FileHandler(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FileHandler {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FileHandler) = 8UL

    override fun write(value: FileHandler, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface FilteredUtxosInterface {
    
    companion object
}

open class FilteredUtxos: Disposable, AutoCloseable, FilteredUtxosInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_filteredutxos(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_filteredutxos(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFilteredUtxos: FfiConverter<FilteredUtxos, Long> {
    override fun lower(value: FilteredUtxos): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FilteredUtxos {
        return FilteredUtxos(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FilteredUtxos {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FilteredUtxos) = 8UL

    override fun write(value: FilteredUtxos, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface FingerprintInterface {
    
    fun `asLowercase`(): kotlin.String
    
    fun `asUppercase`(): kotlin.String
    
    companion object
}

open class Fingerprint: Disposable, AutoCloseable, FingerprintInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`id`: WalletId) :
        this(UniffiWithHandle, 
    uniffiRustCallWithError(FingerprintException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_fingerprint_new(
    
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_fingerprint(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_fingerprint(handle, status)
        }
    }

    override fun `asLowercase`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_fingerprint_as_lowercase(
        it,
        _status)
}
    }
    )
    }
    

    override fun `asUppercase`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_fingerprint_as_uppercase(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFingerprint: FfiConverter<Fingerprint, Long> {
    override fun lower(value: Fingerprint): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Fingerprint {
        return Fingerprint(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Fingerprint {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Fingerprint) = 8UL

    override fun write(value: Fingerprint, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface FoundJsonInterface {
    
    companion object
}

open class FoundJson: Disposable, AutoCloseable, FoundJsonInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_foundjson(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_foundjson(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFoundJson: FfiConverter<FoundJson, Long> {
    override fun lower(value: FoundJson): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FoundJson {
        return FoundJson(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FoundJson {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FoundJson) = 8UL

    override fun write(value: FoundJson, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface GlobalConfigTableInterface {
    
    fun `authType`(): AuthType
    
    fun `clearSelectedWallet`()
    
    fun `colorScheme`(): ColorSchemeSelection
    
    fun `delete`(`key`: GlobalConfigKey)
    
    fun `deleteHashedPinCode`()
    
    fun `get`(`key`: GlobalConfigKey): kotlin.String?
    
    fun `hashedPinCode`(): kotlin.String
    
    fun `isInDecoyMode`(): kotlin.Boolean
    
    fun `isInMainMode`(): kotlin.Boolean
    
    fun `selectWallet`(`id`: WalletId)
    
    fun `selectedFiatCurrency`(): FiatCurrency
    
    fun `selectedNetwork`(): Network
    
    fun `selectedNode`(): Node
    
    fun `selectedWallet`(): WalletId?
    
    fun `set`(`key`: GlobalConfigKey, `value`: kotlin.String)
    
    fun `setColorScheme`(`colorScheme`: ColorSchemeSelection)
    
    fun `setHashedPinCode`(`hashedPinCode`: kotlin.String)
    
    fun `setSelectedNetwork`(`network`: Network)
    
    fun `setSelectedNode`(`node`: Node)
    
    fun `walletMode`(): WalletMode
    
    companion object
}

open class GlobalConfigTable: Disposable, AutoCloseable, GlobalConfigTableInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_globalconfigtable(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_globalconfigtable(handle, status)
        }
    }

    override fun `authType`(): AuthType {
            return FfiConverterTypeAuthType.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_authtype(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `clearSelectedWallet`()
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_clear_selected_wallet(
        it,
        _status)
}
    }
    
    

    override fun `colorScheme`(): ColorSchemeSelection {
            return FfiConverterTypeColorSchemeSelection.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_colorscheme(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `delete`(`key`: GlobalConfigKey)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_delete(
        it,
        FfiConverterTypeGlobalConfigKey.lower(`key`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `deleteHashedPinCode`()
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_delete_hashed_pin_code(
        it,
        _status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `get`(`key`: GlobalConfigKey): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_get(
        it,
        FfiConverterTypeGlobalConfigKey.lower(`key`),_status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `hashedPinCode`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_hashed_pin_code(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isInDecoyMode`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_is_in_decoy_mode(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isInMainMode`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_is_in_main_mode(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `selectWallet`(`id`: WalletId)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_select_wallet(
        it,
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    }
    
    

    override fun `selectedFiatCurrency`(): FiatCurrency {
            return FfiConverterTypeFiatCurrency.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_selectedfiatcurrency(
        it,
        _status)
}
    }
    )
    }
    

    override fun `selectedNetwork`(): Network {
            return FfiConverterTypeNetwork.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_selected_network(
        it,
        _status)
}
    }
    )
    }
    

    override fun `selectedNode`(): Node {
            return FfiConverterTypeNode.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_selected_node(
        it,
        _status)
}
    }
    )
    }
    

    override fun `selectedWallet`(): WalletId? {
            return FfiConverterOptionalTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_selected_wallet(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `set`(`key`: GlobalConfigKey, `value`: kotlin.String)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_set(
        it,
        FfiConverterTypeGlobalConfigKey.lower(`key`),FfiConverterString.lower(`value`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `setColorScheme`(`colorScheme`: ColorSchemeSelection)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_setcolorscheme(
        it,
        FfiConverterTypeColorSchemeSelection.lower(`colorScheme`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `setHashedPinCode`(`hashedPinCode`: kotlin.String)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_set_hashed_pin_code(
        it,
        FfiConverterString.lower(`hashedPinCode`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `setSelectedNetwork`(`network`: Network)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_set_selected_network(
        it,
        FfiConverterTypeNetwork.lower(`network`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `setSelectedNode`(`node`: Node)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_set_selected_node(
        it,
        FfiConverterTypeNode.lower(`node`),_status)
}
    }
    
    

    override fun `walletMode`(): WalletMode {
            return FfiConverterTypeWalletMode.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalconfigtable_wallet_mode(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeGlobalConfigTable: FfiConverter<GlobalConfigTable, Long> {
    override fun lower(value: GlobalConfigTable): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): GlobalConfigTable {
        return GlobalConfigTable(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): GlobalConfigTable {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: GlobalConfigTable) = 8UL

    override fun write(value: GlobalConfigTable, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface GlobalFlagTableInterface {
    
    fun `get`(`key`: GlobalFlagKey): kotlin.Boolean
    
    fun `getBoolConfig`(`key`: GlobalFlagKey): kotlin.Boolean
    
    fun `isTermsAccepted`(): kotlin.Boolean
    
    fun `set`(`key`: GlobalFlagKey, `value`: kotlin.Boolean)
    
    fun `setBoolConfig`(`key`: GlobalFlagKey, `value`: kotlin.Boolean)
    
    fun `toggleBoolConfig`(`key`: GlobalFlagKey)
    
    companion object
}

open class GlobalFlagTable: Disposable, AutoCloseable, GlobalFlagTableInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_globalflagtable(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_globalflagtable(handle, status)
        }
    }

    
    @Throws(DatabaseException::class)override fun `get`(`key`: GlobalFlagKey): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalflagtable_get(
        it,
        FfiConverterTypeGlobalFlagKey.lower(`key`),_status)
}
    }
    )
    }
    

    override fun `getBoolConfig`(`key`: GlobalFlagKey): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalflagtable_get_bool_config(
        it,
        FfiConverterTypeGlobalFlagKey.lower(`key`),_status)
}
    }
    )
    }
    

    override fun `isTermsAccepted`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalflagtable_is_terms_accepted(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `set`(`key`: GlobalFlagKey, `value`: kotlin.Boolean)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalflagtable_set(
        it,
        FfiConverterTypeGlobalFlagKey.lower(`key`),FfiConverterBoolean.lower(`value`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `setBoolConfig`(`key`: GlobalFlagKey, `value`: kotlin.Boolean)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalflagtable_set_bool_config(
        it,
        FfiConverterTypeGlobalFlagKey.lower(`key`),FfiConverterBoolean.lower(`value`),_status)
}
    }
    
    

    
    @Throws(DatabaseException::class)override fun `toggleBoolConfig`(`key`: GlobalFlagKey)
        = 
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_globalflagtable_toggle_bool_config(
        it,
        FfiConverterTypeGlobalFlagKey.lower(`key`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeGlobalFlagTable: FfiConverter<GlobalFlagTable, Long> {
    override fun lower(value: GlobalFlagTable): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): GlobalFlagTable {
        return GlobalFlagTable(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): GlobalFlagTable {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: GlobalFlagTable) = 8UL

    override fun write(value: GlobalFlagTable, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface HardwareExportInterface {
    
    companion object
}

open class HardwareExport: Disposable, AutoCloseable, HardwareExportInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_hardwareexport(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_hardwareexport(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeHardwareExport: FfiConverter<HardwareExport, Long> {
    override fun lower(value: HardwareExport): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): HardwareExport {
        return HardwareExport(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): HardwareExport {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: HardwareExport) = 8UL

    override fun write(value: HardwareExport, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface HeaderIconPresenterInterface {
    
    fun `backgroundColor`(`state`: TransactionState, `direction`: TransactionDirection, `colorScheme`: FfiColorScheme, `confirmationCount`: kotlin.Long): FfiColor
    
    fun `iconColor`(`state`: TransactionState, `direction`: TransactionDirection, `colorScheme`: FfiColorScheme, `confirmationCount`: kotlin.Long): FfiColor
    
    fun `ringColor`(`state`: TransactionState, `colorScheme`: FfiColorScheme, `direction`: TransactionDirection, `confirmations`: kotlin.Long, `ringNumber`: kotlin.Long): FfiColor
    
    companion object
}

open class HeaderIconPresenter: Disposable, AutoCloseable, HeaderIconPresenterInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_headericonpresenter_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_headericonpresenter(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_headericonpresenter(handle, status)
        }
    }

    override fun `backgroundColor`(`state`: TransactionState, `direction`: TransactionDirection, `colorScheme`: FfiColorScheme, `confirmationCount`: kotlin.Long): FfiColor {
            return FfiConverterTypeFfiColor.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_headericonpresenter_background_color(
        it,
        FfiConverterTypeTransactionState.lower(`state`),FfiConverterTypeTransactionDirection.lower(`direction`),FfiConverterTypeFfiColorScheme.lower(`colorScheme`),FfiConverterLong.lower(`confirmationCount`),_status)
}
    }
    )
    }
    

    override fun `iconColor`(`state`: TransactionState, `direction`: TransactionDirection, `colorScheme`: FfiColorScheme, `confirmationCount`: kotlin.Long): FfiColor {
            return FfiConverterTypeFfiColor.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_headericonpresenter_icon_color(
        it,
        FfiConverterTypeTransactionState.lower(`state`),FfiConverterTypeTransactionDirection.lower(`direction`),FfiConverterTypeFfiColorScheme.lower(`colorScheme`),FfiConverterLong.lower(`confirmationCount`),_status)
}
    }
    )
    }
    

    override fun `ringColor`(`state`: TransactionState, `colorScheme`: FfiColorScheme, `direction`: TransactionDirection, `confirmations`: kotlin.Long, `ringNumber`: kotlin.Long): FfiColor {
            return FfiConverterTypeFfiColor.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_headericonpresenter_ring_color(
        it,
        FfiConverterTypeTransactionState.lower(`state`),FfiConverterTypeFfiColorScheme.lower(`colorScheme`),FfiConverterTypeTransactionDirection.lower(`direction`),FfiConverterLong.lower(`confirmations`),FfiConverterLong.lower(`ringNumber`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeHeaderIconPresenter: FfiConverter<HeaderIconPresenter, Long> {
    override fun lower(value: HeaderIconPresenter): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): HeaderIconPresenter {
        return HeaderIconPresenter(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): HeaderIconPresenter {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: HeaderIconPresenter) = 8UL

    override fun write(value: HeaderIconPresenter, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface HistoricalPriceTableInterface {
    
    companion object
}

open class HistoricalPriceTable: Disposable, AutoCloseable, HistoricalPriceTableInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_historicalpricetable(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_historicalpricetable(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeHistoricalPriceTable: FfiConverter<HistoricalPriceTable, Long> {
    override fun lower(value: HistoricalPriceTable): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): HistoricalPriceTable {
        return HistoricalPriceTable(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): HistoricalPriceTable {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: HistoricalPriceTable) = 8UL

    override fun write(value: HistoricalPriceTable, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface HistoricalPricesResponseInterface {
    
    companion object
}

open class HistoricalPricesResponse: Disposable, AutoCloseable, HistoricalPricesResponseInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_historicalpricesresponse(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_historicalpricesresponse(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeHistoricalPricesResponse: FfiConverter<HistoricalPricesResponse, Long> {
    override fun lower(value: HistoricalPricesResponse): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): HistoricalPricesResponse {
        return HistoricalPricesResponse(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): HistoricalPricesResponse {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: HistoricalPricesResponse) = 8UL

    override fun write(value: HistoricalPricesResponse, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface LabelManagerInterface {
    
    fun `deleteLabelsForTxn`(`txId`: TxId)
    
    fun `export`(): kotlin.String
    
    fun `exportDefaultFileName`(`name`: kotlin.String): kotlin.String
    
    fun `hasLabels`(): kotlin.Boolean
    
    fun `import`(`jsonl`: kotlin.String)
    
    fun `importLabels`(`labels`: Bip329Labels)
    
    fun `insertOrUpdateLabelsForTxn`(`details`: TransactionDetails, `label`: kotlin.String, `origin`: kotlin.String?)
    
    fun `transactionLabel`(`txId`: TxId): kotlin.String?
    
    companion object
}

open class LabelManager: Disposable, AutoCloseable, LabelManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`id`: WalletId) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_labelmanager_new(
    
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_labelmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_labelmanager(handle, status)
        }
    }

    
    @Throws(LabelManagerException::class)override fun `deleteLabelsForTxn`(`txId`: TxId)
        = 
    callWithHandle {
    uniffiRustCallWithError(LabelManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_delete_labels_for_txn(
        it,
        FfiConverterTypeTxId.lower(`txId`),_status)
}
    }
    
    

    
    @Throws(LabelManagerException::class)override fun `export`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(LabelManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_export(
        it,
        _status)
}
    }
    )
    }
    

    override fun `exportDefaultFileName`(`name`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_export_default_file_name(
        it,
        FfiConverterString.lower(`name`),_status)
}
    }
    )
    }
    

    override fun `hasLabels`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_has_labels(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(LabelManagerException::class)override fun `import`(`jsonl`: kotlin.String)
        = 
    callWithHandle {
    uniffiRustCallWithError(LabelManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_import(
        it,
        FfiConverterString.lower(`jsonl`),_status)
}
    }
    
    

    
    @Throws(LabelManagerException::class)override fun `importLabels`(`labels`: Bip329Labels)
        = 
    callWithHandle {
    uniffiRustCallWithError(LabelManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_importlabels(
        it,
        FfiConverterTypeBip329Labels.lower(`labels`),_status)
}
    }
    
    

    
    @Throws(LabelManagerException::class)override fun `insertOrUpdateLabelsForTxn`(`details`: TransactionDetails, `label`: kotlin.String, `origin`: kotlin.String?)
        = 
    callWithHandle {
    uniffiRustCallWithError(LabelManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_insert_or_update_labels_for_txn(
        it,
        FfiConverterTypeTransactionDetails.lower(`details`),FfiConverterString.lower(`label`),FfiConverterOptionalString.lower(`origin`),_status)
}
    }
    
    

    override fun `transactionLabel`(`txId`: TxId): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_labelmanager_transaction_label(
        it,
        FfiConverterTypeTxId.lower(`txId`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeLabelManager: FfiConverter<LabelManager, Long> {
    override fun lower(value: LabelManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): LabelManager {
        return LabelManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): LabelManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: LabelManager) = 8UL

    override fun write(value: LabelManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface LabelsTableInterface {
    
    companion object
}

open class LabelsTable: Disposable, AutoCloseable, LabelsTableInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_labelstable(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_labelstable(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeLabelsTable: FfiConverter<LabelsTable, Long> {
    override fun lower(value: LabelsTable): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): LabelsTable {
        return LabelsTable(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): LabelsTable {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: LabelsTable) = 8UL

    override fun write(value: LabelsTable, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface MnemonicInterface {
    
    fun `allWords`(): List<GroupedWord>
    
    fun `words`(): List<kotlin.String>
    
    companion object
}

open class Mnemonic: Disposable, AutoCloseable, MnemonicInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`id`: WalletId) :
        this(UniffiWithHandle, 
    uniffiRustCallWithError(MnemonicException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_mnemonic_new(
    
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_mnemonic(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_mnemonic(handle, status)
        }
    }

    override fun `allWords`(): List<GroupedWord> {
            return FfiConverterSequenceTypeGroupedWord.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_mnemonic_all_words(
        it,
        _status)
}
    }
    )
    }
    

    override fun `words`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_mnemonic_words(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `preview`(`numberOfBip39Words`: NumberOfBip39Words): Mnemonic {
            return FfiConverterTypeMnemonic.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_mnemonic_preview(
    
        FfiConverterTypeNumberOfBip39Words.lower(`numberOfBip39Words`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeMnemonic: FfiConverter<Mnemonic, Long> {
    override fun lower(value: Mnemonic): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Mnemonic {
        return Mnemonic(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Mnemonic {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Mnemonic) = 8UL

    override fun write(value: Mnemonic, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface MultiQrInterface {
    
    fun `addPart`(`qr`: kotlin.String): BbqrJoinResult
    
    fun `getGroupedWords`(`qr`: StringOrData, `groupsOf`: kotlin.UByte): List<List<kotlin.String>>?
    
    fun `handleScanResult`(`qr`: StringOrData): MultiQrScanResult
    
    fun `isBbqr`(): kotlin.Boolean
    
    fun `isSeedQr`(): kotlin.Boolean
    
    fun `totalParts`(): kotlin.UInt
    
    companion object
}

open class MultiQr: Disposable, AutoCloseable, MultiQrInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_multiqr(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_multiqr(handle, status)
        }
    }

    
    @Throws(MultiQrException::class)override fun `addPart`(`qr`: kotlin.String): BbqrJoinResult {
            return FfiConverterTypeBbqrJoinResult.lift(
    callWithHandle {
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_multiqr_add_part(
        it,
        FfiConverterString.lower(`qr`),_status)
}
    }
    )
    }
    

    
    @Throws(MultiQrException::class)override fun `getGroupedWords`(`qr`: StringOrData, `groupsOf`: kotlin.UByte): List<List<kotlin.String>>? {
            return FfiConverterOptionalSequenceSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_multiqr_get_grouped_words(
        it,
        FfiConverterTypeStringOrData.lower(`qr`),FfiConverterUByte.lower(`groupsOf`),_status)
}
    }
    )
    }
    

    
    @Throws(MultiQrException::class)override fun `handleScanResult`(`qr`: StringOrData): MultiQrScanResult {
            return FfiConverterTypeMultiQrScanResult.lift(
    callWithHandle {
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_multiqr_handle_scan_result(
        it,
        FfiConverterTypeStringOrData.lower(`qr`),_status)
}
    }
    )
    }
    

    override fun `isBbqr`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_multiqr_is_bbqr(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isSeedQr`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_multiqr_is_seed_qr(
        it,
        _status)
}
    }
    )
    }
    

    override fun `totalParts`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_multiqr_total_parts(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `newFromString`(`qr`: kotlin.String): MultiQr {
            return FfiConverterTypeMultiQr.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_multiqr_new_from_string(
    
        FfiConverterString.lower(`qr`),_status)
}
    )
    }
    

        
    @Throws(MultiQrException::class) fun `tryNew`(`qr`: StringOrData): MultiQr {
            return FfiConverterTypeMultiQr.lift(
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_multiqr_try_new(
    
        FfiConverterTypeStringOrData.lower(`qr`),_status)
}
    )
    }
    

        
    @Throws(MultiQrException::class) fun `tryNewFromData`(`data`: kotlin.ByteArray): MultiQr {
            return FfiConverterTypeMultiQr.lift(
    uniffiRustCallWithError(MultiQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_multiqr_try_new_from_data(
    
        FfiConverterByteArray.lower(`data`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeMultiQr: FfiConverter<MultiQr, Long> {
    override fun lower(value: MultiQr): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): MultiQr {
        return MultiQr(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): MultiQr {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: MultiQr) = 8UL

    override fun write(value: MultiQr, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface NodeSelectorInterface {
    
    /**
     * Check the node url and set it as selected node if it is valid
     */
    suspend fun `checkAndSaveNode`(`node`: Node)
    
    suspend fun `checkSelectedNode`(`node`: Node)
    
    fun `nodeList`(): List<NodeSelection>
    
    /**
     * Use the url and name of the custom node to set it as the selected node
     */
    fun `parseCustomNode`(`url`: kotlin.String, `name`: kotlin.String, `enteredName`: kotlin.String): Node
    
    fun `selectPresetNode`(`name`: kotlin.String): Node
    
    fun `selectedNode`(): NodeSelection
    
    companion object
}

open class NodeSelector: Disposable, AutoCloseable, NodeSelectorInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_nodeselector_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_nodeselector(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_nodeselector(handle, status)
        }
    }

    
    /**
     * Check the node url and set it as selected node if it is valid
     */
    @Throws(NodeSelectorException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `checkAndSaveNode`(`node`: Node) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_nodeselector_check_and_save_node(
                uniffiHandle,
                FfiConverterTypeNode.lower(`node`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NodeSelectorException.ErrorHandler,
    )
    }

    
    @Throws(NodeSelectorException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `checkSelectedNode`(`node`: Node) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_nodeselector_check_selected_node(
                uniffiHandle,
                FfiConverterTypeNode.lower(`node`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        NodeSelectorException.ErrorHandler,
    )
    }

    override fun `nodeList`(): List<NodeSelection> {
            return FfiConverterSequenceTypeNodeSelection.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_nodeselector_node_list(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Use the url and name of the custom node to set it as the selected node
     */
    @Throws(NodeSelectorException::class)override fun `parseCustomNode`(`url`: kotlin.String, `name`: kotlin.String, `enteredName`: kotlin.String): Node {
            return FfiConverterTypeNode.lift(
    callWithHandle {
    uniffiRustCallWithError(NodeSelectorException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_nodeselector_parse_custom_node(
        it,
        FfiConverterString.lower(`url`),FfiConverterString.lower(`name`),FfiConverterString.lower(`enteredName`),_status)
}
    }
    )
    }
    

    
    @Throws(NodeSelectorException::class)override fun `selectPresetNode`(`name`: kotlin.String): Node {
            return FfiConverterTypeNode.lift(
    callWithHandle {
    uniffiRustCallWithError(NodeSelectorException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_nodeselector_select_preset_node(
        it,
        FfiConverterString.lower(`name`),_status)
}
    }
    )
    }
    

    override fun `selectedNode`(): NodeSelection {
            return FfiConverterTypeNodeSelection.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_nodeselector_selected_node(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeNodeSelector: FfiConverter<NodeSelector, Long> {
    override fun lower(value: NodeSelector): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): NodeSelector {
        return NodeSelector(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): NodeSelector {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: NodeSelector) = 8UL

    override fun write(value: NodeSelector, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface PendingWalletInterface {
    
    companion object
}

open class PendingWallet: Disposable, AutoCloseable, PendingWalletInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_pendingwallet(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_pendingwallet(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypePendingWallet: FfiConverter<PendingWallet, Long> {
    override fun lower(value: PendingWallet): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): PendingWallet {
        return PendingWallet(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): PendingWallet {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: PendingWallet) = 8UL

    override fun write(value: PendingWallet, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface PriceResponseInterface {
    
    fun `get`(): kotlin.ULong
    
    fun `getForCurrency`(`currency`: FiatCurrency): kotlin.ULong
    
    companion object
}

open class PriceResponse: Disposable, AutoCloseable, PriceResponseInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_priceresponse(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_priceresponse(handle, status)
        }
    }

    override fun `get`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_priceresponse_get(
        it,
        _status)
}
    }
    )
    }
    

    override fun `getForCurrency`(`currency`: FiatCurrency): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_priceresponse_get_for_currency(
        it,
        FfiConverterTypeFiatCurrency.lower(`currency`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypePriceResponse: FfiConverter<PriceResponse, Long> {
    override fun lower(value: PriceResponse): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): PriceResponse {
        return PriceResponse(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): PriceResponse {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: PriceResponse) = 8UL

    override fun write(value: PriceResponse, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface PushTxInterface {
    
    companion object
}

open class PushTx: Disposable, AutoCloseable, PushTxInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_pushtx(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_pushtx(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypePushTx: FfiConverter<PushTx, Long> {
    override fun lower(value: PushTx): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): PushTx {
        return PushTx(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): PushTx {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: PushTx) = 8UL

    override fun write(value: PushTx, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RouteFactoryInterface {
    
    fun `coinControlSend`(`id`: WalletId, `utxos`: List<Utxo>): Route
    
    fun `coldWalletImport`(`route`: ColdWalletRoute): Route
    
    fun `hotWallet`(`route`: HotWalletRoute): Route
    
    fun `hotWalletImportFromScan`(): Route
    
    fun `isSameParentRoute`(`route`: Route, `routeToCheck`: Route): kotlin.Boolean
    
    fun `loadAndResetNestedTo`(`defaultRoute`: Route, `nestedRoutes`: List<Route>): Route
    
    fun `loadAndResetTo`(`resetTo`: Route): Route
    
    fun `loadAndResetToAfter`(`resetTo`: Route, `time`: kotlin.UInt): Route
    
    fun `mainWalletSettings`(`id`: WalletId): Route
    
    fun `nestedSettings`(`route`: SettingsRoute): List<Route>
    
    fun `nestedWalletSettings`(`id`: WalletId): List<Route>
    
    fun `newHotWallet`(): Route
    
    fun `newWalletSelect`(): Route
    
    fun `qrImport`(): Route
    
    fun `secretWords`(`walletId`: WalletId): Route
    
    fun `send`(`send`: SendRoute): Route
    
    fun `sendConfirm`(`id`: WalletId, `details`: ConfirmDetails, `signedTransaction`: BitcoinTransaction? = null, `signedPsbt`: Psbt? = null): Route
    
    fun `sendHardwareExport`(`id`: WalletId, `details`: ConfirmDetails): Route
    
    fun `sendSetAmount`(`id`: WalletId, `address`: Address? = null, `amount`: Amount? = null): Route
    
    fun `walletSettings`(`id`: WalletId, `route`: WalletSettingsRoute): Route
    
    companion object
}

open class RouteFactory: Disposable, AutoCloseable, RouteFactoryInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_routefactory_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_routefactory(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_routefactory(handle, status)
        }
    }

    override fun `coinControlSend`(`id`: WalletId, `utxos`: List<Utxo>): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_coin_control_send(
        it,
        FfiConverterTypeWalletId.lower(`id`),FfiConverterSequenceTypeUtxo.lower(`utxos`),_status)
}
    }
    )
    }
    

    override fun `coldWalletImport`(`route`: ColdWalletRoute): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_cold_wallet_import(
        it,
        FfiConverterTypeColdWalletRoute.lower(`route`),_status)
}
    }
    )
    }
    

    override fun `hotWallet`(`route`: HotWalletRoute): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_hot_wallet(
        it,
        FfiConverterTypeHotWalletRoute.lower(`route`),_status)
}
    }
    )
    }
    

    override fun `hotWalletImportFromScan`(): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_hot_wallet_import_from_scan(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isSameParentRoute`(`route`: Route, `routeToCheck`: Route): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_is_same_parent_route(
        it,
        FfiConverterTypeRoute.lower(`route`),FfiConverterTypeRoute.lower(`routeToCheck`),_status)
}
    }
    )
    }
    

    override fun `loadAndResetNestedTo`(`defaultRoute`: Route, `nestedRoutes`: List<Route>): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_load_and_reset_nested_to(
        it,
        FfiConverterTypeRoute.lower(`defaultRoute`),FfiConverterSequenceTypeRoute.lower(`nestedRoutes`),_status)
}
    }
    )
    }
    

    override fun `loadAndResetTo`(`resetTo`: Route): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_load_and_reset_to(
        it,
        FfiConverterTypeRoute.lower(`resetTo`),_status)
}
    }
    )
    }
    

    override fun `loadAndResetToAfter`(`resetTo`: Route, `time`: kotlin.UInt): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_load_and_reset_to_after(
        it,
        FfiConverterTypeRoute.lower(`resetTo`),FfiConverterUInt.lower(`time`),_status)
}
    }
    )
    }
    

    override fun `mainWalletSettings`(`id`: WalletId): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_main_wallet_settings(
        it,
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    }
    )
    }
    

    override fun `nestedSettings`(`route`: SettingsRoute): List<Route> {
            return FfiConverterSequenceTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_nested_settings(
        it,
        FfiConverterTypeSettingsRoute.lower(`route`),_status)
}
    }
    )
    }
    

    override fun `nestedWalletSettings`(`id`: WalletId): List<Route> {
            return FfiConverterSequenceTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_nested_wallet_settings(
        it,
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    }
    )
    }
    

    override fun `newHotWallet`(): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_new_hot_wallet(
        it,
        _status)
}
    }
    )
    }
    

    override fun `newWalletSelect`(): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_new_wallet_select(
        it,
        _status)
}
    }
    )
    }
    

    override fun `qrImport`(): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_qr_import(
        it,
        _status)
}
    }
    )
    }
    

    override fun `secretWords`(`walletId`: WalletId): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_secret_words(
        it,
        FfiConverterTypeWalletId.lower(`walletId`),_status)
}
    }
    )
    }
    

    override fun `send`(`send`: SendRoute): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_send(
        it,
        FfiConverterTypeSendRoute.lower(`send`),_status)
}
    }
    )
    }
    

    override fun `sendConfirm`(`id`: WalletId, `details`: ConfirmDetails, `signedTransaction`: BitcoinTransaction?, `signedPsbt`: Psbt?): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_send_confirm(
        it,
        FfiConverterTypeWalletId.lower(`id`),FfiConverterTypeConfirmDetails.lower(`details`),FfiConverterOptionalTypeBitcoinTransaction.lower(`signedTransaction`),FfiConverterOptionalTypePsbt.lower(`signedPsbt`),_status)
}
    }
    )
    }
    

    override fun `sendHardwareExport`(`id`: WalletId, `details`: ConfirmDetails): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_send_hardware_export(
        it,
        FfiConverterTypeWalletId.lower(`id`),FfiConverterTypeConfirmDetails.lower(`details`),_status)
}
    }
    )
    }
    

    override fun `sendSetAmount`(`id`: WalletId, `address`: Address?, `amount`: Amount?): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_send_set_amount(
        it,
        FfiConverterTypeWalletId.lower(`id`),FfiConverterOptionalTypeAddress.lower(`address`),FfiConverterOptionalTypeAmount.lower(`amount`),_status)
}
    }
    )
    }
    

    override fun `walletSettings`(`id`: WalletId, `route`: WalletSettingsRoute): Route {
            return FfiConverterTypeRoute.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_routefactory_wallet_settings(
        it,
        FfiConverterTypeWalletId.lower(`id`),FfiConverterTypeWalletSettingsRoute.lower(`route`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRouteFactory: FfiConverter<RouteFactory, Long> {
    override fun lower(value: RouteFactory): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RouteFactory {
        return RouteFactory(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RouteFactory {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RouteFactory) = 8UL

    override fun write(value: RouteFactory, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RustAuthManagerInterface {
    
    /**
     * Get the auth type for the app
     */
    fun `authType`(): AuthType
    
    /**
     * Check to see if the passed in PIN matches the decoy pin
     */
    fun `checkDecoyPin`(`pin`: kotlin.String): kotlin.Boolean
    
    /**
     * Check to see if the passed in PIN matches the wipe data PIN
     */
    fun `checkWipeDataPin`(`pin`: kotlin.String): kotlin.Boolean
    
    /**
     * Delete the decoy pin
     */
    fun `deleteDecoyPin`()
    
    /**
     * Delete the wipe data pin
     */
    fun `deleteWipeDataPin`()
    
    /**
     * Action from the frontend to change the state of the view model
     */
    fun `dispatch`(`action`: AuthManagerAction)
    
    /**
     * Check if decoy pin is enabled, not if the user is in decoy mode
     */
    fun `isDecoyPinEnabled`(): kotlin.Boolean
    
    /**
     * Actually check if the user is in decoy mode
     */
    fun `isInDecoyMode`(): kotlin.Boolean
    
    /**
     * Check if the wipe data pin is enabled
     */
    fun `isWipeDataPinEnabled`(): kotlin.Boolean
    
    fun `listenForUpdates`(`reconciler`: AuthManagerReconciler)
    
    fun `lockedAt`(): kotlin.ULong?
    
    fun `send`(`message`: AuthManagerReconcileMessage)
    
    fun `setAuthType`(`authType`: AuthType)
    
    /**
     * Set the decoy pin
     */
    fun `setDecoyPin`(`pin`: kotlin.String)
    
    fun `setLockedAt`(`lockedAt`: kotlin.ULong)
    
    /**
     * Set the wipe data pin
     */
    fun `setWipeDataPin`(`pin`: kotlin.String)
    
    /**
     * Switch from main mode to decoy mode
     */
    fun `switchToDecoyMode`()
    
    /**
     * Switch from decoy mode to main mode
     */
    fun `switchToMainMode`()
    
    /**
     * Validate if we have the correct settings to be able to set a decoy or wipe data pin
     */
    fun `validatePinSettings`(`pin`: kotlin.String)
    
    companion object
}

open class RustAuthManager: Disposable, AutoCloseable, RustAuthManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustauthmanager_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_rustauthmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_rustauthmanager(handle, status)
        }
    }

    
    /**
     * Get the auth type for the app
     */override fun `authType`(): AuthType {
            return FfiConverterTypeAuthType.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_auth_type(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Check to see if the passed in PIN matches the decoy pin
     */override fun `checkDecoyPin`(`pin`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_checkdecoypin(
        it,
        FfiConverterString.lower(`pin`),_status)
}
    }
    )
    }
    

    
    /**
     * Check to see if the passed in PIN matches the wipe data PIN
     */override fun `checkWipeDataPin`(`pin`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_checkwipedatapin(
        it,
        FfiConverterString.lower(`pin`),_status)
}
    }
    )
    }
    

    
    /**
     * Delete the decoy pin
     */override fun `deleteDecoyPin`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_delete_decoy_pin(
        it,
        _status)
}
    }
    
    

    
    /**
     * Delete the wipe data pin
     */override fun `deleteWipeDataPin`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_delete_wipe_data_pin(
        it,
        _status)
}
    }
    
    

    
    /**
     * Action from the frontend to change the state of the view model
     */override fun `dispatch`(`action`: AuthManagerAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_dispatch(
        it,
        FfiConverterTypeAuthManagerAction.lower(`action`),_status)
}
    }
    
    

    
    /**
     * Check if decoy pin is enabled, not if the user is in decoy mode
     */override fun `isDecoyPinEnabled`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_is_decoy_pin_enabled(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Actually check if the user is in decoy mode
     */override fun `isInDecoyMode`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_is_in_decoy_mode(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Check if the wipe data pin is enabled
     */override fun `isWipeDataPinEnabled`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_is_wipe_data_pin_enabled(
        it,
        _status)
}
    }
    )
    }
    

    override fun `listenForUpdates`(`reconciler`: AuthManagerReconciler)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_listen_for_updates(
        it,
        FfiConverterTypeAuthManagerReconciler.lower(`reconciler`),_status)
}
    }
    
    

    override fun `lockedAt`(): kotlin.ULong? {
            return FfiConverterOptionalULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_locked_at(
        it,
        _status)
}
    }
    )
    }
    

    override fun `send`(`message`: AuthManagerReconcileMessage)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_send(
        it,
        FfiConverterTypeAuthManagerReconcileMessage.lower(`message`),_status)
}
    }
    
    

    override fun `setAuthType`(`authType`: AuthType)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_set_auth_type(
        it,
        FfiConverterTypeAuthType.lower(`authType`),_status)
}
    }
    
    

    
    /**
     * Set the decoy pin
     */
    @Throws(AuthManagerException::class)override fun `setDecoyPin`(`pin`: kotlin.String)
        = 
    callWithHandle {
    uniffiRustCallWithError(AuthManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_set_decoy_pin(
        it,
        FfiConverterString.lower(`pin`),_status)
}
    }
    
    

    
    @Throws(AuthManagerException::class)override fun `setLockedAt`(`lockedAt`: kotlin.ULong)
        = 
    callWithHandle {
    uniffiRustCallWithError(AuthManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_set_locked_at(
        it,
        FfiConverterULong.lower(`lockedAt`),_status)
}
    }
    
    

    
    /**
     * Set the wipe data pin
     */
    @Throws(AuthManagerException::class)override fun `setWipeDataPin`(`pin`: kotlin.String)
        = 
    callWithHandle {
    uniffiRustCallWithError(AuthManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_set_wipe_data_pin(
        it,
        FfiConverterString.lower(`pin`),_status)
}
    }
    
    

    
    /**
     * Switch from main mode to decoy mode
     */override fun `switchToDecoyMode`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_switch_to_decoy_mode(
        it,
        _status)
}
    }
    
    

    
    /**
     * Switch from decoy mode to main mode
     */override fun `switchToMainMode`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_switch_to_main_mode(
        it,
        _status)
}
    }
    
    

    
    /**
     * Validate if we have the correct settings to be able to set a decoy or wipe data pin
     */
    @Throws(TrickPinException::class)override fun `validatePinSettings`(`pin`: kotlin.String)
        = 
    callWithHandle {
    uniffiRustCallWithError(TrickPinException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustauthmanager_validate_pin_settings(
        it,
        FfiConverterString.lower(`pin`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRustAuthManager: FfiConverter<RustAuthManager, Long> {
    override fun lower(value: RustAuthManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RustAuthManager {
        return RustAuthManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RustAuthManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RustAuthManager) = 8UL

    override fun write(value: RustAuthManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RustCoinControlManagerInterface {
    
    fun `buttonPresentation`(`button`: CoinControlListSortKey): ButtonPresentation
    
    /**
     * Action from the frontend to change the state of the view model
     */
    fun `dispatch`(`action`: CoinControlManagerAction)
    
    fun `id`(): WalletId
    
    fun `listenForUpdates`(`reconciler`: CoinControlManagerReconciler)
    
    suspend fun `reloadLabels`()
    
    fun `selectedUtxos`(): List<Utxo>
    
    fun `unit`(): BitcoinUnit
    
    fun `utxos`(): List<Utxo>
    
    companion object
}

open class RustCoinControlManager: Disposable, AutoCloseable, RustCoinControlManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_rustcoincontrolmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_rustcoincontrolmanager(handle, status)
        }
    }

    override fun `buttonPresentation`(`button`: CoinControlListSortKey): ButtonPresentation {
            return FfiConverterTypeButtonPresentation.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_button_presentation(
        it,
        FfiConverterTypeCoinControlListSortKey.lower(`button`),_status)
}
    }
    )
    }
    

    
    /**
     * Action from the frontend to change the state of the view model
     */override fun `dispatch`(`action`: CoinControlManagerAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_dispatch(
        it,
        FfiConverterTypeCoinControlManagerAction.lower(`action`),_status)
}
    }
    
    

    override fun `id`(): WalletId {
            return FfiConverterTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `listenForUpdates`(`reconciler`: CoinControlManagerReconciler)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_listen_for_updates(
        it,
        FfiConverterTypeCoinControlManagerReconciler.lower(`reconciler`),_status)
}
    }
    
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `reloadLabels`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_reload_labels(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `selectedUtxos`(): List<Utxo> {
            return FfiConverterSequenceTypeUtxo.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_selected_utxos(
        it,
        _status)
}
    }
    )
    }
    

    override fun `unit`(): BitcoinUnit {
            return FfiConverterTypeBitcoinUnit.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_unit(
        it,
        _status)
}
    }
    )
    }
    

    override fun `utxos`(): List<Utxo> {
            return FfiConverterSequenceTypeUtxo.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustcoincontrolmanager_utxos(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewNew`(`outputCount`: kotlin.UByte = 20u, `changeCount`: kotlin.UByte = 4u): RustCoinControlManager {
            return FfiConverterTypeRustCoinControlManager.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustcoincontrolmanager_preview_new(
    
        FfiConverterUByte.lower(`outputCount`),FfiConverterUByte.lower(`changeCount`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRustCoinControlManager: FfiConverter<RustCoinControlManager, Long> {
    override fun lower(value: RustCoinControlManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RustCoinControlManager {
        return RustCoinControlManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RustCoinControlManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RustCoinControlManager) = 8UL

    override fun write(value: RustCoinControlManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RustImportWalletManagerInterface {
    
    /**
     * Action from the frontend to change the state of the view model
     */
    fun `dispatch`(`action`: ImportWalletManagerAction)
    
    /**
     * Import wallet view from entered words
     */
    fun `importWallet`(`enteredWords`: List<List<kotlin.String>>): WalletMetadata
    
    fun `listenForUpdates`(`reconciler`: ImportWalletManagerReconciler)
    
    companion object
}

open class RustImportWalletManager: Disposable, AutoCloseable, RustImportWalletManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustimportwalletmanager_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_rustimportwalletmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_rustimportwalletmanager(handle, status)
        }
    }

    
    /**
     * Action from the frontend to change the state of the view model
     */override fun `dispatch`(`action`: ImportWalletManagerAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustimportwalletmanager_dispatch(
        it,
        FfiConverterTypeImportWalletManagerAction.lower(`action`),_status)
}
    }
    
    

    
    /**
     * Import wallet view from entered words
     */
    @Throws(ImportWalletException::class)override fun `importWallet`(`enteredWords`: List<List<kotlin.String>>): WalletMetadata {
            return FfiConverterTypeWalletMetadata.lift(
    callWithHandle {
    uniffiRustCallWithError(ImportWalletException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustimportwalletmanager_import_wallet(
        it,
        FfiConverterSequenceSequenceString.lower(`enteredWords`),_status)
}
    }
    )
    }
    

    override fun `listenForUpdates`(`reconciler`: ImportWalletManagerReconciler)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustimportwalletmanager_listen_for_updates(
        it,
        FfiConverterTypeImportWalletManagerReconciler.lower(`reconciler`),_status)
}
    }
    
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRustImportWalletManager: FfiConverter<RustImportWalletManager, Long> {
    override fun lower(value: RustImportWalletManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RustImportWalletManager {
        return RustImportWalletManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RustImportWalletManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RustImportWalletManager) = 8UL

    override fun write(value: RustImportWalletManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RustPendingWalletManagerInterface {
    
    fun `bip39Words`(): List<kotlin.String>
    
    fun `bip39WordsGrouped`(): List<List<GroupedWord>>
    
    fun `cardIndexes`(): kotlin.UByte
    
    /**
     * Action from the frontend to change the state of the view model
     */
    fun `dispatch`(`action`: PendingWalletManagerAction)
    
    fun `getState`(): PendingWalletManagerState
    
    fun `listenForUpdates`(`reconciler`: PendingWalletManagerReconciler)
    
    fun `numberOfWordsCount`(): kotlin.UByte
    
    fun `saveWallet`(): WalletMetadata
    
    companion object
}

open class RustPendingWalletManager: Disposable, AutoCloseable, RustPendingWalletManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`numberOfWords`: NumberOfBip39Words) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustpendingwalletmanager_new(
    
        FfiConverterTypeNumberOfBip39Words.lower(`numberOfWords`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_rustpendingwalletmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_rustpendingwalletmanager(handle, status)
        }
    }

    override fun `bip39Words`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words(
        it,
        _status)
}
    }
    )
    }
    

    override fun `bip39WordsGrouped`(): List<List<GroupedWord>> {
            return FfiConverterSequenceSequenceTypeGroupedWord.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words_grouped(
        it,
        _status)
}
    }
    )
    }
    

    override fun `cardIndexes`(): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_card_indexes(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Action from the frontend to change the state of the view model
     */override fun `dispatch`(`action`: PendingWalletManagerAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_dispatch(
        it,
        FfiConverterTypePendingWalletManagerAction.lower(`action`),_status)
}
    }
    
    

    override fun `getState`(): PendingWalletManagerState {
            return FfiConverterTypePendingWalletManagerState.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_get_state(
        it,
        _status)
}
    }
    )
    }
    

    override fun `listenForUpdates`(`reconciler`: PendingWalletManagerReconciler)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_listen_for_updates(
        it,
        FfiConverterTypePendingWalletManagerReconciler.lower(`reconciler`),_status)
}
    }
    
    

    override fun `numberOfWordsCount`(): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_number_of_words_count(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(PendingWalletManagerException::class)override fun `saveWallet`(): WalletMetadata {
            return FfiConverterTypeWalletMetadata.lift(
    callWithHandle {
    uniffiRustCallWithError(PendingWalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustpendingwalletmanager_save_wallet(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRustPendingWalletManager: FfiConverter<RustPendingWalletManager, Long> {
    override fun lower(value: RustPendingWalletManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RustPendingWalletManager {
        return RustPendingWalletManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RustPendingWalletManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RustPendingWalletManager) = 8UL

    override fun write(value: RustPendingWalletManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RustSendFlowManagerInterface {
    
    fun `amount`(): Amount
    
    fun `amountSats`(): kotlin.ULong
    
    /**
     * action from the frontend to change the state of the view model
     */
    fun `dispatch`(`action`: SendFlowManagerAction)
    
    fun `displayFiatAmount`(`amount`: kotlin.Double, `withSuffix`: kotlin.Boolean = true): kotlin.String
    
    fun `enteringFiatAmount`(): kotlin.String
    
    /**
     * get the custom fee rate option
     */
    suspend fun `getCustomFeeOption`(`feeRate`: FeeRate, `feeSpeed`: FeeSpeed): FeeRateOptionWithTotalFee
    
    fun `listenForUpdates`(`reconciler`: SendFlowManagerReconciler)
    
    fun `maxSendMinusFees`(): Amount?
    
    fun `maxSendMinusFeesAndSmallUtxo`(): Amount?
    
    fun `sanitizeBtcEnteringAmount`(`oldValue`: kotlin.String, `newValue`: kotlin.String): kotlin.String?
    
    fun `sanitizeFiatEnteringAmount`(`oldValue`: kotlin.String, `newValue`: kotlin.String): kotlin.String?
    
    fun `sendAmountBtc`(): kotlin.String
    
    fun `sendAmountFiat`(): kotlin.String
    
    fun `totalFeeString`(): kotlin.String
    
    fun `totalSpentInBtc`(): kotlin.String
    
    fun `totalSpentInFiat`(): kotlin.String
    
    fun `utxos`(): List<Utxo>?
    
    fun `validateAddress`(`displayAlert`: kotlin.Boolean = false): kotlin.Boolean
    
    fun `validateAmount`(`displayAlert`: kotlin.Boolean = false): kotlin.Boolean
    
    fun `validateFeePercentage`(`displayAlert`: kotlin.Boolean = false): kotlin.Boolean
    
    suspend fun `waitForInit`()
    
    fun `walletId`(): WalletId
    
    companion object
}

open class RustSendFlowManager: Disposable, AutoCloseable, RustSendFlowManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_rustsendflowmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_rustsendflowmanager(handle, status)
        }
    }

    override fun `amount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `amountSats`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_amount_sats(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * action from the frontend to change the state of the view model
     */override fun `dispatch`(`action`: SendFlowManagerAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_dispatch(
        it,
        FfiConverterTypeSendFlowManagerAction.lower(`action`),_status)
}
    }
    
    

    override fun `displayFiatAmount`(`amount`: kotlin.Double, `withSuffix`: kotlin.Boolean): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_display_fiat_amount(
        it,
        FfiConverterDouble.lower(`amount`),FfiConverterBoolean.lower(`withSuffix`),_status)
}
    }
    )
    }
    

    override fun `enteringFiatAmount`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_entering_fiat_amount(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * get the custom fee rate option
     */
    @Throws(SendFlowException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getCustomFeeOption`(`feeRate`: FeeRate, `feeSpeed`: FeeSpeed) : FeeRateOptionWithTotalFee {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_get_custom_fee_option(
                uniffiHandle,
                FfiConverterTypeFeeRate.lower(`feeRate`),FfiConverterTypeFeeSpeed.lower(`feeSpeed`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeFeeRateOptionWithTotalFee.lift(it) },
        // Error FFI converter
        SendFlowException.ErrorHandler,
    )
    }

    override fun `listenForUpdates`(`reconciler`: SendFlowManagerReconciler)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_listen_for_updates(
        it,
        FfiConverterTypeSendFlowManagerReconciler.lower(`reconciler`),_status)
}
    }
    
    

    override fun `maxSendMinusFees`(): Amount? {
            return FfiConverterOptionalTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_maxsendminusfees(
        it,
        _status)
}
    }
    )
    }
    

    override fun `maxSendMinusFeesAndSmallUtxo`(): Amount? {
            return FfiConverterOptionalTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_maxsendminusfeesandsmallutxo(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sanitizeBtcEnteringAmount`(`oldValue`: kotlin.String, `newValue`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_sanitize_btc_entering_amount(
        it,
        FfiConverterString.lower(`oldValue`),FfiConverterString.lower(`newValue`),_status)
}
    }
    )
    }
    

    override fun `sanitizeFiatEnteringAmount`(`oldValue`: kotlin.String, `newValue`: kotlin.String): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_sanitize_fiat_entering_amount(
        it,
        FfiConverterString.lower(`oldValue`),FfiConverterString.lower(`newValue`),_status)
}
    }
    )
    }
    

    override fun `sendAmountBtc`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_send_amount_btc(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sendAmountFiat`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_send_amount_fiat(
        it,
        _status)
}
    }
    )
    }
    

    override fun `totalFeeString`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_total_fee_string(
        it,
        _status)
}
    }
    )
    }
    

    override fun `totalSpentInBtc`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_total_spent_in_btc(
        it,
        _status)
}
    }
    )
    }
    

    override fun `totalSpentInFiat`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_total_spent_in_fiat(
        it,
        _status)
}
    }
    )
    }
    

    override fun `utxos`(): List<Utxo>? {
            return FfiConverterOptionalSequenceTypeUtxo.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_utxos(
        it,
        _status)
}
    }
    )
    }
    

    override fun `validateAddress`(`displayAlert`: kotlin.Boolean): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_validate_address(
        it,
        FfiConverterBoolean.lower(`displayAlert`),_status)
}
    }
    )
    }
    

    override fun `validateAmount`(`displayAlert`: kotlin.Boolean): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_validate_amount(
        it,
        FfiConverterBoolean.lower(`displayAlert`),_status)
}
    }
    )
    }
    

    override fun `validateFeePercentage`(`displayAlert`: kotlin.Boolean): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_validate_fee_percentage(
        it,
        FfiConverterBoolean.lower(`displayAlert`),_status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `waitForInit`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_wait_for_init(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `walletId`(): WalletId {
            return FfiConverterTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustsendflowmanager_wallet_id(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRustSendFlowManager: FfiConverter<RustSendFlowManager, Long> {
    override fun lower(value: RustSendFlowManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RustSendFlowManager {
        return RustSendFlowManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RustSendFlowManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RustSendFlowManager) = 8UL

    override fun write(value: RustSendFlowManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface RustWalletManagerInterface {
    
    /**
     * Get address at the given index
     */
    suspend fun `addressAt`(`index`: kotlin.UInt): AddressInfo
    
    suspend fun `amountInFiat`(`amount`: Amount): kotlin.Double
    
    suspend fun `balance`(): Balance
    
    suspend fun `balanceInFiat`(): kotlin.Double
    
    suspend fun `broadcastTransaction`(`signedTransaction`: BitcoinTransaction)
    
    fun `convertAndDisplayFiat`(`amount`: Amount, `prices`: PriceResponse, `withSuffix`: kotlin.Boolean = true): kotlin.String
    
    fun `convertFromFiatString`(`fiatAmount`: kotlin.String, `prices`: PriceResponse): Amount
    
    fun `convertToFiat`(`amount`: Amount, `prices`: PriceResponse): kotlin.Double
    
    suspend fun `createTransactionsWithFiatExport`(): kotlin.String
    
    suspend fun `currentBlockHeight`(): kotlin.UInt
    
    fun `deleteUnsignedTransaction`(`txId`: TxId)
    
    fun `deleteWallet`()
    
    /**
     * Action from the frontend to change the state of the view model
     */
    fun `dispatch`(`action`: WalletManagerAction)
    
    fun `displayAmount`(`amount`: Amount, `showUnit`: kotlin.Boolean = true): kotlin.String
    
    fun `displayFiatAmount`(`amount`: kotlin.Double, `withSuffix`: kotlin.Boolean = true): kotlin.String
    
    fun `displaySentAndReceivedAmount`(`sentAndReceived`: SentAndReceived): kotlin.String
    
    suspend fun `feeRateOptions`(): FeeRateOptions
    
    fun `fees`(): FeeResponse?
    
    /**
     * Finalize a signed PSBT
     */
    suspend fun `finalizePsbt`(`psbt`: Psbt): BitcoinTransaction
    
    suspend fun `firstAddress`(): AddressInfo
    
    suspend fun `forceUpdateHeight`(): kotlin.UInt
    
    suspend fun `forceWalletScan`()
    
    suspend fun `getFeeOptions`(): FeeRateOptions
    
    /**
     * gets the transactions for the wallet that are currently available
     */
    suspend fun `getTransactions`()
    
    fun `getUnsignedTransactions`(): List<UnsignedTransaction>
    
    fun `labelManager`(): LabelManager
    
    fun `listenForUpdates`(`reconciler`: WalletManagerReconciler)
    
    fun `markWalletAsVerified`()
    
    fun `masterFingerprint`(): kotlin.String?
    
    suspend fun `newCoinControlManager`(): RustCoinControlManager
    
    fun `newSendFlowManager`(): RustSendFlowManager
    
    /**
     * Get the next address for the wallet
     */
    suspend fun `nextAddress`(): AddressInfoWithDerivation
    
    suspend fun `numberOfConfirmations`(`blockHeight`: kotlin.UInt): kotlin.UInt
    
    suspend fun `numberOfConfirmationsFmt`(`blockHeight`: kotlin.UInt): kotlin.String
    
    fun `saveUnsignedTransaction`(`details`: ConfirmDetails)
    
    fun `selectedFiatCurrency`(): FiatCurrency
    
    suspend fun `sentAndReceivedFiat`(`sentAndReceived`: SentAndReceived): kotlin.Double
    
    fun `setWalletMetadata`(`metadata`: WalletMetadata)
    
    suspend fun `signAndBroadcastTransaction`(`psbt`: Psbt)
    
    suspend fun `splitTransactionOutputs`(`outputs`: List<AddressAndAmount>): SplitOutput
    
    suspend fun `startWalletScan`()
    
    suspend fun `switchToDifferentWalletAddressType`(`walletAddressType`: WalletAddressType)
    
    suspend fun `transactionDetails`(`txId`: TxId): TransactionDetails
    
    fun `validateMetadata`()
    
    fun `walletMetadata`(): WalletMetadata
    
    fun `wordValidator`(): WordValidator
    
    companion object
}

open class RustWalletManager: Disposable, AutoCloseable, RustWalletManagerInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    constructor(`id`: WalletId) :
        this(UniffiWithHandle, 
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustwalletmanager_new(
    
        FfiConverterTypeWalletId.lower(`id`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_rustwalletmanager(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_rustwalletmanager(handle, status)
        }
    }

    
    /**
     * Get address at the given index
     */
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `addressAt`(`index`: kotlin.UInt) : AddressInfo {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_address_at(
                uniffiHandle,
                FfiConverterUInt.lower(`index`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeAddressInfo.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `amountInFiat`(`amount`: Amount) : kotlin.Double {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_amount_in_fiat(
                uniffiHandle,
                FfiConverterTypeAmount.lower(`amount`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_f64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_f64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_f64(future) },
        // lift function
        { FfiConverterDouble.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `balance`() : Balance {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_balance(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeBalance.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `balanceInFiat`() : kotlin.Double {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_balance_in_fiat(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_f64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_f64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_f64(future) },
        // lift function
        { FfiConverterDouble.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `broadcastTransaction`(`signedTransaction`: BitcoinTransaction) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_broadcast_transaction(
                uniffiHandle,
                FfiConverterTypeBitcoinTransaction.lower(`signedTransaction`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    override fun `convertAndDisplayFiat`(`amount`: Amount, `prices`: PriceResponse, `withSuffix`: kotlin.Boolean): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_convert_and_display_fiat(
        it,
        FfiConverterTypeAmount.lower(`amount`),FfiConverterTypePriceResponse.lower(`prices`),FfiConverterBoolean.lower(`withSuffix`),_status)
}
    }
    )
    }
    

    override fun `convertFromFiatString`(`fiatAmount`: kotlin.String, `prices`: PriceResponse): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_convert_from_fiat_string(
        it,
        FfiConverterString.lower(`fiatAmount`),FfiConverterTypePriceResponse.lower(`prices`),_status)
}
    }
    )
    }
    

    override fun `convertToFiat`(`amount`: Amount, `prices`: PriceResponse): kotlin.Double {
            return FfiConverterDouble.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_convert_to_fiat(
        it,
        FfiConverterTypeAmount.lower(`amount`),FfiConverterTypePriceResponse.lower(`prices`),_status)
}
    }
    )
    }
    

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `createTransactionsWithFiatExport`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_create_transactions_with_fiat_export(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `currentBlockHeight`() : kotlin.UInt {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_current_block_height(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u32(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u32(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u32(future) },
        // lift function
        { FfiConverterUInt.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)override fun `deleteUnsignedTransaction`(`txId`: TxId)
        = 
    callWithHandle {
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_delete_unsigned_transaction(
        it,
        FfiConverterTypeTxId.lower(`txId`),_status)
}
    }
    
    

    
    @Throws(WalletManagerException::class)override fun `deleteWallet`()
        = 
    callWithHandle {
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_delete_wallet(
        it,
        _status)
}
    }
    
    

    
    /**
     * Action from the frontend to change the state of the view model
     */override fun `dispatch`(`action`: WalletManagerAction)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_dispatch(
        it,
        FfiConverterTypeWalletManagerAction.lower(`action`),_status)
}
    }
    
    

    override fun `displayAmount`(`amount`: Amount, `showUnit`: kotlin.Boolean): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_display_amount(
        it,
        FfiConverterTypeAmount.lower(`amount`),FfiConverterBoolean.lower(`showUnit`),_status)
}
    }
    )
    }
    

    override fun `displayFiatAmount`(`amount`: kotlin.Double, `withSuffix`: kotlin.Boolean): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_display_fiat_amount(
        it,
        FfiConverterDouble.lower(`amount`),FfiConverterBoolean.lower(`withSuffix`),_status)
}
    }
    )
    }
    

    override fun `displaySentAndReceivedAmount`(`sentAndReceived`: SentAndReceived): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_display_sent_and_received_amount(
        it,
        FfiConverterTypeSentAndReceived.lower(`sentAndReceived`),_status)
}
    }
    )
    }
    

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `feeRateOptions`() : FeeRateOptions {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_fee_rate_options(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeFeeRateOptions.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    override fun `fees`(): FeeResponse? {
            return FfiConverterOptionalTypeFeeResponse.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_fees(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Finalize a signed PSBT
     */
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `finalizePsbt`(`psbt`: Psbt) : BitcoinTransaction {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_finalize_psbt(
                uniffiHandle,
                FfiConverterTypePsbt.lower(`psbt`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeBitcoinTransaction.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `firstAddress`() : AddressInfo {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_first_address(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeAddressInfo.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `forceUpdateHeight`() : kotlin.UInt {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_force_update_height(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u32(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u32(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u32(future) },
        // lift function
        { FfiConverterUInt.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `forceWalletScan`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_force_wallet_scan(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getFeeOptions`() : FeeRateOptions {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_get_fee_options(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeFeeRateOptions.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    /**
     * gets the transactions for the wallet that are currently available
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `getTransactions`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_get_transactions(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)override fun `getUnsignedTransactions`(): List<UnsignedTransaction> {
            return FfiConverterSequenceTypeUnsignedTransaction.lift(
    callWithHandle {
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_get_unsigned_transactions(
        it,
        _status)
}
    }
    )
    }
    

    override fun `labelManager`(): LabelManager {
            return FfiConverterTypeLabelManager.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_label_manager(
        it,
        _status)
}
    }
    )
    }
    

    override fun `listenForUpdates`(`reconciler`: WalletManagerReconciler)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_listen_for_updates(
        it,
        FfiConverterTypeWalletManagerReconciler.lower(`reconciler`),_status)
}
    }
    
    

    
    @Throws(WalletManagerException::class)override fun `markWalletAsVerified`()
        = 
    callWithHandle {
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_mark_wallet_as_verified(
        it,
        _status)
}
    }
    
    

    override fun `masterFingerprint`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_master_fingerprint(
        it,
        _status)
}
    }
    )
    }
    

    
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `newCoinControlManager`() : RustCoinControlManager {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_new_coin_control_manager(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeRustCoinControlManager.lift(it) },
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }

    override fun `newSendFlowManager`(): RustSendFlowManager {
            return FfiConverterTypeRustSendFlowManager.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_new_send_flow_manager(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Get the next address for the wallet
     */
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `nextAddress`() : AddressInfoWithDerivation {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_next_address(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeAddressInfoWithDerivation.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `numberOfConfirmations`(`blockHeight`: kotlin.UInt) : kotlin.UInt {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations(
                uniffiHandle,
                FfiConverterUInt.lower(`blockHeight`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u32(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u32(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u32(future) },
        // lift function
        { FfiConverterUInt.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `numberOfConfirmationsFmt`(`blockHeight`: kotlin.UInt) : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations_fmt(
                uniffiHandle,
                FfiConverterUInt.lower(`blockHeight`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)override fun `saveUnsignedTransaction`(`details`: ConfirmDetails)
        = 
    callWithHandle {
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_save_unsigned_transaction(
        it,
        FfiConverterTypeConfirmDetails.lower(`details`),_status)
}
    }
    
    

    override fun `selectedFiatCurrency`(): FiatCurrency {
            return FfiConverterTypeFiatCurrency.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_selected_fiat_currency(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sentAndReceivedFiat`(`sentAndReceived`: SentAndReceived) : kotlin.Double {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_sent_and_received_fiat(
                uniffiHandle,
                FfiConverterTypeSentAndReceived.lower(`sentAndReceived`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_f64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_f64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_f64(future) },
        // lift function
        { FfiConverterDouble.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    override fun `setWalletMetadata`(`metadata`: WalletMetadata)
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_set_wallet_metadata(
        it,
        FfiConverterTypeWalletMetadata.lower(`metadata`),_status)
}
    }
    
    

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `signAndBroadcastTransaction`(`psbt`: Psbt) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_sign_and_broadcast_transaction(
                uniffiHandle,
                FfiConverterTypePsbt.lower(`psbt`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `splitTransactionOutputs`(`outputs`: List<AddressAndAmount>) : SplitOutput {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_split_transaction_outputs(
                uniffiHandle,
                FfiConverterSequenceTypeAddressAndAmount.lower(`outputs`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation).let { RustBufferSplitOutput.create(it.capacity.toULong(), it.len.toULong(), it.data) } },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSplitOutput.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `startWalletScan`() {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_start_wallet_scan(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `switchToDifferentWalletAddressType`(`walletAddressType`: WalletAddressType) {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_switch_to_different_wallet_address_type(
                uniffiHandle,
                FfiConverterTypeWalletAddressType.lower(`walletAddressType`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    
    @Throws(WalletManagerException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `transactionDetails`(`txId`: TxId) : TransactionDetails {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_transaction_details(
                uniffiHandle,
                FfiConverterTypeTxId.lower(`txId`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypeTransactionDetails.lift(it) },
        // Error FFI converter
        WalletManagerException.ErrorHandler,
    )
    }

    override fun `validateMetadata`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_validate_metadata(
        it,
        _status)
}
    }
    
    

    override fun `walletMetadata`(): WalletMetadata {
            return FfiConverterTypeWalletMetadata.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_wallet_metadata(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(WalletManagerException::class)override fun `wordValidator`(): WordValidator {
            return FfiConverterTypeWordValidator.lift(
    callWithHandle {
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_rustwalletmanager_word_validator(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewNewWallet`(): RustWalletManager {
            return FfiConverterTypeRustWalletManager.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet(
    
        _status)
}
    )
    }
    

         fun `previewNewWalletWithMetadata`(`metadata`: WalletMetadata): RustWalletManager {
            return FfiConverterTypeRustWalletManager.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet_with_metadata(
    
        FfiConverterTypeWalletMetadata.lower(`metadata`),_status)
}
    )
    }
    

        
    @Throws(WalletManagerException::class) fun `tryNewFromTapSigner`(`tapSigner`: TapSigner, `deriveInfo`: DeriveInfo, `backup`: kotlin.ByteArray? = null): RustWalletManager {
            return FfiConverterTypeRustWalletManager.lift(
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_tap_signer(
    
        FfiConverterTypeTapSigner.lower(`tapSigner`),FfiConverterTypeDeriveInfo.lower(`deriveInfo`),FfiConverterOptionalByteArray.lower(`backup`),_status)
}
    )
    }
    

        
    @Throws(WalletManagerException::class) fun `tryNewFromXpub`(`xpub`: kotlin.String): RustWalletManager {
            return FfiConverterTypeRustWalletManager.lift(
    uniffiRustCallWithError(WalletManagerException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_xpub(
    
        FfiConverterString.lower(`xpub`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRustWalletManager: FfiConverter<RustWalletManager, Long> {
    override fun lower(value: RustWalletManager): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RustWalletManager {
        return RustWalletManager(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RustWalletManager {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RustWalletManager) = 8UL

    override fun write(value: RustWalletManager, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface SeedQrInterface {
    
    fun `getWords`(): List<kotlin.String>
    
    fun `groupedPlainWords`(`groupsOf`: kotlin.UByte): List<List<kotlin.String>>
    
    companion object
}

open class SeedQr: Disposable, AutoCloseable, SeedQrInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_seedqr(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_seedqr(handle, status)
        }
    }

    override fun `getWords`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_seedqr_get_words(
        it,
        _status)
}
    }
    )
    }
    

    override fun `groupedPlainWords`(`groupsOf`: kotlin.UByte): List<List<kotlin.String>> {
            return FfiConverterSequenceSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_seedqr_grouped_plain_words(
        it,
        FfiConverterUByte.lower(`groupsOf`),_status)
}
    }
    )
    }
    

    

    


    
    companion object {
        
    @Throws(SeedQrException::class) fun `newFromData`(`data`: kotlin.ByteArray): SeedQr {
            return FfiConverterTypeSeedQr.lift(
    uniffiRustCallWithError(SeedQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_seedqr_new_from_data(
    
        FfiConverterByteArray.lower(`data`),_status)
}
    )
    }
    

        
    @Throws(SeedQrException::class) fun `newFromStr`(`qr`: kotlin.String): SeedQr {
            return FfiConverterTypeSeedQr.lift(
    uniffiRustCallWithError(SeedQrException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_seedqr_new_from_str(
    
        FfiConverterString.lower(`qr`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSeedQr: FfiConverter<SeedQr, Long> {
    override fun lower(value: SeedQr): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SeedQr {
        return SeedQr(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SeedQr {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SeedQr) = 8UL

    override fun write(value: SeedQr, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface SendFlowManagerStateInterface {
    
    companion object
}

open class SendFlowManagerState: Disposable, AutoCloseable, SendFlowManagerStateInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_sendflowmanagerstate(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_sendflowmanagerstate(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSendFlowManagerState: FfiConverter<SendFlowManagerState, Long> {
    override fun lower(value: SendFlowManagerState): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SendFlowManagerState {
        return SendFlowManagerState(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SendFlowManagerState {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SendFlowManagerState) = 8UL

    override fun write(value: SendFlowManagerState, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface SetupCmdInterface {
    
    companion object
}

open class SetupCmd: Disposable, AutoCloseable, SetupCmdInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_setupcmd(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_setupcmd(handle, status)
        }
    }

    

    


    
    companion object {
        
    @Throws(TapSignerReaderException::class) fun `tryNew`(`factoryPin`: kotlin.String, `newPin`: kotlin.String, `chainCode`: kotlin.ByteArray? = null): SetupCmd {
            return FfiConverterTypeSetupCmd.lift(
    uniffiRustCallWithError(TapSignerReaderException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_setupcmd_try_new(
    
        FfiConverterString.lower(`factoryPin`),FfiConverterString.lower(`newPin`),FfiConverterOptionalByteArray.lower(`chainCode`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSetupCmd: FfiConverter<SetupCmd, Long> {
    override fun lower(value: SetupCmd): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SetupCmd {
        return SetupCmd(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SetupCmd {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SetupCmd) = 8UL

    override fun write(value: SetupCmd, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface TapSignerReaderInterface {
    
    /**
     * User started the setup process, but errored out before completing the setup, we can continue from the last step
     */
    suspend fun `continueSetup`(`response`: SetupCmdResponse): SetupCmdResponse
    
    /**
     * Get the last response from the reader
     */
    fun `lastResponse`(): TapSignerResponse?
    
    suspend fun `run`(): TapSignerResponse
    
    /**
     * Start the setup process
     */
    suspend fun `setup`(`cmd`: SetupCmd): SetupCmdResponse
    
    suspend fun `sign`(`psbt`: Psbt, `pin`: kotlin.String): Psbt
    
    companion object
}

open class TapSignerReader: Disposable, AutoCloseable, TapSignerReaderInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    // Note no constructor generated for this object as it is async.

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_tapsignerreader(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_tapsignerreader(handle, status)
        }
    }

    
    /**
     * User started the setup process, but errored out before completing the setup, we can continue from the last step
     */
    @Throws(TapSignerReaderException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `continueSetup`(`response`: SetupCmdResponse) : SetupCmdResponse {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_tapsignerreader_continue_setup(
                uniffiHandle,
                FfiConverterTypeSetupCmdResponse.lower(`response`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSetupCmdResponse.lift(it) },
        // Error FFI converter
        TapSignerReaderException.ErrorHandler,
    )
    }

    
    /**
     * Get the last response from the reader
     */override fun `lastResponse`(): TapSignerResponse? {
            return FfiConverterOptionalTypeTapSignerResponse.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_tapsignerreader_last_response(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(TapSignerReaderException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `run`() : TapSignerResponse {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_tapsignerreader_run(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeTapSignerResponse.lift(it) },
        // Error FFI converter
        TapSignerReaderException.ErrorHandler,
    )
    }

    
    /**
     * Start the setup process
     */
    @Throws(TapSignerReaderException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `setup`(`cmd`: SetupCmd) : SetupCmdResponse {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_tapsignerreader_setup(
                uniffiHandle,
                FfiConverterTypeSetupCmd.lower(`cmd`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterTypeSetupCmdResponse.lift(it) },
        // Error FFI converter
        TapSignerReaderException.ErrorHandler,
    )
    }

    
    @Throws(TapSignerReaderException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sign`(`psbt`: Psbt, `pin`: kotlin.String) : Psbt {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_tapsignerreader_sign(
                uniffiHandle,
                FfiConverterTypePsbt.lower(`psbt`),FfiConverterString.lower(`pin`),
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_u64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_u64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_u64(future) },
        // lift function
        { FfiConverterTypePsbt.lift(it) },
        // Error FFI converter
        TapSignerReaderException.ErrorHandler,
    )
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeTapSignerReader: FfiConverter<TapSignerReader, Long> {
    override fun lower(value: TapSignerReader): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): TapSignerReader {
        return TapSignerReader(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): TapSignerReader {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TapSignerReader) = 8UL

    override fun write(value: TapSignerReader, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface TransactionDetailsInterface {
    
    fun `address`(): Address
    
    fun `addressSpacedOut`(): kotlin.String
    
    fun `amount`(): Amount
    
    suspend fun `amountFiat`(): kotlin.Double
    
    suspend fun `amountFiatFmt`(): kotlin.String
    
    fun `amountFmt`(`unit`: BitcoinUnit): kotlin.String
    
    fun `blockNumber`(): kotlin.UInt?
    
    fun `blockNumberFmt`(): kotlin.String?
    
    fun `confirmationDateTime`(): kotlin.String?
    
    suspend fun `feeFiatFmt`(): kotlin.String
    
    fun `feeFmt`(`unit`: BitcoinUnit): kotlin.String?
    
    fun `isConfirmed`(): kotlin.Boolean
    
    fun `isReceived`(): kotlin.Boolean
    
    fun `isSent`(): kotlin.Boolean
    
    suspend fun `sentSansFeeFiatFmt`(): kotlin.String
    
    fun `sentSansFeeFmt`(`unit`: BitcoinUnit): kotlin.String?
    
    fun `transactionLabel`(): kotlin.String?
    
    fun `transactionUrl`(): kotlin.String
    
    fun `txId`(): TxId
    
    companion object
}

open class TransactionDetails: Disposable, AutoCloseable, TransactionDetailsInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_transactiondetails(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_transactiondetails(handle, status)
        }
    }

    override fun `address`(): Address {
            return FfiConverterTypeAddress.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_address(
        it,
        _status)
}
    }
    )
    }
    

    override fun `addressSpacedOut`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_address_spaced_out(
        it,
        _status)
}
    }
    )
    }
    

    override fun `amount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_amount(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(TransactionDetailException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `amountFiat`() : kotlin.Double {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_amount_fiat(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_f64(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_f64(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_f64(future) },
        // lift function
        { FfiConverterDouble.lift(it) },
        // Error FFI converter
        TransactionDetailException.ErrorHandler,
    )
    }

    
    @Throws(TransactionDetailException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `amountFiatFmt`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_amount_fiat_fmt(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        TransactionDetailException.ErrorHandler,
    )
    }

    override fun `amountFmt`(`unit`: BitcoinUnit): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_amount_fmt(
        it,
        FfiConverterTypeBitcoinUnit.lower(`unit`),_status)
}
    }
    )
    }
    

    override fun `blockNumber`(): kotlin.UInt? {
            return FfiConverterOptionalUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_block_number(
        it,
        _status)
}
    }
    )
    }
    

    override fun `blockNumberFmt`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_block_number_fmt(
        it,
        _status)
}
    }
    )
    }
    

    override fun `confirmationDateTime`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_confirmation_date_time(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(TransactionDetailException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `feeFiatFmt`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_fee_fiat_fmt(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        TransactionDetailException.ErrorHandler,
    )
    }

    override fun `feeFmt`(`unit`: BitcoinUnit): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_fee_fmt(
        it,
        FfiConverterTypeBitcoinUnit.lower(`unit`),_status)
}
    }
    )
    }
    

    override fun `isConfirmed`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_is_confirmed(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isReceived`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_is_received(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isSent`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_is_sent(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(TransactionDetailException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sentSansFeeFiatFmt`() : kotlin.String {
        return uniffiRustCallAsync(
        callWithHandle { uniffiHandle ->
            UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fiat_fmt(
                uniffiHandle,
                
            )
        },
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_rust_buffer(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_rust_buffer(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_rust_buffer(future) },
        // lift function
        { FfiConverterString.lift(it) },
        // Error FFI converter
        TransactionDetailException.ErrorHandler,
    )
    }

    override fun `sentSansFeeFmt`(`unit`: BitcoinUnit): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fmt(
        it,
        FfiConverterTypeBitcoinUnit.lower(`unit`),_status)
}
    }
    )
    }
    

    override fun `transactionLabel`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_transaction_label(
        it,
        _status)
}
    }
    )
    }
    

    override fun `transactionUrl`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_transaction_url(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txId`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_transactiondetails_tx_id(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewConfirmedReceived`(): TransactionDetails {
            return FfiConverterTypeTransactionDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_received(
    
        _status)
}
    )
    }
    

         fun `previewConfirmedSent`(): TransactionDetails {
            return FfiConverterTypeTransactionDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_sent(
    
        _status)
}
    )
    }
    

         fun `previewNewConfirmed`(): TransactionDetails {
            return FfiConverterTypeTransactionDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_transactiondetails_preview_new_confirmed(
    
        _status)
}
    )
    }
    

         fun `previewNewWithLabel`(`label`: kotlin.String = "bike payment"): TransactionDetails {
            return FfiConverterTypeTransactionDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_transactiondetails_preview_new_with_label(
    
        FfiConverterString.lower(`label`),_status)
}
    )
    }
    

         fun `previewPendingReceived`(): TransactionDetails {
            return FfiConverterTypeTransactionDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_transactiondetails_preview_pending_received(
    
        _status)
}
    )
    }
    

         fun `previewPendingSent`(): TransactionDetails {
            return FfiConverterTypeTransactionDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_transactiondetails_preview_pending_sent(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeTransactionDetails: FfiConverter<TransactionDetails, Long> {
    override fun lower(value: TransactionDetails): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): TransactionDetails {
        return TransactionDetails(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): TransactionDetails {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TransactionDetails) = 8UL

    override fun write(value: TransactionDetails, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface UnconfirmedTransactionInterface {
    
    fun `fiatAmount`(): FiatAmount?
    
    fun `id`(): TxId
    
    fun `label`(): kotlin.String
    
    fun `lastSeen`(): kotlin.ULong
    
    fun `sentAndReceived`(): SentAndReceived
    
    companion object
}

open class UnconfirmedTransaction: Disposable, AutoCloseable, UnconfirmedTransactionInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_unconfirmedtransaction(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_unconfirmedtransaction(handle, status)
        }
    }

    override fun `fiatAmount`(): FiatAmount? {
            return FfiConverterOptionalTypeFiatAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unconfirmedtransaction_fiat_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `id`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unconfirmedtransaction_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `label`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unconfirmedtransaction_label(
        it,
        _status)
}
    }
    )
    }
    

    override fun `lastSeen`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unconfirmedtransaction_last_seen(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sentAndReceived`(): SentAndReceived {
            return FfiConverterTypeSentAndReceived.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unconfirmedtransaction_sent_and_received(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeUnconfirmedTransaction: FfiConverter<UnconfirmedTransaction, Long> {
    override fun lower(value: UnconfirmedTransaction): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): UnconfirmedTransaction {
        return UnconfirmedTransaction(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): UnconfirmedTransaction {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: UnconfirmedTransaction) = 8UL

    override fun write(value: UnconfirmedTransaction, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface UnsignedTransactionInterface {
    
    fun `details`(): ConfirmDetails
    
    fun `id`(): TxId
    
    fun `label`(): kotlin.String
    
    fun `sendingAmount`(): Amount
    
    fun `spendingAmount`(): Amount
    
    companion object
}

open class UnsignedTransaction: Disposable, AutoCloseable, UnsignedTransactionInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_unsignedtransaction(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_unsignedtransaction(handle, status)
        }
    }

    override fun `details`(): ConfirmDetails {
            return FfiConverterTypeConfirmDetails.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransaction_details(
        it,
        _status)
}
    }
    )
    }
    

    override fun `id`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransaction_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `label`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransaction_label(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sendingAmount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransaction_sending_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `spendingAmount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransaction_spending_amount(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewNew`(): UnsignedTransaction {
            return FfiConverterTypeUnsignedTransaction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_unsignedtransaction_preview_new(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeUnsignedTransaction: FfiConverter<UnsignedTransaction, Long> {
    override fun lower(value: UnsignedTransaction): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): UnsignedTransaction {
        return UnsignedTransaction(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): UnsignedTransaction {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: UnsignedTransaction) = 8UL

    override fun write(value: UnsignedTransaction, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface UnsignedTransactionRecordInterface {
    
    fun `confirmDetails`(): ConfirmDetails
    
    fun `createdAt`(): kotlin.ULong
    
    fun `txId`(): TxId
    
    fun `walletId`(): WalletId
    
    companion object
}

open class UnsignedTransactionRecord: Disposable, AutoCloseable, UnsignedTransactionRecordInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_unsignedtransactionrecord(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_unsignedtransactionrecord(handle, status)
        }
    }

    override fun `confirmDetails`(): ConfirmDetails {
            return FfiConverterTypeConfirmDetails.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransactionrecord_confirm_details(
        it,
        _status)
}
    }
    )
    }
    

    override fun `createdAt`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransactionrecord_created_at(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txId`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransactionrecord_tx_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `walletId`(): WalletId {
            return FfiConverterTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransactionrecord_wallet_id(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeUnsignedTransactionRecord: FfiConverter<UnsignedTransactionRecord, Long> {
    override fun lower(value: UnsignedTransactionRecord): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): UnsignedTransactionRecord {
        return UnsignedTransactionRecord(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): UnsignedTransactionRecord {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: UnsignedTransactionRecord) = 8UL

    override fun write(value: UnsignedTransactionRecord, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface UnsignedTransactionsTableInterface {
    
    fun `getTx`(`txId`: TxId): UnsignedTransactionRecord?
    
    fun `getTxThrow`(`txId`: TxId): UnsignedTransactionRecord
    
    companion object
}

open class UnsignedTransactionsTable: Disposable, AutoCloseable, UnsignedTransactionsTableInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_unsignedtransactionstable(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_unsignedtransactionstable(handle, status)
        }
    }

    override fun `getTx`(`txId`: TxId): UnsignedTransactionRecord? {
            return FfiConverterOptionalTypeUnsignedTransactionRecord.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransactionstable_gettx(
        it,
        FfiConverterTypeTxId.lower(`txId`),_status)
}
    }
    )
    }
    

    
    @Throws(UnsignedTransactionsTableException::class)override fun `getTxThrow`(`txId`: TxId): UnsignedTransactionRecord {
            return FfiConverterTypeUnsignedTransactionRecord.lift(
    callWithHandle {
    uniffiRustCallWithError(UnsignedTransactionsTableException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_unsignedtransactionstable_gettxthrow(
        it,
        FfiConverterTypeTxId.lower(`txId`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeUnsignedTransactionsTable: FfiConverter<UnsignedTransactionsTable, Long> {
    override fun lower(value: UnsignedTransactionsTable): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): UnsignedTransactionsTable {
        return UnsignedTransactionsTable(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): UnsignedTransactionsTable {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: UnsignedTransactionsTable) = 8UL

    override fun write(value: UnsignedTransactionsTable, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface WalletInterface {
    
    fun `id`(): WalletId
    
    companion object
}

open class Wallet: Disposable, AutoCloseable, WalletInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_wallet(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_wallet(handle, status)
        }
    }

    override fun `id`(): WalletId {
            return FfiConverterTypeWalletId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_wallet_id(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
        
    @Throws(WalletException::class) fun `newFromExport`(`export`: HardwareExport): Wallet {
            return FfiConverterTypeWallet.lift(
    uniffiRustCallWithError(WalletException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_wallet_new_from_export(
    
        FfiConverterTypeHardwareExport.lower(`export`),_status)
}
    )
    }
    

        
    @Throws(WalletException::class) fun `newFromXpub`(`xpub`: kotlin.String): Wallet {
            return FfiConverterTypeWallet.lift(
    uniffiRustCallWithError(WalletException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_wallet_new_from_xpub(
    
        FfiConverterString.lower(`xpub`),_status)
}
    )
    }
    

         fun `previewNewWallet`(): Wallet {
            return FfiConverterTypeWallet.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_wallet_previewnewwallet(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeWallet: FfiConverter<Wallet, Long> {
    override fun lower(value: Wallet): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Wallet {
        return Wallet(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Wallet {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Wallet) = 8UL

    override fun write(value: Wallet, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface WalletDataDbInterface {
    
    companion object
}

open class WalletDataDb: Disposable, AutoCloseable, WalletDataDbInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_walletdatadb(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_walletdatadb(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletDataDb: FfiConverter<WalletDataDb, Long> {
    override fun lower(value: WalletDataDb): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): WalletDataDb {
        return WalletDataDb(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): WalletDataDb {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: WalletDataDb) = 8UL

    override fun write(value: WalletDataDb, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface WalletKeyInterface {
    
    companion object
}

open class WalletKey: Disposable, AutoCloseable, WalletKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_walletkey(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_walletkey(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletKey: FfiConverter<WalletKey, Long> {
    override fun lower(value: WalletKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): WalletKey {
        return WalletKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): WalletKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: WalletKey) = 8UL

    override fun write(value: WalletKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface WalletsTableInterface {
    
    fun `all`(): List<WalletMetadata>
    
    fun `allSortedActive`(): List<WalletMetadata>
    
    fun `isEmpty`(): kotlin.Boolean
    
    fun `len`(`network`: Network, `mode`: WalletMode): kotlin.UShort
    
    companion object
}

open class WalletsTable: Disposable, AutoCloseable, WalletsTableInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_walletstable(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_walletstable(handle, status)
        }
    }

    
    @Throws(DatabaseException::class)override fun `all`(): List<WalletMetadata> {
            return FfiConverterSequenceTypeWalletMetadata.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_walletstable_all(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `allSortedActive`(): List<WalletMetadata> {
            return FfiConverterSequenceTypeWalletMetadata.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_walletstable_all_sorted_active(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `isEmpty`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_walletstable_is_empty(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(DatabaseException::class)override fun `len`(`network`: Network, `mode`: WalletMode): kotlin.UShort {
            return FfiConverterUShort.lift(
    callWithHandle {
    uniffiRustCallWithError(DatabaseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_walletstable_len(
        it,
        FfiConverterTypeNetwork.lower(`network`),FfiConverterTypeWalletMode.lower(`mode`),_status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletsTable: FfiConverter<WalletsTable, Long> {
    override fun lower(value: WalletsTable): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): WalletsTable {
        return WalletsTable(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): WalletsTable {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: WalletsTable) = 8UL

    override fun write(value: WalletsTable, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
public interface WordValidatorInterface {
    
    fun `isComplete`(`wordNumber`: kotlin.UByte): kotlin.Boolean
    
    fun `isWordCorrect`(`word`: kotlin.String, `for`: kotlin.UByte): kotlin.Boolean
    
    fun `possibleWords`(`for`: kotlin.UByte): List<kotlin.String>
    
    companion object
}

open class WordValidator: Disposable, AutoCloseable, WordValidatorInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_cove_fn_free_wordvalidator(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_cove_fn_clone_wordvalidator(handle, status)
        }
    }

    override fun `isComplete`(`wordNumber`: kotlin.UByte): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_wordvalidator_is_complete(
        it,
        FfiConverterUByte.lower(`wordNumber`),_status)
}
    }
    )
    }
    

    override fun `isWordCorrect`(`word`: kotlin.String, `for`: kotlin.UByte): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_wordvalidator_is_word_correct(
        it,
        FfiConverterString.lower(`word`),FfiConverterUByte.lower(`for`),_status)
}
    }
    )
    }
    

    override fun `possibleWords`(`for`: kotlin.UByte): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_method_wordvalidator_possible_words(
        it,
        FfiConverterUByte.lower(`for`),_status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `preview`(`preview`: kotlin.Boolean, `numberOfWords`: NumberOfBip39Words? = null): WordValidator {
            return FfiConverterTypeWordValidator.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_constructor_wordvalidator_preview(
    
        FfiConverterBoolean.lower(`preview`),FfiConverterOptionalTypeNumberOfBip39Words.lower(`numberOfWords`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeWordValidator: FfiConverter<WordValidator, Long> {
    override fun lower(value: WordValidator): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): WordValidator {
        return WordValidator(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): WordValidator {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: WordValidator) = 8UL

    override fun write(value: WordValidator, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}



data class AppState (
    var `router`: Router
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`router`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppState: FfiConverterRustBuffer<AppState> {
    override fun read(buf: ByteBuffer): AppState {
        return AppState(
            FfiConverterTypeRouter.read(buf),
        )
    }

    override fun allocationSize(value: AppState) = (
            FfiConverterTypeRouter.allocationSize(value.`router`)
    )

    override fun write(value: AppState, buf: ByteBuffer) {
            FfiConverterTypeRouter.write(value.`router`, buf)
    }
}



class AuthManagerState {
    override fun equals(other: Any?): Boolean {
        return other is AuthManagerState
    }

    override fun hashCode(): Int {
        return javaClass.hashCode()
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAuthManagerState: FfiConverterRustBuffer<AuthManagerState> {
    override fun read(buf: ByteBuffer): AuthManagerState {
        return AuthManagerState()
    }

    override fun allocationSize(value: AuthManagerState) = 0UL

    override fun write(value: AuthManagerState, buf: ByteBuffer) {
    }
}



data class ConfirmedDetails (
    var `blockNumber`: kotlin.UInt
    , 
    var `confirmationTime`: kotlin.ULong
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeConfirmedDetails: FfiConverterRustBuffer<ConfirmedDetails> {
    override fun read(buf: ByteBuffer): ConfirmedDetails {
        return ConfirmedDetails(
            FfiConverterUInt.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: ConfirmedDetails) = (
            FfiConverterUInt.allocationSize(value.`blockNumber`) +
            FfiConverterULong.allocationSize(value.`confirmationTime`)
    )

    override fun write(value: ConfirmedDetails, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`blockNumber`, buf)
            FfiConverterULong.write(value.`confirmationTime`, buf)
    }
}



data class ContinueFromBackup (
    var `backup`: kotlin.ByteArray
    , 
    var `continueCmd`: SetupCmd
    , 
    var `error`: TapSignerReaderException
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`backup`,
        this.`continueCmd`,
        this.`error`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContinueFromBackup: FfiConverterRustBuffer<ContinueFromBackup> {
    override fun read(buf: ByteBuffer): ContinueFromBackup {
        return ContinueFromBackup(
            FfiConverterByteArray.read(buf),
            FfiConverterTypeSetupCmd.read(buf),
            FfiConverterTypeTapSignerReaderError.read(buf),
        )
    }

    override fun allocationSize(value: ContinueFromBackup) = (
            FfiConverterByteArray.allocationSize(value.`backup`) +
            FfiConverterTypeSetupCmd.allocationSize(value.`continueCmd`) +
            FfiConverterTypeTapSignerReaderError.allocationSize(value.`error`)
    )

    override fun write(value: ContinueFromBackup, buf: ByteBuffer) {
            FfiConverterByteArray.write(value.`backup`, buf)
            FfiConverterTypeSetupCmd.write(value.`continueCmd`, buf)
            FfiConverterTypeTapSignerReaderError.write(value.`error`, buf)
    }
}



data class ContinueFromDerive (
    var `backup`: kotlin.ByteArray
    , 
    var `deriveInfo`: DeriveInfo
    , 
    var `continueCmd`: SetupCmd
    , 
    var `error`: TapSignerReaderException
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`backup`,
        this.`deriveInfo`,
        this.`continueCmd`,
        this.`error`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContinueFromDerive: FfiConverterRustBuffer<ContinueFromDerive> {
    override fun read(buf: ByteBuffer): ContinueFromDerive {
        return ContinueFromDerive(
            FfiConverterByteArray.read(buf),
            FfiConverterTypeDeriveInfo.read(buf),
            FfiConverterTypeSetupCmd.read(buf),
            FfiConverterTypeTapSignerReaderError.read(buf),
        )
    }

    override fun allocationSize(value: ContinueFromDerive) = (
            FfiConverterByteArray.allocationSize(value.`backup`) +
            FfiConverterTypeDeriveInfo.allocationSize(value.`deriveInfo`) +
            FfiConverterTypeSetupCmd.allocationSize(value.`continueCmd`) +
            FfiConverterTypeTapSignerReaderError.allocationSize(value.`error`)
    )

    override fun write(value: ContinueFromDerive, buf: ByteBuffer) {
            FfiConverterByteArray.write(value.`backup`, buf)
            FfiConverterTypeDeriveInfo.write(value.`deriveInfo`, buf)
            FfiConverterTypeSetupCmd.write(value.`continueCmd`, buf)
            FfiConverterTypeTapSignerReaderError.write(value.`error`, buf)
    }
}



data class ContinueFromInit (
    var `continueCmd`: SetupCmd
    , 
    var `error`: TapSignerReaderException
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`continueCmd`,
        this.`error`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeContinueFromInit: FfiConverterRustBuffer<ContinueFromInit> {
    override fun read(buf: ByteBuffer): ContinueFromInit {
        return ContinueFromInit(
            FfiConverterTypeSetupCmd.read(buf),
            FfiConverterTypeTapSignerReaderError.read(buf),
        )
    }

    override fun allocationSize(value: ContinueFromInit) = (
            FfiConverterTypeSetupCmd.allocationSize(value.`continueCmd`) +
            FfiConverterTypeTapSignerReaderError.allocationSize(value.`error`)
    )

    override fun write(value: ContinueFromInit, buf: ByteBuffer) {
            FfiConverterTypeSetupCmd.write(value.`continueCmd`, buf)
            FfiConverterTypeTapSignerReaderError.write(value.`error`, buf)
    }
}



data class DeriveInfo (
    var `masterPubkey`: kotlin.ByteArray
    , 
    var `pubkey`: kotlin.ByteArray
    , 
    var `chainCode`: kotlin.ByteArray
    , 
    var `path`: List<kotlin.UInt>
    , 
    var `network`: Network
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDeriveInfo: FfiConverterRustBuffer<DeriveInfo> {
    override fun read(buf: ByteBuffer): DeriveInfo {
        return DeriveInfo(
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterByteArray.read(buf),
            FfiConverterSequenceUInt.read(buf),
            FfiConverterTypeNetwork.read(buf),
        )
    }

    override fun allocationSize(value: DeriveInfo) = (
            FfiConverterByteArray.allocationSize(value.`masterPubkey`) +
            FfiConverterByteArray.allocationSize(value.`pubkey`) +
            FfiConverterByteArray.allocationSize(value.`chainCode`) +
            FfiConverterSequenceUInt.allocationSize(value.`path`) +
            FfiConverterTypeNetwork.allocationSize(value.`network`)
    )

    override fun write(value: DeriveInfo, buf: ByteBuffer) {
            FfiConverterByteArray.write(value.`masterPubkey`, buf)
            FfiConverterByteArray.write(value.`pubkey`, buf)
            FfiConverterByteArray.write(value.`chainCode`, buf)
            FfiConverterSequenceUInt.write(value.`path`, buf)
            FfiConverterTypeNetwork.write(value.`network`, buf)
    }
}



data class FeeResponse (
    var `fastestFee`: kotlin.Float
    , 
    var `halfHourFee`: kotlin.Float
    , 
    var `hourFee`: kotlin.Float
    , 
    var `economyFee`: kotlin.Float
    , 
    var `minimumFee`: kotlin.Float
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFeeResponse: FfiConverterRustBuffer<FeeResponse> {
    override fun read(buf: ByteBuffer): FeeResponse {
        return FeeResponse(
            FfiConverterFloat.read(buf),
            FfiConverterFloat.read(buf),
            FfiConverterFloat.read(buf),
            FfiConverterFloat.read(buf),
            FfiConverterFloat.read(buf),
        )
    }

    override fun allocationSize(value: FeeResponse) = (
            FfiConverterFloat.allocationSize(value.`fastestFee`) +
            FfiConverterFloat.allocationSize(value.`halfHourFee`) +
            FfiConverterFloat.allocationSize(value.`hourFee`) +
            FfiConverterFloat.allocationSize(value.`economyFee`) +
            FfiConverterFloat.allocationSize(value.`minimumFee`)
    )

    override fun write(value: FeeResponse, buf: ByteBuffer) {
            FfiConverterFloat.write(value.`fastestFee`, buf)
            FfiConverterFloat.write(value.`halfHourFee`, buf)
            FfiConverterFloat.write(value.`hourFee`, buf)
            FfiConverterFloat.write(value.`economyFee`, buf)
            FfiConverterFloat.write(value.`minimumFee`, buf)
    }
}



data class FiatAmount (
    var `amount`: kotlin.Double
    , 
    var `currency`: FiatCurrency
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFiatAmount: FfiConverterRustBuffer<FiatAmount> {
    override fun read(buf: ByteBuffer): FiatAmount {
        return FiatAmount(
            FfiConverterDouble.read(buf),
            FfiConverterTypeFiatCurrency.read(buf),
        )
    }

    override fun allocationSize(value: FiatAmount) = (
            FfiConverterDouble.allocationSize(value.`amount`) +
            FfiConverterTypeFiatCurrency.allocationSize(value.`currency`)
    )

    override fun write(value: FiatAmount, buf: ByteBuffer) {
            FfiConverterDouble.write(value.`amount`, buf)
            FfiConverterTypeFiatCurrency.write(value.`currency`, buf)
    }
}



data class FoundAddress (
    var `type`: WalletAddressType
    , 
    var `firstAddress`: kotlin.String
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFoundAddress: FfiConverterRustBuffer<FoundAddress> {
    override fun read(buf: ByteBuffer): FoundAddress {
        return FoundAddress(
            FfiConverterTypeWalletAddressType.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: FoundAddress) = (
            FfiConverterTypeWalletAddressType.allocationSize(value.`type`) +
            FfiConverterString.allocationSize(value.`firstAddress`)
    )

    override fun write(value: FoundAddress, buf: ByteBuffer) {
            FfiConverterTypeWalletAddressType.write(value.`type`, buf)
            FfiConverterString.write(value.`firstAddress`, buf)
    }
}



data class GroupedWord (
    var `number`: kotlin.UByte
    , 
    var `word`: kotlin.String
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGroupedWord: FfiConverterRustBuffer<GroupedWord> {
    override fun read(buf: ByteBuffer): GroupedWord {
        return GroupedWord(
            FfiConverterUByte.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: GroupedWord) = (
            FfiConverterUByte.allocationSize(value.`number`) +
            FfiConverterString.allocationSize(value.`word`)
    )

    override fun write(value: GroupedWord, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`number`, buf)
            FfiConverterString.write(value.`word`, buf)
    }
}



/**
 * A space-efficient version of HistoricalPrice where only USD is required
 * and other currencies are optional to save space when they aren't available
 */
data class HistoricalPriceRecord (
    var `time`: kotlin.ULong
    , 
    var `usd`: kotlin.Float
    , 
    var `eur`: kotlin.Float?
    , 
    var `gbp`: kotlin.Float?
    , 
    var `cad`: kotlin.Float?
    , 
    var `chf`: kotlin.Float?
    , 
    var `aud`: kotlin.Float?
    , 
    var `jpy`: kotlin.Float?
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHistoricalPriceRecord: FfiConverterRustBuffer<HistoricalPriceRecord> {
    override fun read(buf: ByteBuffer): HistoricalPriceRecord {
        return HistoricalPriceRecord(
            FfiConverterULong.read(buf),
            FfiConverterFloat.read(buf),
            FfiConverterOptionalFloat.read(buf),
            FfiConverterOptionalFloat.read(buf),
            FfiConverterOptionalFloat.read(buf),
            FfiConverterOptionalFloat.read(buf),
            FfiConverterOptionalFloat.read(buf),
            FfiConverterOptionalFloat.read(buf),
        )
    }

    override fun allocationSize(value: HistoricalPriceRecord) = (
            FfiConverterULong.allocationSize(value.`time`) +
            FfiConverterFloat.allocationSize(value.`usd`) +
            FfiConverterOptionalFloat.allocationSize(value.`eur`) +
            FfiConverterOptionalFloat.allocationSize(value.`gbp`) +
            FfiConverterOptionalFloat.allocationSize(value.`cad`) +
            FfiConverterOptionalFloat.allocationSize(value.`chf`) +
            FfiConverterOptionalFloat.allocationSize(value.`aud`) +
            FfiConverterOptionalFloat.allocationSize(value.`jpy`)
    )

    override fun write(value: HistoricalPriceRecord, buf: ByteBuffer) {
            FfiConverterULong.write(value.`time`, buf)
            FfiConverterFloat.write(value.`usd`, buf)
            FfiConverterOptionalFloat.write(value.`eur`, buf)
            FfiConverterOptionalFloat.write(value.`gbp`, buf)
            FfiConverterOptionalFloat.write(value.`cad`, buf)
            FfiConverterOptionalFloat.write(value.`chf`, buf)
            FfiConverterOptionalFloat.write(value.`aud`, buf)
            FfiConverterOptionalFloat.write(value.`jpy`, buf)
    }
}



class ImportWalletManagerState {
    override fun equals(other: Any?): Boolean {
        return other is ImportWalletManagerState
    }

    override fun hashCode(): Int {
        return javaClass.hashCode()
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeImportWalletManagerState: FfiConverterRustBuffer<ImportWalletManagerState> {
    override fun read(buf: ByteBuffer): ImportWalletManagerState {
        return ImportWalletManagerState()
    }

    override fun allocationSize(value: ImportWalletManagerState) = 0UL

    override fun write(value: ImportWalletManagerState, buf: ByteBuffer) {
    }
}



data class InternalOnlyMetadata (
    var `addressIndex`: AddressIndex?
    , 
    /**
     * this is the last time the wallet was scanned, this includes the initial scna, expanded scan, and incremental scan
     */
    var `lastScanFinished`: java.time.Duration?
    , 
    var `lastHeightFetched`: BlockSizeLast?
    , 
    /**
     * this is the time that a full expanded scan was completed, this should only happen once
     */
    var `performedFullScanAt`: kotlin.ULong?
    , 
    var `storeType`: StoreType
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeInternalOnlyMetadata: FfiConverterRustBuffer<InternalOnlyMetadata> {
    override fun read(buf: ByteBuffer): InternalOnlyMetadata {
        return InternalOnlyMetadata(
            FfiConverterOptionalTypeAddressIndex.read(buf),
            FfiConverterOptionalDuration.read(buf),
            FfiConverterOptionalTypeBlockSizeLast.read(buf),
            FfiConverterOptionalULong.read(buf),
            FfiConverterTypeStoreType.read(buf),
        )
    }

    override fun allocationSize(value: InternalOnlyMetadata) = (
            FfiConverterOptionalTypeAddressIndex.allocationSize(value.`addressIndex`) +
            FfiConverterOptionalDuration.allocationSize(value.`lastScanFinished`) +
            FfiConverterOptionalTypeBlockSizeLast.allocationSize(value.`lastHeightFetched`) +
            FfiConverterOptionalULong.allocationSize(value.`performedFullScanAt`) +
            FfiConverterTypeStoreType.allocationSize(value.`storeType`)
    )

    override fun write(value: InternalOnlyMetadata, buf: ByteBuffer) {
            FfiConverterOptionalTypeAddressIndex.write(value.`addressIndex`, buf)
            FfiConverterOptionalDuration.write(value.`lastScanFinished`, buf)
            FfiConverterOptionalTypeBlockSizeLast.write(value.`lastHeightFetched`, buf)
            FfiConverterOptionalULong.write(value.`performedFullScanAt`, buf)
            FfiConverterTypeStoreType.write(value.`storeType`, buf)
    }
}



data class Node (
    var `name`: kotlin.String
    , 
    var `network`: Network
    , 
    var `apiType`: ApiType
    , 
    var `url`: kotlin.String
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNode: FfiConverterRustBuffer<Node> {
    override fun read(buf: ByteBuffer): Node {
        return Node(
            FfiConverterString.read(buf),
            FfiConverterTypeNetwork.read(buf),
            FfiConverterTypeApiType.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: Node) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeNetwork.allocationSize(value.`network`) +
            FfiConverterTypeApiType.allocationSize(value.`apiType`) +
            FfiConverterString.allocationSize(value.`url`)
    )

    override fun write(value: Node, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeNetwork.write(value.`network`, buf)
            FfiConverterTypeApiType.write(value.`apiType`, buf)
            FfiConverterString.write(value.`url`, buf)
    }
}



data class PendingDetails (
    var `lastSeen`: kotlin.ULong
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePendingDetails: FfiConverterRustBuffer<PendingDetails> {
    override fun read(buf: ByteBuffer): PendingDetails {
        return PendingDetails(
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: PendingDetails) = (
            FfiConverterULong.allocationSize(value.`lastSeen`)
    )

    override fun write(value: PendingDetails, buf: ByteBuffer) {
            FfiConverterULong.write(value.`lastSeen`, buf)
    }
}



data class PendingWalletManagerState (
    var `numberOfWords`: NumberOfBip39Words
    , 
    var `wallet`: PendingWallet
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`numberOfWords`,
        this.`wallet`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePendingWalletManagerState: FfiConverterRustBuffer<PendingWalletManagerState> {
    override fun read(buf: ByteBuffer): PendingWalletManagerState {
        return PendingWalletManagerState(
            FfiConverterTypeNumberOfBip39Words.read(buf),
            FfiConverterTypePendingWallet.read(buf),
        )
    }

    override fun allocationSize(value: PendingWalletManagerState) = (
            FfiConverterTypeNumberOfBip39Words.allocationSize(value.`numberOfWords`) +
            FfiConverterTypePendingWallet.allocationSize(value.`wallet`)
    )

    override fun write(value: PendingWalletManagerState, buf: ByteBuffer) {
            FfiConverterTypeNumberOfBip39Words.write(value.`numberOfWords`, buf)
            FfiConverterTypePendingWallet.write(value.`wallet`, buf)
    }
}



data class Router (
    var `app`: FfiApp
    , 
    var `default`: Route
    , 
    var `routes`: List<Route>
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`app`,
        this.`default`,
        this.`routes`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRouter: FfiConverterRustBuffer<Router> {
    override fun read(buf: ByteBuffer): Router {
        return Router(
            FfiConverterTypeFfiApp.read(buf),
            FfiConverterTypeRoute.read(buf),
            FfiConverterSequenceTypeRoute.read(buf),
        )
    }

    override fun allocationSize(value: Router) = (
            FfiConverterTypeFfiApp.allocationSize(value.`app`) +
            FfiConverterTypeRoute.allocationSize(value.`default`) +
            FfiConverterSequenceTypeRoute.allocationSize(value.`routes`)
    )

    override fun write(value: Router, buf: ByteBuffer) {
            FfiConverterTypeFfiApp.write(value.`app`, buf)
            FfiConverterTypeRoute.write(value.`default`, buf)
            FfiConverterSequenceTypeRoute.write(value.`routes`, buf)
    }
}



data class ScanningInfo (
    var `addressType`: WalletAddressType
    , 
    var `count`: kotlin.UInt
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScanningInfo: FfiConverterRustBuffer<ScanningInfo> {
    override fun read(buf: ByteBuffer): ScanningInfo {
        return ScanningInfo(
            FfiConverterTypeWalletAddressType.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ScanningInfo) = (
            FfiConverterTypeWalletAddressType.allocationSize(value.`addressType`) +
            FfiConverterUInt.allocationSize(value.`count`)
    )

    override fun write(value: ScanningInfo, buf: ByteBuffer) {
            FfiConverterTypeWalletAddressType.write(value.`addressType`, buf)
            FfiConverterUInt.write(value.`count`, buf)
    }
}



data class SendFlowCoinControlMode (
    var `utxoList`: UtxoList
    , 
    var `isMaxSelected`: kotlin.Boolean
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`utxoList`,
        this.`isMaxSelected`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowCoinControlMode: FfiConverterRustBuffer<SendFlowCoinControlMode> {
    override fun read(buf: ByteBuffer): SendFlowCoinControlMode {
        return SendFlowCoinControlMode(
            FfiConverterTypeUtxoList.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: SendFlowCoinControlMode) = (
            FfiConverterTypeUtxoList.allocationSize(value.`utxoList`) +
            FfiConverterBoolean.allocationSize(value.`isMaxSelected`)
    )

    override fun write(value: SendFlowCoinControlMode, buf: ByteBuffer) {
            FfiConverterTypeUtxoList.write(value.`utxoList`, buf)
            FfiConverterBoolean.write(value.`isMaxSelected`, buf)
    }
}



data class SendRouteConfirmArgs (
    var `id`: WalletId
    , 
    var `details`: ConfirmDetails
    , 
    var `signedTransaction`: BitcoinTransaction?
    , 
    var `signedPsbt`: Psbt?
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`id`,
        this.`details`,
        this.`signedTransaction`,
        this.`signedPsbt`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendRouteConfirmArgs: FfiConverterRustBuffer<SendRouteConfirmArgs> {
    override fun read(buf: ByteBuffer): SendRouteConfirmArgs {
        return SendRouteConfirmArgs(
            FfiConverterTypeWalletId.read(buf),
            FfiConverterTypeConfirmDetails.read(buf),
            FfiConverterOptionalTypeBitcoinTransaction.read(buf),
            FfiConverterOptionalTypePsbt.read(buf),
        )
    }

    override fun allocationSize(value: SendRouteConfirmArgs) = (
            FfiConverterTypeWalletId.allocationSize(value.`id`) +
            FfiConverterTypeConfirmDetails.allocationSize(value.`details`) +
            FfiConverterOptionalTypeBitcoinTransaction.allocationSize(value.`signedTransaction`) +
            FfiConverterOptionalTypePsbt.allocationSize(value.`signedPsbt`)
    )

    override fun write(value: SendRouteConfirmArgs, buf: ByteBuffer) {
            FfiConverterTypeWalletId.write(value.`id`, buf)
            FfiConverterTypeConfirmDetails.write(value.`details`, buf)
            FfiConverterOptionalTypeBitcoinTransaction.write(value.`signedTransaction`, buf)
            FfiConverterOptionalTypePsbt.write(value.`signedPsbt`, buf)
    }
}



data class TapSignerConfirmPinArgs (
    var `tapSigner`: TapSigner
    , 
    var `startingPin`: kotlin.String
    , 
    var `newPin`: kotlin.String
    , 
    var `chainCode`: kotlin.String?
    , 
    var `action`: TapSignerPinAction
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`tapSigner`,
        this.`startingPin`,
        this.`newPin`,
        this.`chainCode`,
        this.`action`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerConfirmPinArgs: FfiConverterRustBuffer<TapSignerConfirmPinArgs> {
    override fun read(buf: ByteBuffer): TapSignerConfirmPinArgs {
        return TapSignerConfirmPinArgs(
            FfiConverterTypeTapSigner.read(buf),
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeTapSignerPinAction.read(buf),
        )
    }

    override fun allocationSize(value: TapSignerConfirmPinArgs) = (
            FfiConverterTypeTapSigner.allocationSize(value.`tapSigner`) +
            FfiConverterString.allocationSize(value.`startingPin`) +
            FfiConverterString.allocationSize(value.`newPin`) +
            FfiConverterOptionalString.allocationSize(value.`chainCode`) +
            FfiConverterTypeTapSignerPinAction.allocationSize(value.`action`)
    )

    override fun write(value: TapSignerConfirmPinArgs, buf: ByteBuffer) {
            FfiConverterTypeTapSigner.write(value.`tapSigner`, buf)
            FfiConverterString.write(value.`startingPin`, buf)
            FfiConverterString.write(value.`newPin`, buf)
            FfiConverterOptionalString.write(value.`chainCode`, buf)
            FfiConverterTypeTapSignerPinAction.write(value.`action`, buf)
    }
}



data class TapSignerNewPinArgs (
    var `tapSigner`: TapSigner
    , 
    var `startingPin`: kotlin.String
    , 
    var `chainCode`: kotlin.String?
    , 
    var `action`: TapSignerPinAction
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`tapSigner`,
        this.`startingPin`,
        this.`chainCode`,
        this.`action`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerNewPinArgs: FfiConverterRustBuffer<TapSignerNewPinArgs> {
    override fun read(buf: ByteBuffer): TapSignerNewPinArgs {
        return TapSignerNewPinArgs(
            FfiConverterTypeTapSigner.read(buf),
            FfiConverterString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterTypeTapSignerPinAction.read(buf),
        )
    }

    override fun allocationSize(value: TapSignerNewPinArgs) = (
            FfiConverterTypeTapSigner.allocationSize(value.`tapSigner`) +
            FfiConverterString.allocationSize(value.`startingPin`) +
            FfiConverterOptionalString.allocationSize(value.`chainCode`) +
            FfiConverterTypeTapSignerPinAction.allocationSize(value.`action`)
    )

    override fun write(value: TapSignerNewPinArgs, buf: ByteBuffer) {
            FfiConverterTypeTapSigner.write(value.`tapSigner`, buf)
            FfiConverterString.write(value.`startingPin`, buf)
            FfiConverterOptionalString.write(value.`chainCode`, buf)
            FfiConverterTypeTapSignerPinAction.write(value.`action`, buf)
    }
}



data class TapSignerSetupComplete (
    var `backup`: kotlin.ByteArray
    , 
    var `deriveInfo`: DeriveInfo
    
){
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerSetupComplete: FfiConverterRustBuffer<TapSignerSetupComplete> {
    override fun read(buf: ByteBuffer): TapSignerSetupComplete {
        return TapSignerSetupComplete(
            FfiConverterByteArray.read(buf),
            FfiConverterTypeDeriveInfo.read(buf),
        )
    }

    override fun allocationSize(value: TapSignerSetupComplete) = (
            FfiConverterByteArray.allocationSize(value.`backup`) +
            FfiConverterTypeDeriveInfo.allocationSize(value.`deriveInfo`)
    )

    override fun write(value: TapSignerSetupComplete, buf: ByteBuffer) {
            FfiConverterByteArray.write(value.`backup`, buf)
            FfiConverterTypeDeriveInfo.write(value.`deriveInfo`, buf)
    }
}



data class WalletMetadata (
    var `id`: WalletId
    , 
    var `name`: kotlin.String
    , 
    var `color`: WalletColor
    , 
    var `verified`: kotlin.Boolean
    , 
    var `network`: Network
    , 
    var `masterFingerprint`: Fingerprint?
    , 
    var `selectedUnit`: BitcoinUnit
    , 
    var `sensitiveVisible`: kotlin.Boolean
    , 
    var `detailsExpanded`: kotlin.Boolean
    , 
    var `walletType`: WalletType
    , 
    var `walletMode`: WalletMode
    , 
    var `discoveryState`: DiscoveryState
    , 
    var `addressType`: WalletAddressType
    , 
    var `fiatOrBtc`: FiatOrBtc
    , 
    var `origin`: kotlin.String?
    , 
    /**
     * Metadata data specific to different hardware wallets
     */
    var `hardwareMetadata`: HardwareWalletMetadata?
    , 
    /**
     * Show labels for transactions i the transaction list
     * If false, we only show either `Sent` or `Received` labels
     */
    var `showLabels`: kotlin.Boolean
    , 
    var `internal`: InternalOnlyMetadata
    
): Disposable{
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`id`,
        this.`name`,
        this.`color`,
        this.`verified`,
        this.`network`,
        this.`masterFingerprint`,
        this.`selectedUnit`,
        this.`sensitiveVisible`,
        this.`detailsExpanded`,
        this.`walletType`,
        this.`walletMode`,
        this.`discoveryState`,
        this.`addressType`,
        this.`fiatOrBtc`,
        this.`origin`,
        this.`hardwareMetadata`,
        this.`showLabels`,
        this.`internal`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletMetadata: FfiConverterRustBuffer<WalletMetadata> {
    override fun read(buf: ByteBuffer): WalletMetadata {
        return WalletMetadata(
            FfiConverterTypeWalletId.read(buf),
            FfiConverterString.read(buf),
            FfiConverterTypeWalletColor.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeNetwork.read(buf),
            FfiConverterOptionalTypeFingerprint.read(buf),
            FfiConverterTypeBitcoinUnit.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeWalletType.read(buf),
            FfiConverterTypeWalletMode.read(buf),
            FfiConverterTypeDiscoveryState.read(buf),
            FfiConverterTypeWalletAddressType.read(buf),
            FfiConverterTypeFiatOrBtc.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeHardwareWalletMetadata.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeInternalOnlyMetadata.read(buf),
        )
    }

    override fun allocationSize(value: WalletMetadata) = (
            FfiConverterTypeWalletId.allocationSize(value.`id`) +
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterTypeWalletColor.allocationSize(value.`color`) +
            FfiConverterBoolean.allocationSize(value.`verified`) +
            FfiConverterTypeNetwork.allocationSize(value.`network`) +
            FfiConverterOptionalTypeFingerprint.allocationSize(value.`masterFingerprint`) +
            FfiConverterTypeBitcoinUnit.allocationSize(value.`selectedUnit`) +
            FfiConverterBoolean.allocationSize(value.`sensitiveVisible`) +
            FfiConverterBoolean.allocationSize(value.`detailsExpanded`) +
            FfiConverterTypeWalletType.allocationSize(value.`walletType`) +
            FfiConverterTypeWalletMode.allocationSize(value.`walletMode`) +
            FfiConverterTypeDiscoveryState.allocationSize(value.`discoveryState`) +
            FfiConverterTypeWalletAddressType.allocationSize(value.`addressType`) +
            FfiConverterTypeFiatOrBtc.allocationSize(value.`fiatOrBtc`) +
            FfiConverterOptionalString.allocationSize(value.`origin`) +
            FfiConverterOptionalTypeHardwareWalletMetadata.allocationSize(value.`hardwareMetadata`) +
            FfiConverterBoolean.allocationSize(value.`showLabels`) +
            FfiConverterTypeInternalOnlyMetadata.allocationSize(value.`internal`)
    )

    override fun write(value: WalletMetadata, buf: ByteBuffer) {
            FfiConverterTypeWalletId.write(value.`id`, buf)
            FfiConverterString.write(value.`name`, buf)
            FfiConverterTypeWalletColor.write(value.`color`, buf)
            FfiConverterBoolean.write(value.`verified`, buf)
            FfiConverterTypeNetwork.write(value.`network`, buf)
            FfiConverterOptionalTypeFingerprint.write(value.`masterFingerprint`, buf)
            FfiConverterTypeBitcoinUnit.write(value.`selectedUnit`, buf)
            FfiConverterBoolean.write(value.`sensitiveVisible`, buf)
            FfiConverterBoolean.write(value.`detailsExpanded`, buf)
            FfiConverterTypeWalletType.write(value.`walletType`, buf)
            FfiConverterTypeWalletMode.write(value.`walletMode`, buf)
            FfiConverterTypeDiscoveryState.write(value.`discoveryState`, buf)
            FfiConverterTypeWalletAddressType.write(value.`addressType`, buf)
            FfiConverterTypeFiatOrBtc.write(value.`fiatOrBtc`, buf)
            FfiConverterOptionalString.write(value.`origin`, buf)
            FfiConverterOptionalTypeHardwareWalletMetadata.write(value.`hardwareMetadata`, buf)
            FfiConverterBoolean.write(value.`showLabels`, buf)
            FfiConverterTypeInternalOnlyMetadata.write(value.`internal`, buf)
    }
}



sealed class AfterPinAction: Disposable  {
    
    object Derive : AfterPinAction()
    
    
    object Change : AfterPinAction()
    
    
    object Backup : AfterPinAction()
    
    
    data class Sign(
        val v1: Psbt) : AfterPinAction()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AfterPinAction.Derive -> {// Nothing to destroy
            }
            is AfterPinAction.Change -> {// Nothing to destroy
            }
            is AfterPinAction.Backup -> {// Nothing to destroy
            }
            is AfterPinAction.Sign -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAfterPinAction : FfiConverterRustBuffer<AfterPinAction>{
    override fun read(buf: ByteBuffer): AfterPinAction {
        return when(buf.getInt()) {
            1 -> AfterPinAction.Derive
            2 -> AfterPinAction.Change
            3 -> AfterPinAction.Backup
            4 -> AfterPinAction.Sign(
                FfiConverterTypePsbt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AfterPinAction) = when(value) {
        is AfterPinAction.Derive -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AfterPinAction.Change -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AfterPinAction.Backup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AfterPinAction.Sign -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePsbt.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AfterPinAction, buf: ByteBuffer) {
        when(value) {
            is AfterPinAction.Derive -> {
                buf.putInt(1)
                Unit
            }
            is AfterPinAction.Change -> {
                buf.putInt(2)
                Unit
            }
            is AfterPinAction.Backup -> {
                buf.putInt(3)
                Unit
            }
            is AfterPinAction.Sign -> {
                buf.putInt(4)
                FfiConverterTypePsbt.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class AmountOrMax: Disposable  {
    
    data class Amt(
        val v1: Amount) : AmountOrMax()
        
    {
        

        companion object
    }
    
    object Max : AmountOrMax()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AmountOrMax.Amt -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AmountOrMax.Max -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAmountOrMax : FfiConverterRustBuffer<AmountOrMax>{
    override fun read(buf: ByteBuffer): AmountOrMax {
        return when(buf.getInt()) {
            1 -> AmountOrMax.Amt(
                FfiConverterTypeAmount.read(buf),
                )
            2 -> AmountOrMax.Max
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AmountOrMax) = when(value) {
        is AmountOrMax.Amt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAmount.allocationSize(value.v1)
            )
        }
        is AmountOrMax.Max -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AmountOrMax, buf: ByteBuffer) {
        when(value) {
            is AmountOrMax.Amt -> {
                buf.putInt(1)
                FfiConverterTypeAmount.write(value.v1, buf)
                Unit
            }
            is AmountOrMax.Max -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ApiType {
    
    ESPLORA,
    ELECTRUM,
    RPC;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeApiType: FfiConverterRustBuffer<ApiType> {
    override fun read(buf: ByteBuffer) = try {
        ApiType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ApiType) = 4UL

    override fun write(value: ApiType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class AppAction: Disposable  {
    
    data class UpdateRoute(
        val `routes`: List<Route>) : AppAction()
        
    {
        

        companion object
    }
    
    data class PushRoute(
        val v1: Route) : AppAction()
        
    {
        

        companion object
    }
    
    data class ChangeNetwork(
        val `network`: Network) : AppAction()
        
    {
        

        companion object
    }
    
    data class ChangeColorScheme(
        val v1: ColorSchemeSelection) : AppAction()
        
    {
        

        companion object
    }
    
    data class ChangeFiatCurrency(
        val v1: FiatCurrency) : AppAction()
        
    {
        

        companion object
    }
    
    data class SetSelectedNode(
        val v1: Node) : AppAction()
        
    {
        

        companion object
    }
    
    object UpdateFiatPrices : AppAction()
    
    
    object UpdateFees : AppAction()
    
    
    object AcceptTerms : AppAction()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AppAction.UpdateRoute -> {
                
    Disposable.destroy(
        this.`routes`
    )
                
            }
            is AppAction.PushRoute -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppAction.ChangeNetwork -> {
                
    Disposable.destroy(
        this.`network`
    )
                
            }
            is AppAction.ChangeColorScheme -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppAction.ChangeFiatCurrency -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppAction.SetSelectedNode -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppAction.UpdateFiatPrices -> {// Nothing to destroy
            }
            is AppAction.UpdateFees -> {// Nothing to destroy
            }
            is AppAction.AcceptTerms -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppAction : FfiConverterRustBuffer<AppAction>{
    override fun read(buf: ByteBuffer): AppAction {
        return when(buf.getInt()) {
            1 -> AppAction.UpdateRoute(
                FfiConverterSequenceTypeRoute.read(buf),
                )
            2 -> AppAction.PushRoute(
                FfiConverterTypeRoute.read(buf),
                )
            3 -> AppAction.ChangeNetwork(
                FfiConverterTypeNetwork.read(buf),
                )
            4 -> AppAction.ChangeColorScheme(
                FfiConverterTypeColorSchemeSelection.read(buf),
                )
            5 -> AppAction.ChangeFiatCurrency(
                FfiConverterTypeFiatCurrency.read(buf),
                )
            6 -> AppAction.SetSelectedNode(
                FfiConverterTypeNode.read(buf),
                )
            7 -> AppAction.UpdateFiatPrices
            8 -> AppAction.UpdateFees
            9 -> AppAction.AcceptTerms
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AppAction) = when(value) {
        is AppAction.UpdateRoute -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoute.allocationSize(value.`routes`)
            )
        }
        is AppAction.PushRoute -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoute.allocationSize(value.v1)
            )
        }
        is AppAction.ChangeNetwork -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNetwork.allocationSize(value.`network`)
            )
        }
        is AppAction.ChangeColorScheme -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeColorSchemeSelection.allocationSize(value.v1)
            )
        }
        is AppAction.ChangeFiatCurrency -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFiatCurrency.allocationSize(value.v1)
            )
        }
        is AppAction.SetSelectedNode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNode.allocationSize(value.v1)
            )
        }
        is AppAction.UpdateFiatPrices -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AppAction.UpdateFees -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AppAction.AcceptTerms -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AppAction, buf: ByteBuffer) {
        when(value) {
            is AppAction.UpdateRoute -> {
                buf.putInt(1)
                FfiConverterSequenceTypeRoute.write(value.`routes`, buf)
                Unit
            }
            is AppAction.PushRoute -> {
                buf.putInt(2)
                FfiConverterTypeRoute.write(value.v1, buf)
                Unit
            }
            is AppAction.ChangeNetwork -> {
                buf.putInt(3)
                FfiConverterTypeNetwork.write(value.`network`, buf)
                Unit
            }
            is AppAction.ChangeColorScheme -> {
                buf.putInt(4)
                FfiConverterTypeColorSchemeSelection.write(value.v1, buf)
                Unit
            }
            is AppAction.ChangeFiatCurrency -> {
                buf.putInt(5)
                FfiConverterTypeFiatCurrency.write(value.v1, buf)
                Unit
            }
            is AppAction.SetSelectedNode -> {
                buf.putInt(6)
                FfiConverterTypeNode.write(value.v1, buf)
                Unit
            }
            is AppAction.UpdateFiatPrices -> {
                buf.putInt(7)
                Unit
            }
            is AppAction.UpdateFees -> {
                buf.putInt(8)
                Unit
            }
            is AppAction.AcceptTerms -> {
                buf.putInt(9)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class AppException: kotlin.Exception() {
    
    class PricesException(
        
        val v1: kotlin.String
        ) : AppException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class FeesException(
        
        val v1: kotlin.String
        ) : AppException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<AppException> {
        override fun lift(error_buf: RustBuffer.ByValue): AppException = FfiConverterTypeAppError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeAppError : FfiConverterRustBuffer<AppException> {
    override fun read(buf: ByteBuffer): AppException {
        

        return when(buf.getInt()) {
            1 -> AppException.PricesException(
                FfiConverterString.read(buf),
                )
            2 -> AppException.FeesException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AppException): ULong {
        return when(value) {
            is AppException.PricesException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is AppException.FeesException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AppException, buf: ByteBuffer) {
        when(value) {
            is AppException.PricesException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is AppException.FeesException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class AppStateReconcileMessage: Disposable  {
    
    data class DefaultRouteChanged(
        val v1: Route, 
        val v2: List<Route>) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class RouteUpdated(
        val v1: List<Route>) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    object DatabaseUpdated : AppStateReconcileMessage()
    
    
    data class ColorSchemeChanged(
        val v1: ColorSchemeSelection) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class SelectedNodeChanged(
        val v1: Node) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class SelectedNetworkChanged(
        val v1: Network) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class FiatPricesChanged(
        val v1: PriceResponse) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class FeesChanged(
        val v1: FeeResponse) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class FiatCurrencyChanged(
        val v1: FiatCurrency) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class WalletModeChanged(
        val v1: WalletMode) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    data class PushedRoute(
        val v1: Route) : AppStateReconcileMessage()
        
    {
        

        companion object
    }
    
    object AcceptedTerms : AppStateReconcileMessage()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AppStateReconcileMessage.DefaultRouteChanged -> {
                
    Disposable.destroy(
        this.v1,
        this.v2
    )
                
            }
            is AppStateReconcileMessage.RouteUpdated -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.DatabaseUpdated -> {// Nothing to destroy
            }
            is AppStateReconcileMessage.ColorSchemeChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.SelectedNodeChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.SelectedNetworkChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.FiatPricesChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.FeesChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.FiatCurrencyChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.WalletModeChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.PushedRoute -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is AppStateReconcileMessage.AcceptedTerms -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppStateReconcileMessage : FfiConverterRustBuffer<AppStateReconcileMessage>{
    override fun read(buf: ByteBuffer): AppStateReconcileMessage {
        return when(buf.getInt()) {
            1 -> AppStateReconcileMessage.DefaultRouteChanged(
                FfiConverterTypeRoute.read(buf),
                FfiConverterSequenceTypeRoute.read(buf),
                )
            2 -> AppStateReconcileMessage.RouteUpdated(
                FfiConverterSequenceTypeRoute.read(buf),
                )
            3 -> AppStateReconcileMessage.DatabaseUpdated
            4 -> AppStateReconcileMessage.ColorSchemeChanged(
                FfiConverterTypeColorSchemeSelection.read(buf),
                )
            5 -> AppStateReconcileMessage.SelectedNodeChanged(
                FfiConverterTypeNode.read(buf),
                )
            6 -> AppStateReconcileMessage.SelectedNetworkChanged(
                FfiConverterTypeNetwork.read(buf),
                )
            7 -> AppStateReconcileMessage.FiatPricesChanged(
                FfiConverterTypePriceResponse.read(buf),
                )
            8 -> AppStateReconcileMessage.FeesChanged(
                FfiConverterTypeFeeResponse.read(buf),
                )
            9 -> AppStateReconcileMessage.FiatCurrencyChanged(
                FfiConverterTypeFiatCurrency.read(buf),
                )
            10 -> AppStateReconcileMessage.WalletModeChanged(
                FfiConverterTypeWalletMode.read(buf),
                )
            11 -> AppStateReconcileMessage.PushedRoute(
                FfiConverterTypeRoute.read(buf),
                )
            12 -> AppStateReconcileMessage.AcceptedTerms
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AppStateReconcileMessage) = when(value) {
        is AppStateReconcileMessage.DefaultRouteChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoute.allocationSize(value.v1)
                + FfiConverterSequenceTypeRoute.allocationSize(value.v2)
            )
        }
        is AppStateReconcileMessage.RouteUpdated -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeRoute.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.DatabaseUpdated -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AppStateReconcileMessage.ColorSchemeChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeColorSchemeSelection.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.SelectedNodeChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNode.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.SelectedNetworkChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNetwork.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.FiatPricesChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePriceResponse.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.FeesChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFeeResponse.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.FiatCurrencyChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFiatCurrency.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.WalletModeChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletMode.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.PushedRoute -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRoute.allocationSize(value.v1)
            )
        }
        is AppStateReconcileMessage.AcceptedTerms -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AppStateReconcileMessage, buf: ByteBuffer) {
        when(value) {
            is AppStateReconcileMessage.DefaultRouteChanged -> {
                buf.putInt(1)
                FfiConverterTypeRoute.write(value.v1, buf)
                FfiConverterSequenceTypeRoute.write(value.v2, buf)
                Unit
            }
            is AppStateReconcileMessage.RouteUpdated -> {
                buf.putInt(2)
                FfiConverterSequenceTypeRoute.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.DatabaseUpdated -> {
                buf.putInt(3)
                Unit
            }
            is AppStateReconcileMessage.ColorSchemeChanged -> {
                buf.putInt(4)
                FfiConverterTypeColorSchemeSelection.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.SelectedNodeChanged -> {
                buf.putInt(5)
                FfiConverterTypeNode.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.SelectedNetworkChanged -> {
                buf.putInt(6)
                FfiConverterTypeNetwork.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.FiatPricesChanged -> {
                buf.putInt(7)
                FfiConverterTypePriceResponse.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.FeesChanged -> {
                buf.putInt(8)
                FfiConverterTypeFeeResponse.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.FiatCurrencyChanged -> {
                buf.putInt(9)
                FfiConverterTypeFiatCurrency.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.WalletModeChanged -> {
                buf.putInt(10)
                FfiConverterTypeWalletMode.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.PushedRoute -> {
                buf.putInt(11)
                FfiConverterTypeRoute.write(value.v1, buf)
                Unit
            }
            is AppStateReconcileMessage.AcceptedTerms -> {
                buf.putInt(12)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class AuthException: kotlin.Exception() {
    
    class DatabaseSaveException(
        
        val v1: DatabaseException
        ) : AuthException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class DatabaseGetException(
        
        val v1: DatabaseException
        ) : AuthException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class HashException(
        
        val v1: kotlin.String
        ) : AuthException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ParseHashedPinException(
        
        val v1: kotlin.String
        ) : AuthException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class VerificationFailed(
        
        val v1: kotlin.String
        ) : AuthException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<AuthException> {
        override fun lift(error_buf: RustBuffer.ByValue): AuthException = FfiConverterTypeAuthError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeAuthError : FfiConverterRustBuffer<AuthException> {
    override fun read(buf: ByteBuffer): AuthException {
        

        return when(buf.getInt()) {
            1 -> AuthException.DatabaseSaveException(
                FfiConverterTypeDatabaseError.read(buf),
                )
            2 -> AuthException.DatabaseGetException(
                FfiConverterTypeDatabaseError.read(buf),
                )
            3 -> AuthException.HashException(
                FfiConverterString.read(buf),
                )
            4 -> AuthException.ParseHashedPinException(
                FfiConverterString.read(buf),
                )
            5 -> AuthException.VerificationFailed(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AuthException): ULong {
        return when(value) {
            is AuthException.DatabaseSaveException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is AuthException.DatabaseGetException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is AuthException.HashException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is AuthException.ParseHashedPinException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is AuthException.VerificationFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AuthException, buf: ByteBuffer) {
        when(value) {
            is AuthException.DatabaseSaveException -> {
                buf.putInt(1)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is AuthException.DatabaseGetException -> {
                buf.putInt(2)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is AuthException.HashException -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is AuthException.ParseHashedPinException -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is AuthException.VerificationFailed -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class AuthManagerAction {
    
    data class UpdateAuthType(
        val v1: AuthType) : AuthManagerAction()
        
    {
        

        companion object
    }
    
    object EnableBiometric : AuthManagerAction()
    
    
    object DisableBiometric : AuthManagerAction()
    
    
    object DisablePin : AuthManagerAction()
    
    
    data class SetPin(
        val v1: kotlin.String) : AuthManagerAction()
        
    {
        

        companion object
    }
    
    object DisableWipeDataPin : AuthManagerAction()
    
    
    object DisableDecoyPin : AuthManagerAction()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAuthManagerAction : FfiConverterRustBuffer<AuthManagerAction>{
    override fun read(buf: ByteBuffer): AuthManagerAction {
        return when(buf.getInt()) {
            1 -> AuthManagerAction.UpdateAuthType(
                FfiConverterTypeAuthType.read(buf),
                )
            2 -> AuthManagerAction.EnableBiometric
            3 -> AuthManagerAction.DisableBiometric
            4 -> AuthManagerAction.DisablePin
            5 -> AuthManagerAction.SetPin(
                FfiConverterString.read(buf),
                )
            6 -> AuthManagerAction.DisableWipeDataPin
            7 -> AuthManagerAction.DisableDecoyPin
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AuthManagerAction) = when(value) {
        is AuthManagerAction.UpdateAuthType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAuthType.allocationSize(value.v1)
            )
        }
        is AuthManagerAction.EnableBiometric -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AuthManagerAction.DisableBiometric -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AuthManagerAction.DisablePin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AuthManagerAction.SetPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is AuthManagerAction.DisableWipeDataPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AuthManagerAction.DisableDecoyPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AuthManagerAction, buf: ByteBuffer) {
        when(value) {
            is AuthManagerAction.UpdateAuthType -> {
                buf.putInt(1)
                FfiConverterTypeAuthType.write(value.v1, buf)
                Unit
            }
            is AuthManagerAction.EnableBiometric -> {
                buf.putInt(2)
                Unit
            }
            is AuthManagerAction.DisableBiometric -> {
                buf.putInt(3)
                Unit
            }
            is AuthManagerAction.DisablePin -> {
                buf.putInt(4)
                Unit
            }
            is AuthManagerAction.SetPin -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is AuthManagerAction.DisableWipeDataPin -> {
                buf.putInt(6)
                Unit
            }
            is AuthManagerAction.DisableDecoyPin -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class AuthManagerException: kotlin.Exception() {
    
    class WipeDataSet(
        
        val v1: TrickPinException
        ) : AuthManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class DecoySet(
        
        val v1: TrickPinException
        ) : AuthManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Database(
        
        val v1: DatabaseException
        ) : AuthManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<AuthManagerException> {
        override fun lift(error_buf: RustBuffer.ByValue): AuthManagerException = FfiConverterTypeAuthManagerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeAuthManagerError : FfiConverterRustBuffer<AuthManagerException> {
    override fun read(buf: ByteBuffer): AuthManagerException {
        

        return when(buf.getInt()) {
            1 -> AuthManagerException.WipeDataSet(
                FfiConverterTypeTrickPinError.read(buf),
                )
            2 -> AuthManagerException.DecoySet(
                FfiConverterTypeTrickPinError.read(buf),
                )
            3 -> AuthManagerException.Database(
                FfiConverterTypeDatabaseError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AuthManagerException): ULong {
        return when(value) {
            is AuthManagerException.WipeDataSet -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeTrickPinError.allocationSize(value.v1)
            )
            is AuthManagerException.DecoySet -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeTrickPinError.allocationSize(value.v1)
            )
            is AuthManagerException.Database -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: AuthManagerException, buf: ByteBuffer) {
        when(value) {
            is AuthManagerException.WipeDataSet -> {
                buf.putInt(1)
                FfiConverterTypeTrickPinError.write(value.v1, buf)
                Unit
            }
            is AuthManagerException.DecoySet -> {
                buf.putInt(2)
                FfiConverterTypeTrickPinError.write(value.v1, buf)
                Unit
            }
            is AuthManagerException.Database -> {
                buf.putInt(3)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class AuthManagerReconcileMessage {
    
    data class AuthTypeChanged(
        val v1: AuthType) : AuthManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    object WipeDataPinChanged : AuthManagerReconcileMessage()
    
    
    object DecoyPinChanged : AuthManagerReconcileMessage()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAuthManagerReconcileMessage : FfiConverterRustBuffer<AuthManagerReconcileMessage>{
    override fun read(buf: ByteBuffer): AuthManagerReconcileMessage {
        return when(buf.getInt()) {
            1 -> AuthManagerReconcileMessage.AuthTypeChanged(
                FfiConverterTypeAuthType.read(buf),
                )
            2 -> AuthManagerReconcileMessage.WipeDataPinChanged
            3 -> AuthManagerReconcileMessage.DecoyPinChanged
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AuthManagerReconcileMessage) = when(value) {
        is AuthManagerReconcileMessage.AuthTypeChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAuthType.allocationSize(value.v1)
            )
        }
        is AuthManagerReconcileMessage.WipeDataPinChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is AuthManagerReconcileMessage.DecoyPinChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: AuthManagerReconcileMessage, buf: ByteBuffer) {
        when(value) {
            is AuthManagerReconcileMessage.AuthTypeChanged -> {
                buf.putInt(1)
                FfiConverterTypeAuthType.write(value.v1, buf)
                Unit
            }
            is AuthManagerReconcileMessage.WipeDataPinChanged -> {
                buf.putInt(2)
                Unit
            }
            is AuthManagerReconcileMessage.DecoyPinChanged -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class AuthType {
    
    PIN,
    BIOMETRIC,
    BOTH,
    NONE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeAuthType: FfiConverterRustBuffer<AuthType> {
    override fun read(buf: ByteBuffer) = try {
        AuthType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AuthType) = 4UL

    override fun write(value: AuthType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class Bip39Exception: kotlin.Exception() {
    
    class BadWordCount(
        
        val v1: kotlin.UInt
        ) : Bip39Exception() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnknownWord(
        
        val v1: kotlin.UInt
        ) : Bip39Exception() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class BadEntropyBitCount(
        
        val v1: kotlin.UInt
        ) : Bip39Exception() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidChecksum(
        ) : Bip39Exception() {
        override val message
            get() = ""
    }
    
    class AmbiguousLanguages(
        ) : Bip39Exception() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<Bip39Exception> {
        override fun lift(error_buf: RustBuffer.ByValue): Bip39Exception = FfiConverterTypeBip39Error.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeBip39Error : FfiConverterRustBuffer<Bip39Exception> {
    override fun read(buf: ByteBuffer): Bip39Exception {
        

        return when(buf.getInt()) {
            1 -> Bip39Exception.BadWordCount(
                FfiConverterUInt.read(buf),
                )
            2 -> Bip39Exception.UnknownWord(
                FfiConverterUInt.read(buf),
                )
            3 -> Bip39Exception.BadEntropyBitCount(
                FfiConverterUInt.read(buf),
                )
            4 -> Bip39Exception.InvalidChecksum()
            5 -> Bip39Exception.AmbiguousLanguages()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Bip39Exception): ULong {
        return when(value) {
            is Bip39Exception.BadWordCount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
            is Bip39Exception.UnknownWord -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
            is Bip39Exception.BadEntropyBitCount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
            is Bip39Exception.InvalidChecksum -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is Bip39Exception.AmbiguousLanguages -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: Bip39Exception, buf: ByteBuffer) {
        when(value) {
            is Bip39Exception.BadWordCount -> {
                buf.putInt(1)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
            is Bip39Exception.UnknownWord -> {
                buf.putInt(2)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
            is Bip39Exception.BadEntropyBitCount -> {
                buf.putInt(3)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
            is Bip39Exception.InvalidChecksum -> {
                buf.putInt(4)
                Unit
            }
            is Bip39Exception.AmbiguousLanguages -> {
                buf.putInt(5)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class BitcoinTransactionException: kotlin.Exception() {
    
    class HexDecodeException(
        
        val v1: kotlin.String
        ) : BitcoinTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ParseTransactionException(
        
        val v1: kotlin.String
        ) : BitcoinTransactionException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<BitcoinTransactionException> {
        override fun lift(error_buf: RustBuffer.ByValue): BitcoinTransactionException = FfiConverterTypeBitcoinTransactionError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeBitcoinTransactionError : FfiConverterRustBuffer<BitcoinTransactionException> {
    override fun read(buf: ByteBuffer): BitcoinTransactionException {
        

        return when(buf.getInt()) {
            1 -> BitcoinTransactionException.HexDecodeException(
                FfiConverterString.read(buf),
                )
            2 -> BitcoinTransactionException.ParseTransactionException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: BitcoinTransactionException): ULong {
        return when(value) {
            is BitcoinTransactionException.HexDecodeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is BitcoinTransactionException.ParseTransactionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: BitcoinTransactionException, buf: ByteBuffer) {
        when(value) {
            is BitcoinTransactionException.HexDecodeException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is BitcoinTransactionException.ParseTransactionException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class ButtonPresentation {
    
    object NotSelected : ButtonPresentation()
    
    
    data class Selected(
        val v1: ListSortDirection) : ButtonPresentation()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeButtonPresentation : FfiConverterRustBuffer<ButtonPresentation>{
    override fun read(buf: ByteBuffer): ButtonPresentation {
        return when(buf.getInt()) {
            1 -> ButtonPresentation.NotSelected
            2 -> ButtonPresentation.Selected(
                FfiConverterTypeListSortDirection.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ButtonPresentation) = when(value) {
        is ButtonPresentation.NotSelected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ButtonPresentation.Selected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeListSortDirection.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ButtonPresentation, buf: ByteBuffer) {
        when(value) {
            is ButtonPresentation.NotSelected -> {
                buf.putInt(1)
                Unit
            }
            is ButtonPresentation.Selected -> {
                buf.putInt(2)
                FfiConverterTypeListSortDirection.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class ByteReaderException: kotlin.Exception() {
    
    class BufferTooSmall(
        ) : ByteReaderException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ByteReaderException> {
        override fun lift(error_buf: RustBuffer.ByValue): ByteReaderException = FfiConverterTypeByteReaderError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeByteReaderError : FfiConverterRustBuffer<ByteReaderException> {
    override fun read(buf: ByteBuffer): ByteReaderException {
        

        return when(buf.getInt()) {
            1 -> ByteReaderException.BufferTooSmall()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ByteReaderException): ULong {
        return when(value) {
            is ByteReaderException.BufferTooSmall -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: ByteReaderException, buf: ByteBuffer) {
        when(value) {
            is ByteReaderException.BufferTooSmall -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class CkTapException: kotlin.Exception() {
    
    class UnluckyNumber(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class BadArguments(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class BadAuth(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class NeedsAuth(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class UnknownCommand(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class InvalidCommand(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class InvalidState(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class WeakNonce(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class BadCbor(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class BackupFirst(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    
    class RateLimited(
        ) : CkTapException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<CkTapException> {
        override fun lift(error_buf: RustBuffer.ByValue): CkTapException = FfiConverterTypeCkTapError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeCkTapError : FfiConverterRustBuffer<CkTapException> {
    override fun read(buf: ByteBuffer): CkTapException {
        

        return when(buf.getInt()) {
            1 -> CkTapException.UnluckyNumber()
            2 -> CkTapException.BadArguments()
            3 -> CkTapException.BadAuth()
            4 -> CkTapException.NeedsAuth()
            5 -> CkTapException.UnknownCommand()
            6 -> CkTapException.InvalidCommand()
            7 -> CkTapException.InvalidState()
            8 -> CkTapException.WeakNonce()
            9 -> CkTapException.BadCbor()
            10 -> CkTapException.BackupFirst()
            11 -> CkTapException.RateLimited()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CkTapException): ULong {
        return when(value) {
            is CkTapException.UnluckyNumber -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.BadArguments -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.BadAuth -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.NeedsAuth -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.UnknownCommand -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.InvalidCommand -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.InvalidState -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.WeakNonce -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.BadCbor -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.BackupFirst -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CkTapException.RateLimited -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: CkTapException, buf: ByteBuffer) {
        when(value) {
            is CkTapException.UnluckyNumber -> {
                buf.putInt(1)
                Unit
            }
            is CkTapException.BadArguments -> {
                buf.putInt(2)
                Unit
            }
            is CkTapException.BadAuth -> {
                buf.putInt(3)
                Unit
            }
            is CkTapException.NeedsAuth -> {
                buf.putInt(4)
                Unit
            }
            is CkTapException.UnknownCommand -> {
                buf.putInt(5)
                Unit
            }
            is CkTapException.InvalidCommand -> {
                buf.putInt(6)
                Unit
            }
            is CkTapException.InvalidState -> {
                buf.putInt(7)
                Unit
            }
            is CkTapException.WeakNonce -> {
                buf.putInt(8)
                Unit
            }
            is CkTapException.BadCbor -> {
                buf.putInt(9)
                Unit
            }
            is CkTapException.BackupFirst -> {
                buf.putInt(10)
                Unit
            }
            is CkTapException.RateLimited -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class CoinControlListSort {
    
    data class Date(
        val v1: ListSortDirection) : CoinControlListSort()
        
    {
        

        companion object
    }
    
    data class Name(
        val v1: ListSortDirection) : CoinControlListSort()
        
    {
        

        companion object
    }
    
    data class Amount(
        val v1: ListSortDirection) : CoinControlListSort()
        
    {
        

        companion object
    }
    
    data class Change(
        val v1: UtxoType) : CoinControlListSort()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCoinControlListSort : FfiConverterRustBuffer<CoinControlListSort>{
    override fun read(buf: ByteBuffer): CoinControlListSort {
        return when(buf.getInt()) {
            1 -> CoinControlListSort.Date(
                FfiConverterTypeListSortDirection.read(buf),
                )
            2 -> CoinControlListSort.Name(
                FfiConverterTypeListSortDirection.read(buf),
                )
            3 -> CoinControlListSort.Amount(
                FfiConverterTypeListSortDirection.read(buf),
                )
            4 -> CoinControlListSort.Change(
                FfiConverterTypeUtxoType.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CoinControlListSort) = when(value) {
        is CoinControlListSort.Date -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeListSortDirection.allocationSize(value.v1)
            )
        }
        is CoinControlListSort.Name -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeListSortDirection.allocationSize(value.v1)
            )
        }
        is CoinControlListSort.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeListSortDirection.allocationSize(value.v1)
            )
        }
        is CoinControlListSort.Change -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUtxoType.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CoinControlListSort, buf: ByteBuffer) {
        when(value) {
            is CoinControlListSort.Date -> {
                buf.putInt(1)
                FfiConverterTypeListSortDirection.write(value.v1, buf)
                Unit
            }
            is CoinControlListSort.Name -> {
                buf.putInt(2)
                FfiConverterTypeListSortDirection.write(value.v1, buf)
                Unit
            }
            is CoinControlListSort.Amount -> {
                buf.putInt(3)
                FfiConverterTypeListSortDirection.write(value.v1, buf)
                Unit
            }
            is CoinControlListSort.Change -> {
                buf.putInt(4)
                FfiConverterTypeUtxoType.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class CoinControlListSortKey {
    
    DATE,
    NAME,
    AMOUNT,
    CHANGE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeCoinControlListSortKey: FfiConverterRustBuffer<CoinControlListSortKey> {
    override fun read(buf: ByteBuffer) = try {
        CoinControlListSortKey.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: CoinControlListSortKey) = 4UL

    override fun write(value: CoinControlListSortKey, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class CoinControlListSortState {
    
    data class Active(
        val v1: CoinControlListSort) : CoinControlListSortState()
        
    {
        

        companion object
    }
    
    data class Inactive(
        val v1: CoinControlListSort) : CoinControlListSortState()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCoinControlListSortState : FfiConverterRustBuffer<CoinControlListSortState>{
    override fun read(buf: ByteBuffer): CoinControlListSortState {
        return when(buf.getInt()) {
            1 -> CoinControlListSortState.Active(
                FfiConverterTypeCoinControlListSort.read(buf),
                )
            2 -> CoinControlListSortState.Inactive(
                FfiConverterTypeCoinControlListSort.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CoinControlListSortState) = when(value) {
        is CoinControlListSortState.Active -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCoinControlListSort.allocationSize(value.v1)
            )
        }
        is CoinControlListSortState.Inactive -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCoinControlListSort.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CoinControlListSortState, buf: ByteBuffer) {
        when(value) {
            is CoinControlListSortState.Active -> {
                buf.putInt(1)
                FfiConverterTypeCoinControlListSort.write(value.v1, buf)
                Unit
            }
            is CoinControlListSortState.Inactive -> {
                buf.putInt(2)
                FfiConverterTypeCoinControlListSort.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CoinControlManagerAction: Disposable  {
    
    data class ChangeSort(
        val v1: CoinControlListSortKey) : CoinControlManagerAction()
        
    {
        

        companion object
    }
    
    object ClearSearch : CoinControlManagerAction()
    
    
    object ToggleSelectAll : CoinControlManagerAction()
    
    
    object ToggleUnit : CoinControlManagerAction()
    
    
    data class NotifySelectedUtxosChanged(
        val v1: List<OutPoint>) : CoinControlManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifySearchChanged(
        val v1: kotlin.String) : CoinControlManagerAction()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is CoinControlManagerAction.ChangeSort -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CoinControlManagerAction.ClearSearch -> {// Nothing to destroy
            }
            is CoinControlManagerAction.ToggleSelectAll -> {// Nothing to destroy
            }
            is CoinControlManagerAction.ToggleUnit -> {// Nothing to destroy
            }
            is CoinControlManagerAction.NotifySelectedUtxosChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CoinControlManagerAction.NotifySearchChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCoinControlManagerAction : FfiConverterRustBuffer<CoinControlManagerAction>{
    override fun read(buf: ByteBuffer): CoinControlManagerAction {
        return when(buf.getInt()) {
            1 -> CoinControlManagerAction.ChangeSort(
                FfiConverterTypeCoinControlListSortKey.read(buf),
                )
            2 -> CoinControlManagerAction.ClearSearch
            3 -> CoinControlManagerAction.ToggleSelectAll
            4 -> CoinControlManagerAction.ToggleUnit
            5 -> CoinControlManagerAction.NotifySelectedUtxosChanged(
                FfiConverterSequenceTypeOutPoint.read(buf),
                )
            6 -> CoinControlManagerAction.NotifySearchChanged(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CoinControlManagerAction) = when(value) {
        is CoinControlManagerAction.ChangeSort -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCoinControlListSortKey.allocationSize(value.v1)
            )
        }
        is CoinControlManagerAction.ClearSearch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CoinControlManagerAction.ToggleSelectAll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CoinControlManagerAction.ToggleUnit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CoinControlManagerAction.NotifySelectedUtxosChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeOutPoint.allocationSize(value.v1)
            )
        }
        is CoinControlManagerAction.NotifySearchChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CoinControlManagerAction, buf: ByteBuffer) {
        when(value) {
            is CoinControlManagerAction.ChangeSort -> {
                buf.putInt(1)
                FfiConverterTypeCoinControlListSortKey.write(value.v1, buf)
                Unit
            }
            is CoinControlManagerAction.ClearSearch -> {
                buf.putInt(2)
                Unit
            }
            is CoinControlManagerAction.ToggleSelectAll -> {
                buf.putInt(3)
                Unit
            }
            is CoinControlManagerAction.ToggleUnit -> {
                buf.putInt(4)
                Unit
            }
            is CoinControlManagerAction.NotifySelectedUtxosChanged -> {
                buf.putInt(5)
                FfiConverterSequenceTypeOutPoint.write(value.v1, buf)
                Unit
            }
            is CoinControlManagerAction.NotifySearchChanged -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CoinControlManagerReconcileMessage: Disposable  {
    
    object ClearSort : CoinControlManagerReconcileMessage()
    
    
    data class UpdateSort(
        val v1: CoinControlListSort) : CoinControlManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateUtxos(
        val v1: List<Utxo>) : CoinControlManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateSearch(
        val v1: kotlin.String) : CoinControlManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateSelectedUtxos(
        val `utxos`: List<OutPoint>, 
        val `totalValue`: Amount) : CoinControlManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateTotalSelectedAmount(
        val v1: Amount) : CoinControlManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateUnit(
        val v1: BitcoinUnit) : CoinControlManagerReconcileMessage()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is CoinControlManagerReconcileMessage.ClearSort -> {// Nothing to destroy
            }
            is CoinControlManagerReconcileMessage.UpdateSort -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CoinControlManagerReconcileMessage.UpdateUtxos -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CoinControlManagerReconcileMessage.UpdateSearch -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CoinControlManagerReconcileMessage.UpdateSelectedUtxos -> {
                
    Disposable.destroy(
        this.`utxos`,
        this.`totalValue`
    )
                
            }
            is CoinControlManagerReconcileMessage.UpdateTotalSelectedAmount -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is CoinControlManagerReconcileMessage.UpdateUnit -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCoinControlManagerReconcileMessage : FfiConverterRustBuffer<CoinControlManagerReconcileMessage>{
    override fun read(buf: ByteBuffer): CoinControlManagerReconcileMessage {
        return when(buf.getInt()) {
            1 -> CoinControlManagerReconcileMessage.ClearSort
            2 -> CoinControlManagerReconcileMessage.UpdateSort(
                FfiConverterTypeCoinControlListSort.read(buf),
                )
            3 -> CoinControlManagerReconcileMessage.UpdateUtxos(
                FfiConverterSequenceTypeUtxo.read(buf),
                )
            4 -> CoinControlManagerReconcileMessage.UpdateSearch(
                FfiConverterString.read(buf),
                )
            5 -> CoinControlManagerReconcileMessage.UpdateSelectedUtxos(
                FfiConverterSequenceTypeOutPoint.read(buf),
                FfiConverterTypeAmount.read(buf),
                )
            6 -> CoinControlManagerReconcileMessage.UpdateTotalSelectedAmount(
                FfiConverterTypeAmount.read(buf),
                )
            7 -> CoinControlManagerReconcileMessage.UpdateUnit(
                FfiConverterTypeBitcoinUnit.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CoinControlManagerReconcileMessage) = when(value) {
        is CoinControlManagerReconcileMessage.ClearSort -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is CoinControlManagerReconcileMessage.UpdateSort -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCoinControlListSort.allocationSize(value.v1)
            )
        }
        is CoinControlManagerReconcileMessage.UpdateUtxos -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeUtxo.allocationSize(value.v1)
            )
        }
        is CoinControlManagerReconcileMessage.UpdateSearch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is CoinControlManagerReconcileMessage.UpdateSelectedUtxos -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeOutPoint.allocationSize(value.`utxos`)
                + FfiConverterTypeAmount.allocationSize(value.`totalValue`)
            )
        }
        is CoinControlManagerReconcileMessage.UpdateTotalSelectedAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAmount.allocationSize(value.v1)
            )
        }
        is CoinControlManagerReconcileMessage.UpdateUnit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBitcoinUnit.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CoinControlManagerReconcileMessage, buf: ByteBuffer) {
        when(value) {
            is CoinControlManagerReconcileMessage.ClearSort -> {
                buf.putInt(1)
                Unit
            }
            is CoinControlManagerReconcileMessage.UpdateSort -> {
                buf.putInt(2)
                FfiConverterTypeCoinControlListSort.write(value.v1, buf)
                Unit
            }
            is CoinControlManagerReconcileMessage.UpdateUtxos -> {
                buf.putInt(3)
                FfiConverterSequenceTypeUtxo.write(value.v1, buf)
                Unit
            }
            is CoinControlManagerReconcileMessage.UpdateSearch -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is CoinControlManagerReconcileMessage.UpdateSelectedUtxos -> {
                buf.putInt(5)
                FfiConverterSequenceTypeOutPoint.write(value.`utxos`, buf)
                FfiConverterTypeAmount.write(value.`totalValue`, buf)
                Unit
            }
            is CoinControlManagerReconcileMessage.UpdateTotalSelectedAmount -> {
                buf.putInt(6)
                FfiConverterTypeAmount.write(value.v1, buf)
                Unit
            }
            is CoinControlManagerReconcileMessage.UpdateUnit -> {
                buf.putInt(7)
                FfiConverterTypeBitcoinUnit.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class CoinControlRoute {
    
    data class List(
        val v1: WalletId) : CoinControlRoute()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCoinControlRoute : FfiConverterRustBuffer<CoinControlRoute>{
    override fun read(buf: ByteBuffer): CoinControlRoute {
        return when(buf.getInt()) {
            1 -> CoinControlRoute.List(
                FfiConverterTypeWalletId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: CoinControlRoute) = when(value) {
        is CoinControlRoute.List -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: CoinControlRoute, buf: ByteBuffer) {
        when(value) {
            is CoinControlRoute.List -> {
                buf.putInt(1)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ColdWalletRoute {
    
    QR_CODE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeColdWalletRoute: FfiConverterRustBuffer<ColdWalletRoute> {
    override fun read(buf: ByteBuffer) = try {
        ColdWalletRoute.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ColdWalletRoute) = 4UL

    override fun write(value: ColdWalletRoute, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class ConverterException: kotlin.Exception() {
    
    class FiatAmountFromStringException(
        
        val v1: kotlin.String
        ) : ConverterException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ConverterException> {
        override fun lift(error_buf: RustBuffer.ByValue): ConverterException = FfiConverterTypeConverterError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeConverterError : FfiConverterRustBuffer<ConverterException> {
    override fun read(buf: ByteBuffer): ConverterException {
        

        return when(buf.getInt()) {
            1 -> ConverterException.FiatAmountFromStringException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConverterException): ULong {
        return when(value) {
            is ConverterException.FiatAmountFromStringException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConverterException, buf: ByteBuffer) {
        when(value) {
            is ConverterException.FiatAmountFromStringException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class DatabaseException: kotlin.Exception() {
    
    class DatabaseAccess(
        
        val v1: kotlin.String
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class TableAccess(
        
        val v1: kotlin.String
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Wallets(
        
        val v1: WalletTableException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GlobalFlag(
        
        val v1: GlobalFlagTableException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GlobalConfig(
        
        val v1: GlobalConfigTableException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GlobalCache(
        
        val v1: GlobalCacheTableException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnsignedTransactions(
        
        val v1: UnsignedTransactionsTableException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class HistoricalPrice(
        
        val v1: HistoricalPriceTableException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Serialization(
        
        val v1: SerdeException
        ) : DatabaseException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<DatabaseException> {
        override fun lift(error_buf: RustBuffer.ByValue): DatabaseException = FfiConverterTypeDatabaseError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeDatabaseError : FfiConverterRustBuffer<DatabaseException> {
    override fun read(buf: ByteBuffer): DatabaseException {
        

        return when(buf.getInt()) {
            1 -> DatabaseException.DatabaseAccess(
                FfiConverterString.read(buf),
                )
            2 -> DatabaseException.TableAccess(
                FfiConverterString.read(buf),
                )
            3 -> DatabaseException.Wallets(
                FfiConverterTypeWalletTableError.read(buf),
                )
            4 -> DatabaseException.GlobalFlag(
                FfiConverterTypeGlobalFlagTableError.read(buf),
                )
            5 -> DatabaseException.GlobalConfig(
                FfiConverterTypeGlobalConfigTableError.read(buf),
                )
            6 -> DatabaseException.GlobalCache(
                FfiConverterTypeGlobalCacheTableError.read(buf),
                )
            7 -> DatabaseException.UnsignedTransactions(
                FfiConverterTypeUnsignedTransactionsTableError.read(buf),
                )
            8 -> DatabaseException.HistoricalPrice(
                FfiConverterTypeHistoricalPriceTableError.read(buf),
                )
            9 -> DatabaseException.Serialization(
                FfiConverterTypeSerdeError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DatabaseException): ULong {
        return when(value) {
            is DatabaseException.DatabaseAccess -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DatabaseException.TableAccess -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DatabaseException.Wallets -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletTableError.allocationSize(value.v1)
            )
            is DatabaseException.GlobalFlag -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeGlobalFlagTableError.allocationSize(value.v1)
            )
            is DatabaseException.GlobalConfig -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeGlobalConfigTableError.allocationSize(value.v1)
            )
            is DatabaseException.GlobalCache -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeGlobalCacheTableError.allocationSize(value.v1)
            )
            is DatabaseException.UnsignedTransactions -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeUnsignedTransactionsTableError.allocationSize(value.v1)
            )
            is DatabaseException.HistoricalPrice -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeHistoricalPriceTableError.allocationSize(value.v1)
            )
            is DatabaseException.Serialization -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSerdeError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DatabaseException, buf: ByteBuffer) {
        when(value) {
            is DatabaseException.DatabaseAccess -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DatabaseException.TableAccess -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DatabaseException.Wallets -> {
                buf.putInt(3)
                FfiConverterTypeWalletTableError.write(value.v1, buf)
                Unit
            }
            is DatabaseException.GlobalFlag -> {
                buf.putInt(4)
                FfiConverterTypeGlobalFlagTableError.write(value.v1, buf)
                Unit
            }
            is DatabaseException.GlobalConfig -> {
                buf.putInt(5)
                FfiConverterTypeGlobalConfigTableError.write(value.v1, buf)
                Unit
            }
            is DatabaseException.GlobalCache -> {
                buf.putInt(6)
                FfiConverterTypeGlobalCacheTableError.write(value.v1, buf)
                Unit
            }
            is DatabaseException.UnsignedTransactions -> {
                buf.putInt(7)
                FfiConverterTypeUnsignedTransactionsTableError.write(value.v1, buf)
                Unit
            }
            is DatabaseException.HistoricalPrice -> {
                buf.putInt(8)
                FfiConverterTypeHistoricalPriceTableError.write(value.v1, buf)
                Unit
            }
            is DatabaseException.Serialization -> {
                buf.putInt(9)
                FfiConverterTypeSerdeError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class DescriptorException: kotlin.Exception() {
    
    class InvalidDescriptor(
        
        val v1: kotlin.String
        ) : DescriptorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MissingKeys(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class TooManyKeys(
        
        val v1: kotlin.UInt
        ) : DescriptorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidDescriptorParse(
        
        val v1: kotlin.String
        ) : DescriptorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MissingDescriptor(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class MissingXpub(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class MissingDerivationPath(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class MissingScriptType(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class MissingFingerprint(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class InvalidXpub(
        
        val v1: kotlin.String
        ) : DescriptorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnableToParseXpub(
        
        val v1: kotlin.String
        ) : DescriptorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NoXpubInDescriptor(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class SinglePubkeyNotSupported(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class MasterXpub(
        ) : DescriptorException() {
        override val message
            get() = ""
    }
    
    class KeyExpressionException(
        
        val v1: kotlin.String
        ) : DescriptorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<DescriptorException> {
        override fun lift(error_buf: RustBuffer.ByValue): DescriptorException = FfiConverterTypeDescriptorError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeDescriptorError : FfiConverterRustBuffer<DescriptorException> {
    override fun read(buf: ByteBuffer): DescriptorException {
        

        return when(buf.getInt()) {
            1 -> DescriptorException.InvalidDescriptor(
                FfiConverterString.read(buf),
                )
            2 -> DescriptorException.MissingKeys()
            3 -> DescriptorException.TooManyKeys(
                FfiConverterUInt.read(buf),
                )
            4 -> DescriptorException.InvalidDescriptorParse(
                FfiConverterString.read(buf),
                )
            5 -> DescriptorException.MissingDescriptor()
            6 -> DescriptorException.MissingXpub()
            7 -> DescriptorException.MissingDerivationPath()
            8 -> DescriptorException.MissingScriptType()
            9 -> DescriptorException.MissingFingerprint()
            10 -> DescriptorException.InvalidXpub(
                FfiConverterString.read(buf),
                )
            11 -> DescriptorException.UnableToParseXpub(
                FfiConverterString.read(buf),
                )
            12 -> DescriptorException.NoXpubInDescriptor()
            13 -> DescriptorException.SinglePubkeyNotSupported()
            14 -> DescriptorException.MasterXpub()
            15 -> DescriptorException.KeyExpressionException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DescriptorException): ULong {
        return when(value) {
            is DescriptorException.InvalidDescriptor -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DescriptorException.MissingKeys -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.TooManyKeys -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
            is DescriptorException.InvalidDescriptorParse -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DescriptorException.MissingDescriptor -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.MissingXpub -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.MissingDerivationPath -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.MissingScriptType -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.MissingFingerprint -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.InvalidXpub -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DescriptorException.UnableToParseXpub -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is DescriptorException.NoXpubInDescriptor -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.SinglePubkeyNotSupported -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.MasterXpub -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is DescriptorException.KeyExpressionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: DescriptorException, buf: ByteBuffer) {
        when(value) {
            is DescriptorException.InvalidDescriptor -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DescriptorException.MissingKeys -> {
                buf.putInt(2)
                Unit
            }
            is DescriptorException.TooManyKeys -> {
                buf.putInt(3)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
            is DescriptorException.InvalidDescriptorParse -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DescriptorException.MissingDescriptor -> {
                buf.putInt(5)
                Unit
            }
            is DescriptorException.MissingXpub -> {
                buf.putInt(6)
                Unit
            }
            is DescriptorException.MissingDerivationPath -> {
                buf.putInt(7)
                Unit
            }
            is DescriptorException.MissingScriptType -> {
                buf.putInt(8)
                Unit
            }
            is DescriptorException.MissingFingerprint -> {
                buf.putInt(9)
                Unit
            }
            is DescriptorException.InvalidXpub -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DescriptorException.UnableToParseXpub -> {
                buf.putInt(11)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is DescriptorException.NoXpubInDescriptor -> {
                buf.putInt(12)
                Unit
            }
            is DescriptorException.SinglePubkeyNotSupported -> {
                buf.putInt(13)
                Unit
            }
            is DescriptorException.MasterXpub -> {
                buf.putInt(14)
                Unit
            }
            is DescriptorException.KeyExpressionException -> {
                buf.putInt(15)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class DiscoveryState: Disposable  {
    
    object Single : DiscoveryState()
    
    
    data class StartedJson(
        val v1: FoundJson) : DiscoveryState()
        
    {
        

        companion object
    }
    
    object StartedMnemonic : DiscoveryState()
    
    
    data class FoundAddressesFromJson(
        val v1: List<FoundAddress>, 
        val v2: FoundJson) : DiscoveryState()
        
    {
        

        companion object
    }
    
    data class FoundAddressesFromMnemonic(
        val v1: List<FoundAddress>) : DiscoveryState()
        
    {
        

        companion object
    }
    
    object NoneFound : DiscoveryState()
    
    
    object ChoseAdressType : DiscoveryState()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is DiscoveryState.Single -> {// Nothing to destroy
            }
            is DiscoveryState.StartedJson -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is DiscoveryState.StartedMnemonic -> {// Nothing to destroy
            }
            is DiscoveryState.FoundAddressesFromJson -> {
                
    Disposable.destroy(
        this.v1,
        this.v2
    )
                
            }
            is DiscoveryState.FoundAddressesFromMnemonic -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is DiscoveryState.NoneFound -> {// Nothing to destroy
            }
            is DiscoveryState.ChoseAdressType -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDiscoveryState : FfiConverterRustBuffer<DiscoveryState>{
    override fun read(buf: ByteBuffer): DiscoveryState {
        return when(buf.getInt()) {
            1 -> DiscoveryState.Single
            2 -> DiscoveryState.StartedJson(
                FfiConverterTypeFoundJson.read(buf),
                )
            3 -> DiscoveryState.StartedMnemonic
            4 -> DiscoveryState.FoundAddressesFromJson(
                FfiConverterSequenceTypeFoundAddress.read(buf),
                FfiConverterTypeFoundJson.read(buf),
                )
            5 -> DiscoveryState.FoundAddressesFromMnemonic(
                FfiConverterSequenceTypeFoundAddress.read(buf),
                )
            6 -> DiscoveryState.NoneFound
            7 -> DiscoveryState.ChoseAdressType
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DiscoveryState) = when(value) {
        is DiscoveryState.Single -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DiscoveryState.StartedJson -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFoundJson.allocationSize(value.v1)
            )
        }
        is DiscoveryState.StartedMnemonic -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DiscoveryState.FoundAddressesFromJson -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeFoundAddress.allocationSize(value.v1)
                + FfiConverterTypeFoundJson.allocationSize(value.v2)
            )
        }
        is DiscoveryState.FoundAddressesFromMnemonic -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeFoundAddress.allocationSize(value.v1)
            )
        }
        is DiscoveryState.NoneFound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is DiscoveryState.ChoseAdressType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: DiscoveryState, buf: ByteBuffer) {
        when(value) {
            is DiscoveryState.Single -> {
                buf.putInt(1)
                Unit
            }
            is DiscoveryState.StartedJson -> {
                buf.putInt(2)
                FfiConverterTypeFoundJson.write(value.v1, buf)
                Unit
            }
            is DiscoveryState.StartedMnemonic -> {
                buf.putInt(3)
                Unit
            }
            is DiscoveryState.FoundAddressesFromJson -> {
                buf.putInt(4)
                FfiConverterSequenceTypeFoundAddress.write(value.v1, buf)
                FfiConverterTypeFoundJson.write(value.v2, buf)
                Unit
            }
            is DiscoveryState.FoundAddressesFromMnemonic -> {
                buf.putInt(5)
                FfiConverterSequenceTypeFoundAddress.write(value.v1, buf)
                Unit
            }
            is DiscoveryState.NoneFound -> {
                buf.putInt(6)
                Unit
            }
            is DiscoveryState.ChoseAdressType -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class FiatAmountException: kotlin.Exception() {
    
    /**
     * Unable to convert to fiat amount, prices client unavailable {0}
     */
    class PricesUnavailable(
        
        val v1: kotlin.String
        ) : FiatAmountException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<FiatAmountException> {
        override fun lift(error_buf: RustBuffer.ByValue): FiatAmountException = FfiConverterTypeFiatAmountError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeFiatAmountError : FfiConverterRustBuffer<FiatAmountException> {
    override fun read(buf: ByteBuffer): FiatAmountException {
        

        return when(buf.getInt()) {
            1 -> FiatAmountException.PricesUnavailable(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FiatAmountException): ULong {
        return when(value) {
            is FiatAmountException.PricesUnavailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: FiatAmountException, buf: ByteBuffer) {
        when(value) {
            is FiatAmountException.PricesUnavailable -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class FiatCurrency {
    
    USD,
    CAD,
    AUD,
    EUR,
    GBP,
    CHF,
    JPY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeFiatCurrency: FfiConverterRustBuffer<FiatCurrency> {
    override fun read(buf: ByteBuffer) = try {
        FiatCurrency.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: FiatCurrency) = 4UL

    override fun write(value: FiatCurrency, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class FiatOrBtc {
    
    BTC,
    FIAT;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeFiatOrBtc: FfiConverterRustBuffer<FiatOrBtc> {
    override fun read(buf: ByteBuffer) = try {
        FiatOrBtc.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: FiatOrBtc) = 4UL

    override fun write(value: FiatOrBtc, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class FileHandlerException: kotlin.Exception() {
    
    class FileNotFound(
        ) : FileHandlerException() {
        override val message
            get() = ""
    }
    
    class OpenFile(
        
        val v1: kotlin.String
        ) : FileHandlerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ReadFile(
        
        val v1: kotlin.String
        ) : FileHandlerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NotRecognizedFormat(
        
        val v1: MultiFormatException
        ) : FileHandlerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<FileHandlerException> {
        override fun lift(error_buf: RustBuffer.ByValue): FileHandlerException = FfiConverterTypeFileHandlerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeFileHandlerError : FfiConverterRustBuffer<FileHandlerException> {
    override fun read(buf: ByteBuffer): FileHandlerException {
        

        return when(buf.getInt()) {
            1 -> FileHandlerException.FileNotFound()
            2 -> FileHandlerException.OpenFile(
                FfiConverterString.read(buf),
                )
            3 -> FileHandlerException.ReadFile(
                FfiConverterString.read(buf),
                )
            4 -> FileHandlerException.NotRecognizedFormat(
                FfiConverterTypeMultiFormatError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FileHandlerException): ULong {
        return when(value) {
            is FileHandlerException.FileNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is FileHandlerException.OpenFile -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is FileHandlerException.ReadFile -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is FileHandlerException.NotRecognizedFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeMultiFormatError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: FileHandlerException, buf: ByteBuffer) {
        when(value) {
            is FileHandlerException.FileNotFound -> {
                buf.putInt(1)
                Unit
            }
            is FileHandlerException.OpenFile -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is FileHandlerException.ReadFile -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is FileHandlerException.NotRecognizedFormat -> {
                buf.putInt(4)
                FfiConverterTypeMultiFormatError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class FingerprintException: kotlin.Exception() {
    
    class WalletNotFound(
        ) : FingerprintException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<FingerprintException> {
        override fun lift(error_buf: RustBuffer.ByValue): FingerprintException = FfiConverterTypeFingerprintError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeFingerprintError : FfiConverterRustBuffer<FingerprintException> {
    override fun read(buf: ByteBuffer): FingerprintException {
        

        return when(buf.getInt()) {
            1 -> FingerprintException.WalletNotFound()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FingerprintException): ULong {
        return when(value) {
            is FingerprintException.WalletNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: FingerprintException, buf: ByteBuffer) {
        when(value) {
            is FingerprintException.WalletNotFound -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class GlobalCacheTableException: kotlin.Exception() {
    
    class Save(
        
        val v1: kotlin.String
        ) : GlobalCacheTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Read(
        
        val v1: kotlin.String
        ) : GlobalCacheTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<GlobalCacheTableException> {
        override fun lift(error_buf: RustBuffer.ByValue): GlobalCacheTableException = FfiConverterTypeGlobalCacheTableError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeGlobalCacheTableError : FfiConverterRustBuffer<GlobalCacheTableException> {
    override fun read(buf: ByteBuffer): GlobalCacheTableException {
        

        return when(buf.getInt()) {
            1 -> GlobalCacheTableException.Save(
                FfiConverterString.read(buf),
                )
            2 -> GlobalCacheTableException.Read(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GlobalCacheTableException): ULong {
        return when(value) {
            is GlobalCacheTableException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is GlobalCacheTableException.Read -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GlobalCacheTableException, buf: ByteBuffer) {
        when(value) {
            is GlobalCacheTableException.Save -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is GlobalCacheTableException.Read -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class GlobalConfigKey {
    
    object SelectedWalletId : GlobalConfigKey()
    
    
    object SelectedNetwork : GlobalConfigKey()
    
    
    object SelectedFiatCurrency : GlobalConfigKey()
    
    
    data class SelectedNode(
        val v1: Network) : GlobalConfigKey()
        
    {
        

        companion object
    }
    
    object ColorScheme : GlobalConfigKey()
    
    
    object AuthType : GlobalConfigKey()
    
    
    object HashedPinCode : GlobalConfigKey()
    
    
    object WipeDataPin : GlobalConfigKey()
    
    
    object DecoyPin : GlobalConfigKey()
    
    
    object InDecoyMode : GlobalConfigKey()
    
    
    object MainSelectedWalletId : GlobalConfigKey()
    
    
    object DecoySelectedWalletId : GlobalConfigKey()
    
    
    object LockedAt : GlobalConfigKey()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeGlobalConfigKey : FfiConverterRustBuffer<GlobalConfigKey>{
    override fun read(buf: ByteBuffer): GlobalConfigKey {
        return when(buf.getInt()) {
            1 -> GlobalConfigKey.SelectedWalletId
            2 -> GlobalConfigKey.SelectedNetwork
            3 -> GlobalConfigKey.SelectedFiatCurrency
            4 -> GlobalConfigKey.SelectedNode(
                FfiConverterTypeNetwork.read(buf),
                )
            5 -> GlobalConfigKey.ColorScheme
            6 -> GlobalConfigKey.AuthType
            7 -> GlobalConfigKey.HashedPinCode
            8 -> GlobalConfigKey.WipeDataPin
            9 -> GlobalConfigKey.DecoyPin
            10 -> GlobalConfigKey.InDecoyMode
            11 -> GlobalConfigKey.MainSelectedWalletId
            12 -> GlobalConfigKey.DecoySelectedWalletId
            13 -> GlobalConfigKey.LockedAt
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GlobalConfigKey) = when(value) {
        is GlobalConfigKey.SelectedWalletId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.SelectedNetwork -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.SelectedFiatCurrency -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.SelectedNode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNetwork.allocationSize(value.v1)
            )
        }
        is GlobalConfigKey.ColorScheme -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.AuthType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.HashedPinCode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.WipeDataPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.DecoyPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.InDecoyMode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.MainSelectedWalletId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.DecoySelectedWalletId -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is GlobalConfigKey.LockedAt -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: GlobalConfigKey, buf: ByteBuffer) {
        when(value) {
            is GlobalConfigKey.SelectedWalletId -> {
                buf.putInt(1)
                Unit
            }
            is GlobalConfigKey.SelectedNetwork -> {
                buf.putInt(2)
                Unit
            }
            is GlobalConfigKey.SelectedFiatCurrency -> {
                buf.putInt(3)
                Unit
            }
            is GlobalConfigKey.SelectedNode -> {
                buf.putInt(4)
                FfiConverterTypeNetwork.write(value.v1, buf)
                Unit
            }
            is GlobalConfigKey.ColorScheme -> {
                buf.putInt(5)
                Unit
            }
            is GlobalConfigKey.AuthType -> {
                buf.putInt(6)
                Unit
            }
            is GlobalConfigKey.HashedPinCode -> {
                buf.putInt(7)
                Unit
            }
            is GlobalConfigKey.WipeDataPin -> {
                buf.putInt(8)
                Unit
            }
            is GlobalConfigKey.DecoyPin -> {
                buf.putInt(9)
                Unit
            }
            is GlobalConfigKey.InDecoyMode -> {
                buf.putInt(10)
                Unit
            }
            is GlobalConfigKey.MainSelectedWalletId -> {
                buf.putInt(11)
                Unit
            }
            is GlobalConfigKey.DecoySelectedWalletId -> {
                buf.putInt(12)
                Unit
            }
            is GlobalConfigKey.LockedAt -> {
                buf.putInt(13)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class GlobalConfigTableException: kotlin.Exception() {
    
    class Save(
        
        val v1: kotlin.String
        ) : GlobalConfigTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Read(
        
        val v1: kotlin.String
        ) : GlobalConfigTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class PinCodeMustBeHashed(
        ) : GlobalConfigTableException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<GlobalConfigTableException> {
        override fun lift(error_buf: RustBuffer.ByValue): GlobalConfigTableException = FfiConverterTypeGlobalConfigTableError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeGlobalConfigTableError : FfiConverterRustBuffer<GlobalConfigTableException> {
    override fun read(buf: ByteBuffer): GlobalConfigTableException {
        

        return when(buf.getInt()) {
            1 -> GlobalConfigTableException.Save(
                FfiConverterString.read(buf),
                )
            2 -> GlobalConfigTableException.Read(
                FfiConverterString.read(buf),
                )
            3 -> GlobalConfigTableException.PinCodeMustBeHashed()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GlobalConfigTableException): ULong {
        return when(value) {
            is GlobalConfigTableException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is GlobalConfigTableException.Read -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is GlobalConfigTableException.PinCodeMustBeHashed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: GlobalConfigTableException, buf: ByteBuffer) {
        when(value) {
            is GlobalConfigTableException.Save -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is GlobalConfigTableException.Read -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is GlobalConfigTableException.PinCodeMustBeHashed -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class GlobalFlagKey {
    
    COMPLETED_ONBOARDING,
    ACCEPTED_TERMS;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeGlobalFlagKey: FfiConverterRustBuffer<GlobalFlagKey> {
    override fun read(buf: ByteBuffer) = try {
        GlobalFlagKey.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: GlobalFlagKey) = 4UL

    override fun write(value: GlobalFlagKey, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class GlobalFlagTableException: kotlin.Exception() {
    
    class Save(
        
        val v1: kotlin.String
        ) : GlobalFlagTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Read(
        
        val v1: kotlin.String
        ) : GlobalFlagTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<GlobalFlagTableException> {
        override fun lift(error_buf: RustBuffer.ByValue): GlobalFlagTableException = FfiConverterTypeGlobalFlagTableError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeGlobalFlagTableError : FfiConverterRustBuffer<GlobalFlagTableException> {
    override fun read(buf: ByteBuffer): GlobalFlagTableException {
        

        return when(buf.getInt()) {
            1 -> GlobalFlagTableException.Save(
                FfiConverterString.read(buf),
                )
            2 -> GlobalFlagTableException.Read(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: GlobalFlagTableException): ULong {
        return when(value) {
            is GlobalFlagTableException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is GlobalFlagTableException.Read -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: GlobalFlagTableException, buf: ByteBuffer) {
        when(value) {
            is GlobalFlagTableException.Save -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is GlobalFlagTableException.Read -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class HardwareWalletMetadata: Disposable  {
    
    data class TapSignerCard(
        val v1: TapSigner) : HardwareWalletMetadata()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is HardwareWalletMetadata.TapSignerCard -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHardwareWalletMetadata : FfiConverterRustBuffer<HardwareWalletMetadata>{
    override fun read(buf: ByteBuffer): HardwareWalletMetadata {
        return when(buf.getInt()) {
            1 -> HardwareWalletMetadata.TapSignerCard(
                FfiConverterTypeTapSigner.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: HardwareWalletMetadata) = when(value) {
        is HardwareWalletMetadata.TapSignerCard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: HardwareWalletMetadata, buf: ByteBuffer) {
        when(value) {
            is HardwareWalletMetadata.TapSignerCard -> {
                buf.putInt(1)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * Error type for HistoricalPriceRecord
 */
sealed class HistoricalPriceRecordException: kotlin.Exception() {
    
    class ConversionException(
        
        val v1: ByteReaderException
        ) : HistoricalPriceRecordException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<HistoricalPriceRecordException> {
        override fun lift(error_buf: RustBuffer.ByValue): HistoricalPriceRecordException = FfiConverterTypeHistoricalPriceRecordError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeHistoricalPriceRecordError : FfiConverterRustBuffer<HistoricalPriceRecordException> {
    override fun read(buf: ByteBuffer): HistoricalPriceRecordException {
        

        return when(buf.getInt()) {
            1 -> HistoricalPriceRecordException.ConversionException(
                FfiConverterTypeByteReaderError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: HistoricalPriceRecordException): ULong {
        return when(value) {
            is HistoricalPriceRecordException.ConversionException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeByteReaderError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: HistoricalPriceRecordException, buf: ByteBuffer) {
        when(value) {
            is HistoricalPriceRecordException.ConversionException -> {
                buf.putInt(1)
                FfiConverterTypeByteReaderError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class HistoricalPriceTableException: kotlin.Exception() {
    
    class Save(
        
        val v1: kotlin.String
        ) : HistoricalPriceTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Read(
        
        val v1: kotlin.String
        ) : HistoricalPriceTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NoRecordFound(
        ) : HistoricalPriceTableException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<HistoricalPriceTableException> {
        override fun lift(error_buf: RustBuffer.ByValue): HistoricalPriceTableException = FfiConverterTypeHistoricalPriceTableError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeHistoricalPriceTableError : FfiConverterRustBuffer<HistoricalPriceTableException> {
    override fun read(buf: ByteBuffer): HistoricalPriceTableException {
        

        return when(buf.getInt()) {
            1 -> HistoricalPriceTableException.Save(
                FfiConverterString.read(buf),
                )
            2 -> HistoricalPriceTableException.Read(
                FfiConverterString.read(buf),
                )
            3 -> HistoricalPriceTableException.NoRecordFound()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: HistoricalPriceTableException): ULong {
        return when(value) {
            is HistoricalPriceTableException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is HistoricalPriceTableException.Read -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is HistoricalPriceTableException.NoRecordFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: HistoricalPriceTableException, buf: ByteBuffer) {
        when(value) {
            is HistoricalPriceTableException.Save -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is HistoricalPriceTableException.Read -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is HistoricalPriceTableException.NoRecordFound -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class HotWalletRoute {
    
    object Select : HotWalletRoute()
    
    
    data class Create(
        val v1: NumberOfBip39Words) : HotWalletRoute()
        
    {
        

        companion object
    }
    
    data class Import(
        val v1: NumberOfBip39Words, 
        val v2: ImportType) : HotWalletRoute()
        
    {
        

        companion object
    }
    
    data class VerifyWords(
        val v1: WalletId) : HotWalletRoute()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeHotWalletRoute : FfiConverterRustBuffer<HotWalletRoute>{
    override fun read(buf: ByteBuffer): HotWalletRoute {
        return when(buf.getInt()) {
            1 -> HotWalletRoute.Select
            2 -> HotWalletRoute.Create(
                FfiConverterTypeNumberOfBip39Words.read(buf),
                )
            3 -> HotWalletRoute.Import(
                FfiConverterTypeNumberOfBip39Words.read(buf),
                FfiConverterTypeImportType.read(buf),
                )
            4 -> HotWalletRoute.VerifyWords(
                FfiConverterTypeWalletId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: HotWalletRoute) = when(value) {
        is HotWalletRoute.Select -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is HotWalletRoute.Create -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNumberOfBip39Words.allocationSize(value.v1)
            )
        }
        is HotWalletRoute.Import -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNumberOfBip39Words.allocationSize(value.v1)
                + FfiConverterTypeImportType.allocationSize(value.v2)
            )
        }
        is HotWalletRoute.VerifyWords -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: HotWalletRoute, buf: ByteBuffer) {
        when(value) {
            is HotWalletRoute.Select -> {
                buf.putInt(1)
                Unit
            }
            is HotWalletRoute.Create -> {
                buf.putInt(2)
                FfiConverterTypeNumberOfBip39Words.write(value.v1, buf)
                Unit
            }
            is HotWalletRoute.Import -> {
                buf.putInt(3)
                FfiConverterTypeNumberOfBip39Words.write(value.v1, buf)
                FfiConverterTypeImportType.write(value.v2, buf)
                Unit
            }
            is HotWalletRoute.VerifyWords -> {
                buf.putInt(4)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ImportType {
    
    MANUAL,
    NFC,
    QR;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeImportType: FfiConverterRustBuffer<ImportType> {
    override fun read(buf: ByteBuffer) = try {
        ImportType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ImportType) = 4UL

    override fun write(value: ImportType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class ImportWalletException: kotlin.Exception() {
    
    class WalletImportException(
        
        val v1: kotlin.String
        ) : ImportWalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidWordGroup(
        
        val v1: kotlin.String
        ) : ImportWalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Keychain(
        
        val v1: KeychainException
        ) : ImportWalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletAlreadyExists(
        
        val v1: WalletId
        ) : ImportWalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Database(
        
        val v1: DatabaseException
        ) : ImportWalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class BdkException(
        
        val v1: kotlin.String
        ) : ImportWalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ImportWalletException> {
        override fun lift(error_buf: RustBuffer.ByValue): ImportWalletException = FfiConverterTypeImportWalletError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeImportWalletError : FfiConverterRustBuffer<ImportWalletException> {
    override fun read(buf: ByteBuffer): ImportWalletException {
        

        return when(buf.getInt()) {
            1 -> ImportWalletException.WalletImportException(
                FfiConverterString.read(buf),
                )
            2 -> ImportWalletException.InvalidWordGroup(
                FfiConverterString.read(buf),
                )
            3 -> ImportWalletException.Keychain(
                FfiConverterTypeKeychainError.read(buf),
                )
            4 -> ImportWalletException.WalletAlreadyExists(
                FfiConverterTypeWalletId.read(buf),
                )
            5 -> ImportWalletException.Database(
                FfiConverterTypeDatabaseError.read(buf),
                )
            6 -> ImportWalletException.BdkException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ImportWalletException): ULong {
        return when(value) {
            is ImportWalletException.WalletImportException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is ImportWalletException.InvalidWordGroup -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is ImportWalletException.Keychain -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeKeychainError.allocationSize(value.v1)
            )
            is ImportWalletException.WalletAlreadyExists -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
            is ImportWalletException.Database -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is ImportWalletException.BdkException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ImportWalletException, buf: ByteBuffer) {
        when(value) {
            is ImportWalletException.WalletImportException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ImportWalletException.InvalidWordGroup -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is ImportWalletException.Keychain -> {
                buf.putInt(3)
                FfiConverterTypeKeychainError.write(value.v1, buf)
                Unit
            }
            is ImportWalletException.WalletAlreadyExists -> {
                buf.putInt(4)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
            is ImportWalletException.Database -> {
                buf.putInt(5)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is ImportWalletException.BdkException -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class ImportWalletManagerAction {
    
    NO_OP;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeImportWalletManagerAction: FfiConverterRustBuffer<ImportWalletManagerAction> {
    override fun read(buf: ByteBuffer) = try {
        ImportWalletManagerAction.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ImportWalletManagerAction) = 4UL

    override fun write(value: ImportWalletManagerAction, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ImportWalletManagerReconcileMessage {
    
    NO_OP;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeImportWalletManagerReconcileMessage: FfiConverterRustBuffer<ImportWalletManagerReconcileMessage> {
    override fun read(buf: ByteBuffer) = try {
        ImportWalletManagerReconcileMessage.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ImportWalletManagerReconcileMessage) = 4UL

    override fun write(value: ImportWalletManagerReconcileMessage, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class InsertOrUpdate {
    
    data class Insert(
        val v1: Timestamp) : InsertOrUpdate()
        
    {
        

        companion object
    }
    
    data class Update(
        val v1: Timestamp) : InsertOrUpdate()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeInsertOrUpdate : FfiConverterRustBuffer<InsertOrUpdate>{
    override fun read(buf: ByteBuffer): InsertOrUpdate {
        return when(buf.getInt()) {
            1 -> InsertOrUpdate.Insert(
                FfiConverterTypeTimestamp.read(buf),
                )
            2 -> InsertOrUpdate.Update(
                FfiConverterTypeTimestamp.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: InsertOrUpdate) = when(value) {
        is InsertOrUpdate.Insert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimestamp.allocationSize(value.v1)
            )
        }
        is InsertOrUpdate.Update -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTimestamp.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: InsertOrUpdate, buf: ByteBuffer) {
        when(value) {
            is InsertOrUpdate.Insert -> {
                buf.putInt(1)
                FfiConverterTypeTimestamp.write(value.v1, buf)
                Unit
            }
            is InsertOrUpdate.Update -> {
                buf.putInt(2)
                FfiConverterTypeTimestamp.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class LabelDbException: kotlin.Exception() {
    
    class Database(
        
        val v1: DatabaseException
        ) : LabelDbException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnsupportedLabelType(
        
        val v1: kotlin.String
        ) : LabelDbException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<LabelDbException> {
        override fun lift(error_buf: RustBuffer.ByValue): LabelDbException = FfiConverterTypeLabelDbError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelDbError : FfiConverterRustBuffer<LabelDbException> {
    override fun read(buf: ByteBuffer): LabelDbException {
        

        return when(buf.getInt()) {
            1 -> LabelDbException.Database(
                FfiConverterTypeDatabaseError.read(buf),
                )
            2 -> LabelDbException.UnsupportedLabelType(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LabelDbException): ULong {
        return when(value) {
            is LabelDbException.Database -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is LabelDbException.UnsupportedLabelType -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LabelDbException, buf: ByteBuffer) {
        when(value) {
            is LabelDbException.Database -> {
                buf.putInt(1)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is LabelDbException.UnsupportedLabelType -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class LabelManagerException: kotlin.Exception() {
    
    class Parse(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Save(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Get(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Export(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetInputRecords(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetOutputRecords(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SaveInputLabels(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SaveOutputLabels(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class DeleteLabels(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SaveAddressLabels(
        
        val v1: kotlin.String
        ) : LabelManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<LabelManagerException> {
        override fun lift(error_buf: RustBuffer.ByValue): LabelManagerException = FfiConverterTypeLabelManagerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeLabelManagerError : FfiConverterRustBuffer<LabelManagerException> {
    override fun read(buf: ByteBuffer): LabelManagerException {
        

        return when(buf.getInt()) {
            1 -> LabelManagerException.Parse(
                FfiConverterString.read(buf),
                )
            2 -> LabelManagerException.Save(
                FfiConverterString.read(buf),
                )
            3 -> LabelManagerException.Get(
                FfiConverterString.read(buf),
                )
            4 -> LabelManagerException.Export(
                FfiConverterString.read(buf),
                )
            5 -> LabelManagerException.GetInputRecords(
                FfiConverterString.read(buf),
                )
            6 -> LabelManagerException.GetOutputRecords(
                FfiConverterString.read(buf),
                )
            7 -> LabelManagerException.SaveInputLabels(
                FfiConverterString.read(buf),
                )
            8 -> LabelManagerException.SaveOutputLabels(
                FfiConverterString.read(buf),
                )
            9 -> LabelManagerException.DeleteLabels(
                FfiConverterString.read(buf),
                )
            10 -> LabelManagerException.SaveAddressLabels(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LabelManagerException): ULong {
        return when(value) {
            is LabelManagerException.Parse -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.Get -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.Export -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.GetInputRecords -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.GetOutputRecords -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.SaveInputLabels -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.SaveOutputLabels -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.DeleteLabels -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is LabelManagerException.SaveAddressLabels -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: LabelManagerException, buf: ByteBuffer) {
        when(value) {
            is LabelManagerException.Parse -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.Save -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.Get -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.Export -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.GetInputRecords -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.GetOutputRecords -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.SaveInputLabels -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.SaveOutputLabels -> {
                buf.putInt(8)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.DeleteLabels -> {
                buf.putInt(9)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is LabelManagerException.SaveAddressLabels -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class ListSortDirection {
    
    ASCENDING,
    DESCENDING;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeListSortDirection: FfiConverterRustBuffer<ListSortDirection> {
    override fun read(buf: ByteBuffer) = try {
        ListSortDirection.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ListSortDirection) = 4UL

    override fun write(value: ListSortDirection, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class MnemonicException: kotlin.Exception() {
    
    class GetWalletKeychain(
        
        val v1: KeychainException
        ) : MnemonicException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NotAvailable(
        
        val v1: WalletId
        ) : MnemonicException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<MnemonicException> {
        override fun lift(error_buf: RustBuffer.ByValue): MnemonicException = FfiConverterTypeMnemonicError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeMnemonicError : FfiConverterRustBuffer<MnemonicException> {
    override fun read(buf: ByteBuffer): MnemonicException {
        

        return when(buf.getInt()) {
            1 -> MnemonicException.GetWalletKeychain(
                FfiConverterTypeKeychainError.read(buf),
                )
            2 -> MnemonicException.NotAvailable(
                FfiConverterTypeWalletId.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MnemonicException): ULong {
        return when(value) {
            is MnemonicException.GetWalletKeychain -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeKeychainError.allocationSize(value.v1)
            )
            is MnemonicException.NotAvailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MnemonicException, buf: ByteBuffer) {
        when(value) {
            is MnemonicException.GetWalletKeychain -> {
                buf.putInt(1)
                FfiConverterTypeKeychainError.write(value.v1, buf)
                Unit
            }
            is MnemonicException.NotAvailable -> {
                buf.putInt(2)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class MnemonicParseException: kotlin.Exception() {
    
    class InvalidMnemonic(
        
        val v1: kotlin.String, 
        
        val v2: kotlin.String
        ) : MnemonicParseException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<MnemonicParseException> {
        override fun lift(error_buf: RustBuffer.ByValue): MnemonicParseException = FfiConverterTypeMnemonicParseError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeMnemonicParseError : FfiConverterRustBuffer<MnemonicParseException> {
    override fun read(buf: ByteBuffer): MnemonicParseException {
        

        return when(buf.getInt()) {
            1 -> MnemonicParseException.InvalidMnemonic(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MnemonicParseException): ULong {
        return when(value) {
            is MnemonicParseException.InvalidMnemonic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
                + FfiConverterString.allocationSize(value.v2)
            )
        }
    }

    override fun write(value: MnemonicParseException, buf: ByteBuffer) {
        when(value) {
            is MnemonicParseException.InvalidMnemonic -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                FfiConverterString.write(value.v2, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class MultiFormat: Disposable  {
    
    data class Address(
        val v1: AddressWithNetwork) : MultiFormat()
        
    {
        

        companion object
    }
    
    data class Hardware(
        val v1: HardwareExport) : MultiFormat()
        
    {
        

        companion object
    }
    
    data class Mnem(
        val v1: Mnemonic) : MultiFormat()
        
    {
        

        companion object
    }
    
    data class Transaction(
        val v1: BitcoinTransaction) : MultiFormat()
        
    {
        

        companion object
    }
    
    data class Labels(
        val v1: Bip329Labels) : MultiFormat()
        
    {
        

        companion object
    }
    
    /**
     * TAPSIGNER has not been initialized yet
     */
    data class TapSignerReady(
        val v1: TapSigner) : MultiFormat()
        
    {
        

        companion object
    }
    
    /**
     * TAPSIGNER has not been initialized yet
     */
    data class TapSignerUnused(
        val v1: TapSigner) : MultiFormat()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MultiFormat.Address -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiFormat.Hardware -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiFormat.Mnem -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiFormat.Transaction -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiFormat.Labels -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiFormat.TapSignerReady -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiFormat.TapSignerUnused -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMultiFormat : FfiConverterRustBuffer<MultiFormat>{
    override fun read(buf: ByteBuffer): MultiFormat {
        return when(buf.getInt()) {
            1 -> MultiFormat.Address(
                FfiConverterTypeAddressWithNetwork.read(buf),
                )
            2 -> MultiFormat.Hardware(
                FfiConverterTypeHardwareExport.read(buf),
                )
            3 -> MultiFormat.Mnem(
                FfiConverterTypeMnemonic.read(buf),
                )
            4 -> MultiFormat.Transaction(
                FfiConverterTypeBitcoinTransaction.read(buf),
                )
            5 -> MultiFormat.Labels(
                FfiConverterTypeBip329Labels.read(buf),
                )
            6 -> MultiFormat.TapSignerReady(
                FfiConverterTypeTapSigner.read(buf),
                )
            7 -> MultiFormat.TapSignerUnused(
                FfiConverterTypeTapSigner.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MultiFormat) = when(value) {
        is MultiFormat.Address -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAddressWithNetwork.allocationSize(value.v1)
            )
        }
        is MultiFormat.Hardware -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeHardwareExport.allocationSize(value.v1)
            )
        }
        is MultiFormat.Mnem -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeMnemonic.allocationSize(value.v1)
            )
        }
        is MultiFormat.Transaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBitcoinTransaction.allocationSize(value.v1)
            )
        }
        is MultiFormat.Labels -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBip329Labels.allocationSize(value.v1)
            )
        }
        is MultiFormat.TapSignerReady -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
            )
        }
        is MultiFormat.TapSignerUnused -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MultiFormat, buf: ByteBuffer) {
        when(value) {
            is MultiFormat.Address -> {
                buf.putInt(1)
                FfiConverterTypeAddressWithNetwork.write(value.v1, buf)
                Unit
            }
            is MultiFormat.Hardware -> {
                buf.putInt(2)
                FfiConverterTypeHardwareExport.write(value.v1, buf)
                Unit
            }
            is MultiFormat.Mnem -> {
                buf.putInt(3)
                FfiConverterTypeMnemonic.write(value.v1, buf)
                Unit
            }
            is MultiFormat.Transaction -> {
                buf.putInt(4)
                FfiConverterTypeBitcoinTransaction.write(value.v1, buf)
                Unit
            }
            is MultiFormat.Labels -> {
                buf.putInt(5)
                FfiConverterTypeBip329Labels.write(value.v1, buf)
                Unit
            }
            is MultiFormat.TapSignerReady -> {
                buf.putInt(6)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                Unit
            }
            is MultiFormat.TapSignerUnused -> {
                buf.putInt(7)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class MultiFormatException: kotlin.Exception() {
    
    class InvalidSeedQr(
        
        val v1: SeedQrException
        ) : MultiFormatException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnsupportedNetworkAddress(
        ) : MultiFormatException() {
        override val message
            get() = ""
    }
    
    class UnrecognizedFormat(
        ) : MultiFormatException() {
        override val message
            get() = ""
    }
    
    class UrFormatNotSupported(
        ) : MultiFormatException() {
        override val message
            get() = ""
    }
    
    class InvalidTapSigner(
        
        val v1: TapCardParseException
        ) : MultiFormatException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<MultiFormatException> {
        override fun lift(error_buf: RustBuffer.ByValue): MultiFormatException = FfiConverterTypeMultiFormatError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeMultiFormatError : FfiConverterRustBuffer<MultiFormatException> {
    override fun read(buf: ByteBuffer): MultiFormatException {
        

        return when(buf.getInt()) {
            1 -> MultiFormatException.InvalidSeedQr(
                FfiConverterTypeSeedQrError.read(buf),
                )
            2 -> MultiFormatException.UnsupportedNetworkAddress()
            3 -> MultiFormatException.UnrecognizedFormat()
            4 -> MultiFormatException.UrFormatNotSupported()
            5 -> MultiFormatException.InvalidTapSigner(
                FfiConverterTypeTapCardParseError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MultiFormatException): ULong {
        return when(value) {
            is MultiFormatException.InvalidSeedQr -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSeedQrError.allocationSize(value.v1)
            )
            is MultiFormatException.UnsupportedNetworkAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiFormatException.UnrecognizedFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiFormatException.UrFormatNotSupported -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiFormatException.InvalidTapSigner -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeTapCardParseError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MultiFormatException, buf: ByteBuffer) {
        when(value) {
            is MultiFormatException.InvalidSeedQr -> {
                buf.putInt(1)
                FfiConverterTypeSeedQrError.write(value.v1, buf)
                Unit
            }
            is MultiFormatException.UnsupportedNetworkAddress -> {
                buf.putInt(2)
                Unit
            }
            is MultiFormatException.UnrecognizedFormat -> {
                buf.putInt(3)
                Unit
            }
            is MultiFormatException.UrFormatNotSupported -> {
                buf.putInt(4)
                Unit
            }
            is MultiFormatException.InvalidTapSigner -> {
                buf.putInt(5)
                FfiConverterTypeTapCardParseError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class MultiQrException: kotlin.Exception() {
    
    class CannotAddPartToSingleQr(
        ) : MultiQrException() {
        override val message
            get() = ""
    }
    
    class CannotAddPartToSeedQr(
        ) : MultiQrException() {
        override val message
            get() = ""
    }
    
    class ParseException(
        
        val v1: kotlin.String
        ) : MultiQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidUtf8(
        ) : MultiQrException() {
        override val message
            get() = ""
    }
    
    class NotYetAvailable(
        ) : MultiQrException() {
        override val message
            get() = ""
    }
    
    class CannotAddBinaryDataToBbqr(
        ) : MultiQrException() {
        override val message
            get() = ""
    }
    
    class BbqrDidNotContainSeedWords(
        
        val v1: kotlin.String
        ) : MultiQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidSeedQr(
        
        val v1: SeedQrException
        ) : MultiQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidPlainTextQr(
        
        val v1: kotlin.String
        ) : MultiQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<MultiQrException> {
        override fun lift(error_buf: RustBuffer.ByValue): MultiQrException = FfiConverterTypeMultiQrError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeMultiQrError : FfiConverterRustBuffer<MultiQrException> {
    override fun read(buf: ByteBuffer): MultiQrException {
        

        return when(buf.getInt()) {
            1 -> MultiQrException.CannotAddPartToSingleQr()
            2 -> MultiQrException.CannotAddPartToSeedQr()
            3 -> MultiQrException.ParseException(
                FfiConverterString.read(buf),
                )
            4 -> MultiQrException.InvalidUtf8()
            5 -> MultiQrException.NotYetAvailable()
            6 -> MultiQrException.CannotAddBinaryDataToBbqr()
            7 -> MultiQrException.BbqrDidNotContainSeedWords(
                FfiConverterString.read(buf),
                )
            8 -> MultiQrException.InvalidSeedQr(
                FfiConverterTypeSeedQrError.read(buf),
                )
            9 -> MultiQrException.InvalidPlainTextQr(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MultiQrException): ULong {
        return when(value) {
            is MultiQrException.CannotAddPartToSingleQr -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiQrException.CannotAddPartToSeedQr -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiQrException.ParseException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is MultiQrException.InvalidUtf8 -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiQrException.NotYetAvailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiQrException.CannotAddBinaryDataToBbqr -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is MultiQrException.BbqrDidNotContainSeedWords -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is MultiQrException.InvalidSeedQr -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeSeedQrError.allocationSize(value.v1)
            )
            is MultiQrException.InvalidPlainTextQr -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MultiQrException, buf: ByteBuffer) {
        when(value) {
            is MultiQrException.CannotAddPartToSingleQr -> {
                buf.putInt(1)
                Unit
            }
            is MultiQrException.CannotAddPartToSeedQr -> {
                buf.putInt(2)
                Unit
            }
            is MultiQrException.ParseException -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MultiQrException.InvalidUtf8 -> {
                buf.putInt(4)
                Unit
            }
            is MultiQrException.NotYetAvailable -> {
                buf.putInt(5)
                Unit
            }
            is MultiQrException.CannotAddBinaryDataToBbqr -> {
                buf.putInt(6)
                Unit
            }
            is MultiQrException.BbqrDidNotContainSeedWords -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MultiQrException.InvalidSeedQr -> {
                buf.putInt(8)
                FfiConverterTypeSeedQrError.write(value.v1, buf)
                Unit
            }
            is MultiQrException.InvalidPlainTextQr -> {
                buf.putInt(9)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class MultiQrScanResult: Disposable  {
    
    data class Seed(
        val v1: SeedQr) : MultiQrScanResult()
        
    {
        

        companion object
    }
    
    data class Single(
        val v1: kotlin.String) : MultiQrScanResult()
        
    {
        

        companion object
    }
    
    data class CompletedBBqr(
        val v1: BbqrJoined) : MultiQrScanResult()
        
    {
        

        companion object
    }
    
    data class InProgressBBqr(
        val v1: kotlin.UInt) : MultiQrScanResult()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MultiQrScanResult.Seed -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiQrScanResult.Single -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiQrScanResult.CompletedBBqr -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is MultiQrScanResult.InProgressBBqr -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMultiQrScanResult : FfiConverterRustBuffer<MultiQrScanResult>{
    override fun read(buf: ByteBuffer): MultiQrScanResult {
        return when(buf.getInt()) {
            1 -> MultiQrScanResult.Seed(
                FfiConverterTypeSeedQr.read(buf),
                )
            2 -> MultiQrScanResult.Single(
                FfiConverterString.read(buf),
                )
            3 -> MultiQrScanResult.CompletedBBqr(
                FfiConverterTypeBbqrJoined.read(buf),
                )
            4 -> MultiQrScanResult.InProgressBBqr(
                FfiConverterUInt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MultiQrScanResult) = when(value) {
        is MultiQrScanResult.Seed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSeedQr.allocationSize(value.v1)
            )
        }
        is MultiQrScanResult.Single -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is MultiQrScanResult.CompletedBBqr -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBbqrJoined.allocationSize(value.v1)
            )
        }
        is MultiQrScanResult.InProgressBBqr -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: MultiQrScanResult, buf: ByteBuffer) {
        when(value) {
            is MultiQrScanResult.Seed -> {
                buf.putInt(1)
                FfiConverterTypeSeedQr.write(value.v1, buf)
                Unit
            }
            is MultiQrScanResult.Single -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is MultiQrScanResult.CompletedBBqr -> {
                buf.putInt(3)
                FfiConverterTypeBbqrJoined.write(value.v1, buf)
                Unit
            }
            is MultiQrScanResult.InProgressBBqr -> {
                buf.putInt(4)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NewWalletRoute {
    
    object Select : NewWalletRoute()
    
    
    data class HotWallet(
        val v1: HotWalletRoute) : NewWalletRoute()
        
    {
        

        companion object
    }
    
    data class ColdWallet(
        val v1: ColdWalletRoute) : NewWalletRoute()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNewWalletRoute : FfiConverterRustBuffer<NewWalletRoute>{
    override fun read(buf: ByteBuffer): NewWalletRoute {
        return when(buf.getInt()) {
            1 -> NewWalletRoute.Select
            2 -> NewWalletRoute.HotWallet(
                FfiConverterTypeHotWalletRoute.read(buf),
                )
            3 -> NewWalletRoute.ColdWallet(
                FfiConverterTypeColdWalletRoute.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NewWalletRoute) = when(value) {
        is NewWalletRoute.Select -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is NewWalletRoute.HotWallet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeHotWalletRoute.allocationSize(value.v1)
            )
        }
        is NewWalletRoute.ColdWallet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeColdWalletRoute.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NewWalletRoute, buf: ByteBuffer) {
        when(value) {
            is NewWalletRoute.Select -> {
                buf.putInt(1)
                Unit
            }
            is NewWalletRoute.HotWallet -> {
                buf.putInt(2)
                FfiConverterTypeHotWalletRoute.write(value.v1, buf)
                Unit
            }
            is NewWalletRoute.ColdWallet -> {
                buf.putInt(3)
                FfiConverterTypeColdWalletRoute.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class NodeSelection {
    
    data class Preset(
        val v1: Node) : NodeSelection()
        
    {
        

        companion object
    }
    
    data class Custom(
        val v1: Node) : NodeSelection()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNodeSelection : FfiConverterRustBuffer<NodeSelection>{
    override fun read(buf: ByteBuffer): NodeSelection {
        return when(buf.getInt()) {
            1 -> NodeSelection.Preset(
                FfiConverterTypeNode.read(buf),
                )
            2 -> NodeSelection.Custom(
                FfiConverterTypeNode.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NodeSelection) = when(value) {
        is NodeSelection.Preset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNode.allocationSize(value.v1)
            )
        }
        is NodeSelection.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNode.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NodeSelection, buf: ByteBuffer) {
        when(value) {
            is NodeSelection.Preset -> {
                buf.putInt(1)
                FfiConverterTypeNode.write(value.v1, buf)
                Unit
            }
            is NodeSelection.Custom -> {
                buf.putInt(2)
                FfiConverterTypeNode.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class NodeSelectorException: kotlin.Exception() {
    
    class NodeNotFound(
        
        val v1: kotlin.String
        ) : NodeSelectorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SetSelectedNodeException(
        
        val v1: kotlin.String
        ) : NodeSelectorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NodeAccessException(
        
        val v1: kotlin.String
        ) : NodeSelectorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ParseNodeUrlException(
        
        val v1: kotlin.String
        ) : NodeSelectorException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<NodeSelectorException> {
        override fun lift(error_buf: RustBuffer.ByValue): NodeSelectorException = FfiConverterTypeNodeSelectorError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeNodeSelectorError : FfiConverterRustBuffer<NodeSelectorException> {
    override fun read(buf: ByteBuffer): NodeSelectorException {
        

        return when(buf.getInt()) {
            1 -> NodeSelectorException.NodeNotFound(
                FfiConverterString.read(buf),
                )
            2 -> NodeSelectorException.SetSelectedNodeException(
                FfiConverterString.read(buf),
                )
            3 -> NodeSelectorException.NodeAccessException(
                FfiConverterString.read(buf),
                )
            4 -> NodeSelectorException.ParseNodeUrlException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NodeSelectorException): ULong {
        return when(value) {
            is NodeSelectorException.NodeNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is NodeSelectorException.SetSelectedNodeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is NodeSelectorException.NodeAccessException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is NodeSelectorException.ParseNodeUrlException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: NodeSelectorException, buf: ByteBuffer) {
        when(value) {
            is NodeSelectorException.NodeNotFound -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is NodeSelectorException.SetSelectedNodeException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is NodeSelectorException.NodeAccessException -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is NodeSelectorException.ParseNodeUrlException -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class NumberOfBip39Words {
    
    TWELVE,
    TWENTY_FOUR;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNumberOfBip39Words: FfiConverterRustBuffer<NumberOfBip39Words> {
    override fun read(buf: ByteBuffer) = try {
        NumberOfBip39Words.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: NumberOfBip39Words) = 4UL

    override fun write(value: NumberOfBip39Words, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class PendingOrConfirmed {
    
    data class Pending(
        val v1: PendingDetails) : PendingOrConfirmed()
        
    {
        

        companion object
    }
    
    data class Confirmed(
        val v1: ConfirmedDetails) : PendingOrConfirmed()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePendingOrConfirmed : FfiConverterRustBuffer<PendingOrConfirmed>{
    override fun read(buf: ByteBuffer): PendingOrConfirmed {
        return when(buf.getInt()) {
            1 -> PendingOrConfirmed.Pending(
                FfiConverterTypePendingDetails.read(buf),
                )
            2 -> PendingOrConfirmed.Confirmed(
                FfiConverterTypeConfirmedDetails.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PendingOrConfirmed) = when(value) {
        is PendingOrConfirmed.Pending -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePendingDetails.allocationSize(value.v1)
            )
        }
        is PendingOrConfirmed.Confirmed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConfirmedDetails.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PendingOrConfirmed, buf: ByteBuffer) {
        when(value) {
            is PendingOrConfirmed.Pending -> {
                buf.putInt(1)
                FfiConverterTypePendingDetails.write(value.v1, buf)
                Unit
            }
            is PendingOrConfirmed.Confirmed -> {
                buf.putInt(2)
                FfiConverterTypeConfirmedDetails.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class PendingWalletManagerAction {
    
    data class UpdateWords(
        val v1: NumberOfBip39Words) : PendingWalletManagerAction()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePendingWalletManagerAction : FfiConverterRustBuffer<PendingWalletManagerAction>{
    override fun read(buf: ByteBuffer): PendingWalletManagerAction {
        return when(buf.getInt()) {
            1 -> PendingWalletManagerAction.UpdateWords(
                FfiConverterTypeNumberOfBip39Words.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PendingWalletManagerAction) = when(value) {
        is PendingWalletManagerAction.UpdateWords -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNumberOfBip39Words.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PendingWalletManagerAction, buf: ByteBuffer) {
        when(value) {
            is PendingWalletManagerAction.UpdateWords -> {
                buf.putInt(1)
                FfiConverterTypeNumberOfBip39Words.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class PendingWalletManagerException: kotlin.Exception() {
    
    class BdkException(
        
        val v1: kotlin.String
        ) : PendingWalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Creation(
        
        val v1: WalletCreationException
        ) : PendingWalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PendingWalletManagerException> {
        override fun lift(error_buf: RustBuffer.ByValue): PendingWalletManagerException = FfiConverterTypePendingWalletManagerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePendingWalletManagerError : FfiConverterRustBuffer<PendingWalletManagerException> {
    override fun read(buf: ByteBuffer): PendingWalletManagerException {
        

        return when(buf.getInt()) {
            1 -> PendingWalletManagerException.BdkException(
                FfiConverterString.read(buf),
                )
            2 -> PendingWalletManagerException.Creation(
                FfiConverterTypeWalletCreationError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PendingWalletManagerException): ULong {
        return when(value) {
            is PendingWalletManagerException.BdkException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is PendingWalletManagerException.Creation -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletCreationError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PendingWalletManagerException, buf: ByteBuffer) {
        when(value) {
            is PendingWalletManagerException.BdkException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is PendingWalletManagerException.Creation -> {
                buf.putInt(2)
                FfiConverterTypeWalletCreationError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class PendingWalletManagerReconcileMessage {
    
    data class Words(
        val v1: NumberOfBip39Words) : PendingWalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePendingWalletManagerReconcileMessage : FfiConverterRustBuffer<PendingWalletManagerReconcileMessage>{
    override fun read(buf: ByteBuffer): PendingWalletManagerReconcileMessage {
        return when(buf.getInt()) {
            1 -> PendingWalletManagerReconcileMessage.Words(
                FfiConverterTypeNumberOfBip39Words.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PendingWalletManagerReconcileMessage) = when(value) {
        is PendingWalletManagerReconcileMessage.Words -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNumberOfBip39Words.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PendingWalletManagerReconcileMessage, buf: ByteBuffer) {
        when(value) {
            is PendingWalletManagerReconcileMessage.Words -> {
                buf.putInt(1)
                FfiConverterTypeNumberOfBip39Words.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class Route: Disposable  {
    
    data class LoadAndReset(
        val `resetTo`: List<BoxedRoute>, 
        val `afterMillis`: kotlin.UInt) : Route()
        
    {
        

        companion object
    }
    
    object ListWallets : Route()
    
    
    data class SelectedWallet(
        val v1: WalletId) : Route()
        
    {
        

        companion object
    }
    
    data class NewWallet(
        val v1: NewWalletRoute) : Route()
        
    {
        

        companion object
    }
    
    data class Settings(
        val v1: SettingsRoute) : Route()
        
    {
        

        companion object
    }
    
    data class SecretWords(
        val v1: WalletId) : Route()
        
    {
        

        companion object
    }
    
    data class TxDetails(
        val `id`: WalletId, 
        val `details`: TransactionDetails) : Route()
        
    {
        

        companion object
    }
    
    data class Send(
        val v1: SendRoute) : Route()
        
    {
        

        companion object
    }
    
    data class CoinControl(
        val v1: CoinControlRoute) : Route()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is Route.LoadAndReset -> {
                
    Disposable.destroy(
        this.`resetTo`,
        this.`afterMillis`
    )
                
            }
            is Route.ListWallets -> {// Nothing to destroy
            }
            is Route.SelectedWallet -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is Route.NewWallet -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is Route.Settings -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is Route.SecretWords -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is Route.TxDetails -> {
                
    Disposable.destroy(
        this.`id`,
        this.`details`
    )
                
            }
            is Route.Send -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is Route.CoinControl -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRoute : FfiConverterRustBuffer<Route>{
    override fun read(buf: ByteBuffer): Route {
        return when(buf.getInt()) {
            1 -> Route.LoadAndReset(
                FfiConverterSequenceTypeBoxedRoute.read(buf),
                FfiConverterUInt.read(buf),
                )
            2 -> Route.ListWallets
            3 -> Route.SelectedWallet(
                FfiConverterTypeWalletId.read(buf),
                )
            4 -> Route.NewWallet(
                FfiConverterTypeNewWalletRoute.read(buf),
                )
            5 -> Route.Settings(
                FfiConverterTypeSettingsRoute.read(buf),
                )
            6 -> Route.SecretWords(
                FfiConverterTypeWalletId.read(buf),
                )
            7 -> Route.TxDetails(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterTypeTransactionDetails.read(buf),
                )
            8 -> Route.Send(
                FfiConverterTypeSendRoute.read(buf),
                )
            9 -> Route.CoinControl(
                FfiConverterTypeCoinControlRoute.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Route) = when(value) {
        is Route.LoadAndReset -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeBoxedRoute.allocationSize(value.`resetTo`)
                + FfiConverterUInt.allocationSize(value.`afterMillis`)
            )
        }
        is Route.ListWallets -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is Route.SelectedWallet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
        }
        is Route.NewWallet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeNewWalletRoute.allocationSize(value.v1)
            )
        }
        is Route.Settings -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSettingsRoute.allocationSize(value.v1)
            )
        }
        is Route.SecretWords -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
        }
        is Route.TxDetails -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterTypeTransactionDetails.allocationSize(value.`details`)
            )
        }
        is Route.Send -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSendRoute.allocationSize(value.v1)
            )
        }
        is Route.CoinControl -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeCoinControlRoute.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: Route, buf: ByteBuffer) {
        when(value) {
            is Route.LoadAndReset -> {
                buf.putInt(1)
                FfiConverterSequenceTypeBoxedRoute.write(value.`resetTo`, buf)
                FfiConverterUInt.write(value.`afterMillis`, buf)
                Unit
            }
            is Route.ListWallets -> {
                buf.putInt(2)
                Unit
            }
            is Route.SelectedWallet -> {
                buf.putInt(3)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
            is Route.NewWallet -> {
                buf.putInt(4)
                FfiConverterTypeNewWalletRoute.write(value.v1, buf)
                Unit
            }
            is Route.Settings -> {
                buf.putInt(5)
                FfiConverterTypeSettingsRoute.write(value.v1, buf)
                Unit
            }
            is Route.SecretWords -> {
                buf.putInt(6)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
            is Route.TxDetails -> {
                buf.putInt(7)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterTypeTransactionDetails.write(value.`details`, buf)
                Unit
            }
            is Route.Send -> {
                buf.putInt(8)
                FfiConverterTypeSendRoute.write(value.v1, buf)
                Unit
            }
            is Route.CoinControl -> {
                buf.putInt(9)
                FfiConverterTypeCoinControlRoute.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ScanState {
    
    object NotStarted : ScanState()
    
    
    data class Scanning(
        val v1: ScanningInfo) : ScanState()
        
    {
        

        companion object
    }
    
    object Completed : ScanState()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScanState : FfiConverterRustBuffer<ScanState>{
    override fun read(buf: ByteBuffer): ScanState {
        return when(buf.getInt()) {
            1 -> ScanState.NotStarted
            2 -> ScanState.Scanning(
                FfiConverterTypeScanningInfo.read(buf),
                )
            3 -> ScanState.Completed
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ScanState) = when(value) {
        is ScanState.NotStarted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is ScanState.Scanning -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeScanningInfo.allocationSize(value.v1)
            )
        }
        is ScanState.Completed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ScanState, buf: ByteBuffer) {
        when(value) {
            is ScanState.NotStarted -> {
                buf.putInt(1)
                Unit
            }
            is ScanState.Scanning -> {
                buf.putInt(2)
                FfiConverterTypeScanningInfo.write(value.v1, buf)
                Unit
            }
            is ScanState.Completed -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class ScannerResponse {
    
    data class FoundAddresses(
        val v1: List<FoundAddress>) : ScannerResponse()
        
    {
        

        companion object
    }
    
    object NoneFound : ScannerResponse()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeScannerResponse : FfiConverterRustBuffer<ScannerResponse>{
    override fun read(buf: ByteBuffer): ScannerResponse {
        return when(buf.getInt()) {
            1 -> ScannerResponse.FoundAddresses(
                FfiConverterSequenceTypeFoundAddress.read(buf),
                )
            2 -> ScannerResponse.NoneFound
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ScannerResponse) = when(value) {
        is ScannerResponse.FoundAddresses -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeFoundAddress.allocationSize(value.v1)
            )
        }
        is ScannerResponse.NoneFound -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: ScannerResponse, buf: ByteBuffer) {
        when(value) {
            is ScannerResponse.FoundAddresses -> {
                buf.putInt(1)
                FfiConverterSequenceTypeFoundAddress.write(value.v1, buf)
                Unit
            }
            is ScannerResponse.NoneFound -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SeedQrException: kotlin.Exception() {
    
    class ContainsNonNumericChars(
        ) : SeedQrException() {
        override val message
            get() = ""
    }
    
    class IndexOutOfBounds(
        
        val v1: kotlin.UShort
        ) : SeedQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class IncorrectWordLength(
        
        val v1: kotlin.UShort
        ) : SeedQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidMnemonic(
        
        val v1: Bip39Exception
        ) : SeedQrException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SeedQrException> {
        override fun lift(error_buf: RustBuffer.ByValue): SeedQrException = FfiConverterTypeSeedQrError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSeedQrError : FfiConverterRustBuffer<SeedQrException> {
    override fun read(buf: ByteBuffer): SeedQrException {
        

        return when(buf.getInt()) {
            1 -> SeedQrException.ContainsNonNumericChars()
            2 -> SeedQrException.IndexOutOfBounds(
                FfiConverterUShort.read(buf),
                )
            3 -> SeedQrException.IncorrectWordLength(
                FfiConverterUShort.read(buf),
                )
            4 -> SeedQrException.InvalidMnemonic(
                FfiConverterTypeBip39Error.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SeedQrException): ULong {
        return when(value) {
            is SeedQrException.ContainsNonNumericChars -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SeedQrException.IndexOutOfBounds -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUShort.allocationSize(value.v1)
            )
            is SeedQrException.IncorrectWordLength -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUShort.allocationSize(value.v1)
            )
            is SeedQrException.InvalidMnemonic -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeBip39Error.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SeedQrException, buf: ByteBuffer) {
        when(value) {
            is SeedQrException.ContainsNonNumericChars -> {
                buf.putInt(1)
                Unit
            }
            is SeedQrException.IndexOutOfBounds -> {
                buf.putInt(2)
                FfiConverterUShort.write(value.v1, buf)
                Unit
            }
            is SeedQrException.IncorrectWordLength -> {
                buf.putInt(3)
                FfiConverterUShort.write(value.v1, buf)
                Unit
            }
            is SeedQrException.InvalidMnemonic -> {
                buf.putInt(4)
                FfiConverterTypeBip39Error.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SendFlowAlertState {
    
    data class Error(
        val v1: SendFlowException) : SendFlowAlertState()
        
    {
        

        companion object
    }
    
    data class General(
        val `title`: kotlin.String, 
        val `message`: kotlin.String) : SendFlowAlertState()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowAlertState : FfiConverterRustBuffer<SendFlowAlertState>{
    override fun read(buf: ByteBuffer): SendFlowAlertState {
        return when(buf.getInt()) {
            1 -> SendFlowAlertState.Error(
                FfiConverterTypeSendFlowError.read(buf),
                )
            2 -> SendFlowAlertState.General(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowAlertState) = when(value) {
        is SendFlowAlertState.Error -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSendFlowError.allocationSize(value.v1)
            )
        }
        is SendFlowAlertState.General -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`title`)
                + FfiConverterString.allocationSize(value.`message`)
            )
        }
    }

    override fun write(value: SendFlowAlertState, buf: ByteBuffer) {
        when(value) {
            is SendFlowAlertState.Error -> {
                buf.putInt(1)
                FfiConverterTypeSendFlowError.write(value.v1, buf)
                Unit
            }
            is SendFlowAlertState.General -> {
                buf.putInt(2)
                FfiConverterString.write(value.`title`, buf)
                FfiConverterString.write(value.`message`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SendFlowEnterMode: Disposable  {
    
    object SetAmount : SendFlowEnterMode()
    
    
    data class CoinControl(
        val v1: SendFlowCoinControlMode) : SendFlowEnterMode()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SendFlowEnterMode.SetAmount -> {// Nothing to destroy
            }
            is SendFlowEnterMode.CoinControl -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowEnterMode : FfiConverterRustBuffer<SendFlowEnterMode>{
    override fun read(buf: ByteBuffer): SendFlowEnterMode {
        return when(buf.getInt()) {
            1 -> SendFlowEnterMode.SetAmount
            2 -> SendFlowEnterMode.CoinControl(
                FfiConverterTypeSendFlowCoinControlMode.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowEnterMode) = when(value) {
        is SendFlowEnterMode.SetAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowEnterMode.CoinControl -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSendFlowCoinControlMode.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SendFlowEnterMode, buf: ByteBuffer) {
        when(value) {
            is SendFlowEnterMode.SetAmount -> {
                buf.putInt(1)
                Unit
            }
            is SendFlowEnterMode.CoinControl -> {
                buf.putInt(2)
                FfiConverterTypeSendFlowCoinControlMode.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SendFlowException: kotlin.Exception() {
    
    class EmptyAddress(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class InvalidNumber(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class InvalidAddress(
        
        val v1: kotlin.String
        ) : SendFlowException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WrongNetwork(
        
        val `address`: kotlin.String, 
        
        val `validFor`: Network, 
        
        val `current`: Network
        ) : SendFlowException() {
        override val message
            get() = "address=${ `address` }, validFor=${ `validFor` }, current=${ `current` }"
    }
    
    class NoBalance(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class ZeroAmount(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class UnableToGetMaxSend(
        
        val v1: kotlin.String
        ) : SendFlowException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InsufficientFunds(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class SendAmountToLow(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class UnableToGetFeeRate(
        ) : SendFlowException() {
        override val message
            get() = ""
    }
    
    class UnableToBuildTxn(
        
        val v1: kotlin.String
        ) : SendFlowException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnableToSaveUnsignedTransaction(
        
        val v1: kotlin.String
        ) : SendFlowException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletManager(
        
        val v1: WalletManagerException
        ) : SendFlowException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnableToGetFeeDetails(
        
        val v1: kotlin.String
        ) : SendFlowException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SendFlowException> {
        override fun lift(error_buf: RustBuffer.ByValue): SendFlowException = FfiConverterTypeSendFlowError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowError : FfiConverterRustBuffer<SendFlowException> {
    override fun read(buf: ByteBuffer): SendFlowException {
        

        return when(buf.getInt()) {
            1 -> SendFlowException.EmptyAddress()
            2 -> SendFlowException.InvalidNumber()
            3 -> SendFlowException.InvalidAddress(
                FfiConverterString.read(buf),
                )
            4 -> SendFlowException.WrongNetwork(
                FfiConverterString.read(buf),
                FfiConverterTypeNetwork.read(buf),
                FfiConverterTypeNetwork.read(buf),
                )
            5 -> SendFlowException.NoBalance()
            6 -> SendFlowException.ZeroAmount()
            7 -> SendFlowException.UnableToGetMaxSend(
                FfiConverterString.read(buf),
                )
            8 -> SendFlowException.InsufficientFunds()
            9 -> SendFlowException.SendAmountToLow()
            10 -> SendFlowException.UnableToGetFeeRate()
            11 -> SendFlowException.UnableToBuildTxn(
                FfiConverterString.read(buf),
                )
            12 -> SendFlowException.UnableToSaveUnsignedTransaction(
                FfiConverterString.read(buf),
                )
            13 -> SendFlowException.WalletManager(
                FfiConverterTypeWalletManagerError.read(buf),
                )
            14 -> SendFlowException.UnableToGetFeeDetails(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowException): ULong {
        return when(value) {
            is SendFlowException.EmptyAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.InvalidNumber -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.InvalidAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SendFlowException.WrongNetwork -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.`address`)
                + FfiConverterTypeNetwork.allocationSize(value.`validFor`)
                + FfiConverterTypeNetwork.allocationSize(value.`current`)
            )
            is SendFlowException.NoBalance -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.ZeroAmount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.UnableToGetMaxSend -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SendFlowException.InsufficientFunds -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.SendAmountToLow -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.UnableToGetFeeRate -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SendFlowException.UnableToBuildTxn -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SendFlowException.UnableToSaveUnsignedTransaction -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SendFlowException.WalletManager -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletManagerError.allocationSize(value.v1)
            )
            is SendFlowException.UnableToGetFeeDetails -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SendFlowException, buf: ByteBuffer) {
        when(value) {
            is SendFlowException.EmptyAddress -> {
                buf.putInt(1)
                Unit
            }
            is SendFlowException.InvalidNumber -> {
                buf.putInt(2)
                Unit
            }
            is SendFlowException.InvalidAddress -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowException.WrongNetwork -> {
                buf.putInt(4)
                FfiConverterString.write(value.`address`, buf)
                FfiConverterTypeNetwork.write(value.`validFor`, buf)
                FfiConverterTypeNetwork.write(value.`current`, buf)
                Unit
            }
            is SendFlowException.NoBalance -> {
                buf.putInt(5)
                Unit
            }
            is SendFlowException.ZeroAmount -> {
                buf.putInt(6)
                Unit
            }
            is SendFlowException.UnableToGetMaxSend -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowException.InsufficientFunds -> {
                buf.putInt(8)
                Unit
            }
            is SendFlowException.SendAmountToLow -> {
                buf.putInt(9)
                Unit
            }
            is SendFlowException.UnableToGetFeeRate -> {
                buf.putInt(10)
                Unit
            }
            is SendFlowException.UnableToBuildTxn -> {
                buf.putInt(11)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowException.UnableToSaveUnsignedTransaction -> {
                buf.putInt(12)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowException.WalletManager -> {
                buf.putInt(13)
                FfiConverterTypeWalletManagerError.write(value.v1, buf)
                Unit
            }
            is SendFlowException.UnableToGetFeeDetails -> {
                buf.putInt(14)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SendFlowErrorAlert {
    
    data class SignAndBroadcast(
        val v1: kotlin.String) : SendFlowErrorAlert()
        
    {
        

        companion object
    }
    
    data class ConfirmDetails(
        val v1: kotlin.String) : SendFlowErrorAlert()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowErrorAlert : FfiConverterRustBuffer<SendFlowErrorAlert>{
    override fun read(buf: ByteBuffer): SendFlowErrorAlert {
        return when(buf.getInt()) {
            1 -> SendFlowErrorAlert.SignAndBroadcast(
                FfiConverterString.read(buf),
                )
            2 -> SendFlowErrorAlert.ConfirmDetails(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowErrorAlert) = when(value) {
        is SendFlowErrorAlert.SignAndBroadcast -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowErrorAlert.ConfirmDetails -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SendFlowErrorAlert, buf: ByteBuffer) {
        when(value) {
            is SendFlowErrorAlert.SignAndBroadcast -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowErrorAlert.ConfirmDetails -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SendFlowFiatOnChangeError {
    
    data class InvalidFiatAmount(
        val `error`: kotlin.String, 
        val `input`: kotlin.String) : SendFlowFiatOnChangeError()
        
    {
        

        companion object
    }
    
    data class Converter(
        val v1: ConverterException) : SendFlowFiatOnChangeError()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowFiatOnChangeError : FfiConverterRustBuffer<SendFlowFiatOnChangeError>{
    override fun read(buf: ByteBuffer): SendFlowFiatOnChangeError {
        return when(buf.getInt()) {
            1 -> SendFlowFiatOnChangeError.InvalidFiatAmount(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> SendFlowFiatOnChangeError.Converter(
                FfiConverterTypeConverterError.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowFiatOnChangeError) = when(value) {
        is SendFlowFiatOnChangeError.InvalidFiatAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`error`)
                + FfiConverterString.allocationSize(value.`input`)
            )
        }
        is SendFlowFiatOnChangeError.Converter -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConverterError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SendFlowFiatOnChangeError, buf: ByteBuffer) {
        when(value) {
            is SendFlowFiatOnChangeError.InvalidFiatAmount -> {
                buf.putInt(1)
                FfiConverterString.write(value.`error`, buf)
                FfiConverterString.write(value.`input`, buf)
                Unit
            }
            is SendFlowFiatOnChangeError.Converter -> {
                buf.putInt(2)
                FfiConverterTypeConverterError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SendFlowManagerAction: Disposable  {
    
    data class ChangeEnteringAddress(
        val v1: kotlin.String) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class ChangeSetAmountFocusField(
        val v1: SetAmountFocusField?) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    object SelectMaxSend : SendFlowManagerAction()
    
    
    object ClearSendAmount : SendFlowManagerAction()
    
    
    object ClearAddress : SendFlowManagerAction()
    
    
    data class SetCoinControlMode(
        val v1: List<Utxo>) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    object DisableCoinControlMode : SendFlowManagerAction()
    
    
    data class SelectFeeRate(
        val v1: FeeRateOptionWithTotalFee) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyEnteringBtcAmountChanged(
        val v1: kotlin.String) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyEnteringFiatAmountChanged(
        val v1: kotlin.String) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyEnteringAddressChanged(
        val v1: kotlin.String) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifySelectedUnitedChanged(
        val `old`: BitcoinUnit, 
        val `new`: BitcoinUnit) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyBtcOrFiatChanged(
        val `old`: FiatOrBtc, 
        val `new`: FiatOrBtc) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyScanCodeChanged(
        val `old`: kotlin.String, 
        val `new`: kotlin.String) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyPricesChanged(
        val v1: PriceResponse) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyFocusFieldChanged(
        val `old`: SetAmountFocusField?, 
        val `new`: SetAmountFocusField?) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyAddressChanged(
        val v1: Address) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyAmountChanged(
        val v1: Amount) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyCoinControlAmountChanged(
        val v1: kotlin.Double) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class NotifyCoinControlEnteredAmountChanged(
        val v1: kotlin.String, 
        val v2: kotlin.Boolean) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    data class ChangeFeeRateOptions(
        val v1: FeeRateOptionsWithTotalFee) : SendFlowManagerAction()
        
    {
        

        companion object
    }
    
    object FinalizeAndGoToNextScreen : SendFlowManagerAction()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SendFlowManagerAction.ChangeEnteringAddress -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.ChangeSetAmountFocusField -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.SelectMaxSend -> {// Nothing to destroy
            }
            is SendFlowManagerAction.ClearSendAmount -> {// Nothing to destroy
            }
            is SendFlowManagerAction.ClearAddress -> {// Nothing to destroy
            }
            is SendFlowManagerAction.SetCoinControlMode -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.DisableCoinControlMode -> {// Nothing to destroy
            }
            is SendFlowManagerAction.SelectFeeRate -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyEnteringBtcAmountChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyEnteringFiatAmountChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyEnteringAddressChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifySelectedUnitedChanged -> {
                
    Disposable.destroy(
        this.`old`,
        this.`new`
    )
                
            }
            is SendFlowManagerAction.NotifyBtcOrFiatChanged -> {
                
    Disposable.destroy(
        this.`old`,
        this.`new`
    )
                
            }
            is SendFlowManagerAction.NotifyScanCodeChanged -> {
                
    Disposable.destroy(
        this.`old`,
        this.`new`
    )
                
            }
            is SendFlowManagerAction.NotifyPricesChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyFocusFieldChanged -> {
                
    Disposable.destroy(
        this.`old`,
        this.`new`
    )
                
            }
            is SendFlowManagerAction.NotifyAddressChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyAmountChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyCoinControlAmountChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.NotifyCoinControlEnteredAmountChanged -> {
                
    Disposable.destroy(
        this.v1,
        this.v2
    )
                
            }
            is SendFlowManagerAction.ChangeFeeRateOptions -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerAction.FinalizeAndGoToNextScreen -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowManagerAction : FfiConverterRustBuffer<SendFlowManagerAction>{
    override fun read(buf: ByteBuffer): SendFlowManagerAction {
        return when(buf.getInt()) {
            1 -> SendFlowManagerAction.ChangeEnteringAddress(
                FfiConverterString.read(buf),
                )
            2 -> SendFlowManagerAction.ChangeSetAmountFocusField(
                FfiConverterOptionalTypeSetAmountFocusField.read(buf),
                )
            3 -> SendFlowManagerAction.SelectMaxSend
            4 -> SendFlowManagerAction.ClearSendAmount
            5 -> SendFlowManagerAction.ClearAddress
            6 -> SendFlowManagerAction.SetCoinControlMode(
                FfiConverterSequenceTypeUtxo.read(buf),
                )
            7 -> SendFlowManagerAction.DisableCoinControlMode
            8 -> SendFlowManagerAction.SelectFeeRate(
                FfiConverterTypeFeeRateOptionWithTotalFee.read(buf),
                )
            9 -> SendFlowManagerAction.NotifyEnteringBtcAmountChanged(
                FfiConverterString.read(buf),
                )
            10 -> SendFlowManagerAction.NotifyEnteringFiatAmountChanged(
                FfiConverterString.read(buf),
                )
            11 -> SendFlowManagerAction.NotifyEnteringAddressChanged(
                FfiConverterString.read(buf),
                )
            12 -> SendFlowManagerAction.NotifySelectedUnitedChanged(
                FfiConverterTypeBitcoinUnit.read(buf),
                FfiConverterTypeBitcoinUnit.read(buf),
                )
            13 -> SendFlowManagerAction.NotifyBtcOrFiatChanged(
                FfiConverterTypeFiatOrBtc.read(buf),
                FfiConverterTypeFiatOrBtc.read(buf),
                )
            14 -> SendFlowManagerAction.NotifyScanCodeChanged(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            15 -> SendFlowManagerAction.NotifyPricesChanged(
                FfiConverterTypePriceResponse.read(buf),
                )
            16 -> SendFlowManagerAction.NotifyFocusFieldChanged(
                FfiConverterOptionalTypeSetAmountFocusField.read(buf),
                FfiConverterOptionalTypeSetAmountFocusField.read(buf),
                )
            17 -> SendFlowManagerAction.NotifyAddressChanged(
                FfiConverterTypeAddress.read(buf),
                )
            18 -> SendFlowManagerAction.NotifyAmountChanged(
                FfiConverterTypeAmount.read(buf),
                )
            19 -> SendFlowManagerAction.NotifyCoinControlAmountChanged(
                FfiConverterDouble.read(buf),
                )
            20 -> SendFlowManagerAction.NotifyCoinControlEnteredAmountChanged(
                FfiConverterString.read(buf),
                FfiConverterBoolean.read(buf),
                )
            21 -> SendFlowManagerAction.ChangeFeeRateOptions(
                FfiConverterTypeFeeRateOptionsWithTotalFee.read(buf),
                )
            22 -> SendFlowManagerAction.FinalizeAndGoToNextScreen
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowManagerAction) = when(value) {
        is SendFlowManagerAction.ChangeEnteringAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.ChangeSetAmountFocusField -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeSetAmountFocusField.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.SelectMaxSend -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowManagerAction.ClearSendAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowManagerAction.ClearAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowManagerAction.SetCoinControlMode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeUtxo.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.DisableCoinControlMode -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowManagerAction.SelectFeeRate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFeeRateOptionWithTotalFee.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyEnteringBtcAmountChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyEnteringFiatAmountChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyEnteringAddressChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifySelectedUnitedChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBitcoinUnit.allocationSize(value.`old`)
                + FfiConverterTypeBitcoinUnit.allocationSize(value.`new`)
            )
        }
        is SendFlowManagerAction.NotifyBtcOrFiatChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFiatOrBtc.allocationSize(value.`old`)
                + FfiConverterTypeFiatOrBtc.allocationSize(value.`new`)
            )
        }
        is SendFlowManagerAction.NotifyScanCodeChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`old`)
                + FfiConverterString.allocationSize(value.`new`)
            )
        }
        is SendFlowManagerAction.NotifyPricesChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePriceResponse.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyFocusFieldChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeSetAmountFocusField.allocationSize(value.`old`)
                + FfiConverterOptionalTypeSetAmountFocusField.allocationSize(value.`new`)
            )
        }
        is SendFlowManagerAction.NotifyAddressChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAddress.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyAmountChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAmount.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyCoinControlAmountChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterDouble.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.NotifyCoinControlEnteredAmountChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
                + FfiConverterBoolean.allocationSize(value.v2)
            )
        }
        is SendFlowManagerAction.ChangeFeeRateOptions -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFeeRateOptionsWithTotalFee.allocationSize(value.v1)
            )
        }
        is SendFlowManagerAction.FinalizeAndGoToNextScreen -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: SendFlowManagerAction, buf: ByteBuffer) {
        when(value) {
            is SendFlowManagerAction.ChangeEnteringAddress -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.ChangeSetAmountFocusField -> {
                buf.putInt(2)
                FfiConverterOptionalTypeSetAmountFocusField.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.SelectMaxSend -> {
                buf.putInt(3)
                Unit
            }
            is SendFlowManagerAction.ClearSendAmount -> {
                buf.putInt(4)
                Unit
            }
            is SendFlowManagerAction.ClearAddress -> {
                buf.putInt(5)
                Unit
            }
            is SendFlowManagerAction.SetCoinControlMode -> {
                buf.putInt(6)
                FfiConverterSequenceTypeUtxo.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.DisableCoinControlMode -> {
                buf.putInt(7)
                Unit
            }
            is SendFlowManagerAction.SelectFeeRate -> {
                buf.putInt(8)
                FfiConverterTypeFeeRateOptionWithTotalFee.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyEnteringBtcAmountChanged -> {
                buf.putInt(9)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyEnteringFiatAmountChanged -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyEnteringAddressChanged -> {
                buf.putInt(11)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifySelectedUnitedChanged -> {
                buf.putInt(12)
                FfiConverterTypeBitcoinUnit.write(value.`old`, buf)
                FfiConverterTypeBitcoinUnit.write(value.`new`, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyBtcOrFiatChanged -> {
                buf.putInt(13)
                FfiConverterTypeFiatOrBtc.write(value.`old`, buf)
                FfiConverterTypeFiatOrBtc.write(value.`new`, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyScanCodeChanged -> {
                buf.putInt(14)
                FfiConverterString.write(value.`old`, buf)
                FfiConverterString.write(value.`new`, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyPricesChanged -> {
                buf.putInt(15)
                FfiConverterTypePriceResponse.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyFocusFieldChanged -> {
                buf.putInt(16)
                FfiConverterOptionalTypeSetAmountFocusField.write(value.`old`, buf)
                FfiConverterOptionalTypeSetAmountFocusField.write(value.`new`, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyAddressChanged -> {
                buf.putInt(17)
                FfiConverterTypeAddress.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyAmountChanged -> {
                buf.putInt(18)
                FfiConverterTypeAmount.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyCoinControlAmountChanged -> {
                buf.putInt(19)
                FfiConverterDouble.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.NotifyCoinControlEnteredAmountChanged -> {
                buf.putInt(20)
                FfiConverterString.write(value.v1, buf)
                FfiConverterBoolean.write(value.v2, buf)
                Unit
            }
            is SendFlowManagerAction.ChangeFeeRateOptions -> {
                buf.putInt(21)
                FfiConverterTypeFeeRateOptionsWithTotalFee.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerAction.FinalizeAndGoToNextScreen -> {
                buf.putInt(22)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SendFlowManagerReconcileMessage: Disposable  {
    
    data class UpdateEnteringBtcAmount(
        val v1: kotlin.String) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateEnteringFiatAmount(
        val v1: kotlin.String) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateEnteringAddress(
        val v1: kotlin.String) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateAddress(
        val v1: Address?) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class SetMaxSelected(
        val v1: Amount) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    object UnsetMaxSelected : SendFlowManagerReconcileMessage()
    
    
    data class UpdateAmountSats(
        val v1: kotlin.ULong) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateAmountFiat(
        val v1: kotlin.Double) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateFocusField(
        val v1: SetAmountFocusField?) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateSelectedFeeRate(
        val v1: FeeRateOptionWithTotalFee) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdateFeeRateOptions(
        val v1: FeeRateOptionsWithTotalFee) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    object RefreshPresenters : SendFlowManagerReconcileMessage()
    
    
    data class SetAlert(
        val v1: SendFlowAlertState) : SendFlowManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    object ClearAlert : SendFlowManagerReconcileMessage()
    
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SendFlowManagerReconcileMessage.UpdateEnteringBtcAmount -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateEnteringFiatAmount -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateEnteringAddress -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateAddress -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.SetMaxSelected -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UnsetMaxSelected -> {// Nothing to destroy
            }
            is SendFlowManagerReconcileMessage.UpdateAmountSats -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateAmountFiat -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateFocusField -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateSelectedFeeRate -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.UpdateFeeRateOptions -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.RefreshPresenters -> {// Nothing to destroy
            }
            is SendFlowManagerReconcileMessage.SetAlert -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SendFlowManagerReconcileMessage.ClearAlert -> {// Nothing to destroy
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendFlowManagerReconcileMessage : FfiConverterRustBuffer<SendFlowManagerReconcileMessage>{
    override fun read(buf: ByteBuffer): SendFlowManagerReconcileMessage {
        return when(buf.getInt()) {
            1 -> SendFlowManagerReconcileMessage.UpdateEnteringBtcAmount(
                FfiConverterString.read(buf),
                )
            2 -> SendFlowManagerReconcileMessage.UpdateEnteringFiatAmount(
                FfiConverterString.read(buf),
                )
            3 -> SendFlowManagerReconcileMessage.UpdateEnteringAddress(
                FfiConverterString.read(buf),
                )
            4 -> SendFlowManagerReconcileMessage.UpdateAddress(
                FfiConverterOptionalTypeAddress.read(buf),
                )
            5 -> SendFlowManagerReconcileMessage.SetMaxSelected(
                FfiConverterTypeAmount.read(buf),
                )
            6 -> SendFlowManagerReconcileMessage.UnsetMaxSelected
            7 -> SendFlowManagerReconcileMessage.UpdateAmountSats(
                FfiConverterULong.read(buf),
                )
            8 -> SendFlowManagerReconcileMessage.UpdateAmountFiat(
                FfiConverterDouble.read(buf),
                )
            9 -> SendFlowManagerReconcileMessage.UpdateFocusField(
                FfiConverterOptionalTypeSetAmountFocusField.read(buf),
                )
            10 -> SendFlowManagerReconcileMessage.UpdateSelectedFeeRate(
                FfiConverterTypeFeeRateOptionWithTotalFee.read(buf),
                )
            11 -> SendFlowManagerReconcileMessage.UpdateFeeRateOptions(
                FfiConverterTypeFeeRateOptionsWithTotalFee.read(buf),
                )
            12 -> SendFlowManagerReconcileMessage.RefreshPresenters
            13 -> SendFlowManagerReconcileMessage.SetAlert(
                FfiConverterTypeSendFlowAlertState.read(buf),
                )
            14 -> SendFlowManagerReconcileMessage.ClearAlert
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendFlowManagerReconcileMessage) = when(value) {
        is SendFlowManagerReconcileMessage.UpdateEnteringBtcAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateEnteringFiatAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateEnteringAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeAddress.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.SetMaxSelected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeAmount.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UnsetMaxSelected -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowManagerReconcileMessage.UpdateAmountSats -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterULong.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateAmountFiat -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterDouble.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateFocusField -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterOptionalTypeSetAmountFocusField.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateSelectedFeeRate -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFeeRateOptionWithTotalFee.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.UpdateFeeRateOptions -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFeeRateOptionsWithTotalFee.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.RefreshPresenters -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SendFlowManagerReconcileMessage.SetAlert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSendFlowAlertState.allocationSize(value.v1)
            )
        }
        is SendFlowManagerReconcileMessage.ClearAlert -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: SendFlowManagerReconcileMessage, buf: ByteBuffer) {
        when(value) {
            is SendFlowManagerReconcileMessage.UpdateEnteringBtcAmount -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateEnteringFiatAmount -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateEnteringAddress -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateAddress -> {
                buf.putInt(4)
                FfiConverterOptionalTypeAddress.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.SetMaxSelected -> {
                buf.putInt(5)
                FfiConverterTypeAmount.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UnsetMaxSelected -> {
                buf.putInt(6)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateAmountSats -> {
                buf.putInt(7)
                FfiConverterULong.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateAmountFiat -> {
                buf.putInt(8)
                FfiConverterDouble.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateFocusField -> {
                buf.putInt(9)
                FfiConverterOptionalTypeSetAmountFocusField.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateSelectedFeeRate -> {
                buf.putInt(10)
                FfiConverterTypeFeeRateOptionWithTotalFee.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.UpdateFeeRateOptions -> {
                buf.putInt(11)
                FfiConverterTypeFeeRateOptionsWithTotalFee.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.RefreshPresenters -> {
                buf.putInt(12)
                Unit
            }
            is SendFlowManagerReconcileMessage.SetAlert -> {
                buf.putInt(13)
                FfiConverterTypeSendFlowAlertState.write(value.v1, buf)
                Unit
            }
            is SendFlowManagerReconcileMessage.ClearAlert -> {
                buf.putInt(14)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SendRoute: Disposable  {
    
    data class SetAmount(
        val `id`: WalletId, 
        val `address`: Address?, 
        val `amount`: Amount?) : SendRoute()
        
    {
        

        companion object
    }
    
    data class CoinControlSetAmount(
        val `id`: WalletId, 
        val `utxos`: List<Utxo>) : SendRoute()
        
    {
        

        companion object
    }
    
    data class HardwareExport(
        val `id`: WalletId, 
        val `details`: ConfirmDetails) : SendRoute()
        
    {
        

        companion object
    }
    
    data class Confirm(
        val v1: SendRouteConfirmArgs) : SendRoute()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SendRoute.SetAmount -> {
                
    Disposable.destroy(
        this.`id`,
        this.`address`,
        this.`amount`
    )
                
            }
            is SendRoute.CoinControlSetAmount -> {
                
    Disposable.destroy(
        this.`id`,
        this.`utxos`
    )
                
            }
            is SendRoute.HardwareExport -> {
                
    Disposable.destroy(
        this.`id`,
        this.`details`
    )
                
            }
            is SendRoute.Confirm -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSendRoute : FfiConverterRustBuffer<SendRoute>{
    override fun read(buf: ByteBuffer): SendRoute {
        return when(buf.getInt()) {
            1 -> SendRoute.SetAmount(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterOptionalTypeAddress.read(buf),
                FfiConverterOptionalTypeAmount.read(buf),
                )
            2 -> SendRoute.CoinControlSetAmount(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterSequenceTypeUtxo.read(buf),
                )
            3 -> SendRoute.HardwareExport(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterTypeConfirmDetails.read(buf),
                )
            4 -> SendRoute.Confirm(
                FfiConverterTypeSendRouteConfirmArgs.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SendRoute) = when(value) {
        is SendRoute.SetAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterOptionalTypeAddress.allocationSize(value.`address`)
                + FfiConverterOptionalTypeAmount.allocationSize(value.`amount`)
            )
        }
        is SendRoute.CoinControlSetAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterSequenceTypeUtxo.allocationSize(value.`utxos`)
            )
        }
        is SendRoute.HardwareExport -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterTypeConfirmDetails.allocationSize(value.`details`)
            )
        }
        is SendRoute.Confirm -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSendRouteConfirmArgs.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SendRoute, buf: ByteBuffer) {
        when(value) {
            is SendRoute.SetAmount -> {
                buf.putInt(1)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterOptionalTypeAddress.write(value.`address`, buf)
                FfiConverterOptionalTypeAmount.write(value.`amount`, buf)
                Unit
            }
            is SendRoute.CoinControlSetAmount -> {
                buf.putInt(2)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterSequenceTypeUtxo.write(value.`utxos`, buf)
                Unit
            }
            is SendRoute.HardwareExport -> {
                buf.putInt(3)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterTypeConfirmDetails.write(value.`details`, buf)
                Unit
            }
            is SendRoute.Confirm -> {
                buf.putInt(4)
                FfiConverterTypeSendRouteConfirmArgs.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class SerdeException: kotlin.Exception() {
    
    class SerializationException(
        
        val v1: kotlin.String
        ) : SerdeException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class DeserializationException(
        
        val v1: kotlin.String
        ) : SerdeException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SerdeException> {
        override fun lift(error_buf: RustBuffer.ByValue): SerdeException = FfiConverterTypeSerdeError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeSerdeError : FfiConverterRustBuffer<SerdeException> {
    override fun read(buf: ByteBuffer): SerdeException {
        

        return when(buf.getInt()) {
            1 -> SerdeException.SerializationException(
                FfiConverterString.read(buf),
                )
            2 -> SerdeException.DeserializationException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SerdeException): ULong {
        return when(value) {
            is SerdeException.SerializationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is SerdeException.DeserializationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SerdeException, buf: ByteBuffer) {
        when(value) {
            is SerdeException.SerializationException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is SerdeException.DeserializationException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class SetAmountFocusField {
    
    AMOUNT,
    ADDRESS;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSetAmountFocusField: FfiConverterRustBuffer<SetAmountFocusField> {
    override fun read(buf: ByteBuffer) = try {
        SetAmountFocusField.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SetAmountFocusField) = 4UL

    override fun write(value: SetAmountFocusField, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class SettingsRoute {
    
    object Main : SettingsRoute()
    
    
    object Network : SettingsRoute()
    
    
    object Appearance : SettingsRoute()
    
    
    object Node : SettingsRoute()
    
    
    object FiatCurrency : SettingsRoute()
    
    
    data class Wallet(
        val `id`: WalletId, 
        val `route`: WalletSettingsRoute) : SettingsRoute()
        
    {
        

        companion object
    }
    
    object AllWallets : SettingsRoute()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSettingsRoute : FfiConverterRustBuffer<SettingsRoute>{
    override fun read(buf: ByteBuffer): SettingsRoute {
        return when(buf.getInt()) {
            1 -> SettingsRoute.Main
            2 -> SettingsRoute.Network
            3 -> SettingsRoute.Appearance
            4 -> SettingsRoute.Node
            5 -> SettingsRoute.FiatCurrency
            6 -> SettingsRoute.Wallet(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterTypeWalletSettingsRoute.read(buf),
                )
            7 -> SettingsRoute.AllWallets
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SettingsRoute) = when(value) {
        is SettingsRoute.Main -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SettingsRoute.Network -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SettingsRoute.Appearance -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SettingsRoute.Node -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SettingsRoute.FiatCurrency -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is SettingsRoute.Wallet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterTypeWalletSettingsRoute.allocationSize(value.`route`)
            )
        }
        is SettingsRoute.AllWallets -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: SettingsRoute, buf: ByteBuffer) {
        when(value) {
            is SettingsRoute.Main -> {
                buf.putInt(1)
                Unit
            }
            is SettingsRoute.Network -> {
                buf.putInt(2)
                Unit
            }
            is SettingsRoute.Appearance -> {
                buf.putInt(3)
                Unit
            }
            is SettingsRoute.Node -> {
                buf.putInt(4)
                Unit
            }
            is SettingsRoute.FiatCurrency -> {
                buf.putInt(5)
                Unit
            }
            is SettingsRoute.Wallet -> {
                buf.putInt(6)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterTypeWalletSettingsRoute.write(value.`route`, buf)
                Unit
            }
            is SettingsRoute.AllWallets -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class SetupCmdResponse: Disposable  {
    
    data class Init(
        val v1: ContinueFromInit) : SetupCmdResponse()
        
    {
        

        companion object
    }
    
    data class Backup(
        val v1: ContinueFromBackup) : SetupCmdResponse()
        
    {
        

        companion object
    }
    
    data class Derive(
        val v1: ContinueFromDerive) : SetupCmdResponse()
        
    {
        

        companion object
    }
    
    data class Complete(
        val v1: TapSignerSetupComplete) : SetupCmdResponse()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is SetupCmdResponse.Init -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SetupCmdResponse.Backup -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SetupCmdResponse.Derive -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is SetupCmdResponse.Complete -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSetupCmdResponse : FfiConverterRustBuffer<SetupCmdResponse>{
    override fun read(buf: ByteBuffer): SetupCmdResponse {
        return when(buf.getInt()) {
            1 -> SetupCmdResponse.Init(
                FfiConverterTypeContinueFromInit.read(buf),
                )
            2 -> SetupCmdResponse.Backup(
                FfiConverterTypeContinueFromBackup.read(buf),
                )
            3 -> SetupCmdResponse.Derive(
                FfiConverterTypeContinueFromDerive.read(buf),
                )
            4 -> SetupCmdResponse.Complete(
                FfiConverterTypeTapSignerSetupComplete.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SetupCmdResponse) = when(value) {
        is SetupCmdResponse.Init -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContinueFromInit.allocationSize(value.v1)
            )
        }
        is SetupCmdResponse.Backup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContinueFromBackup.allocationSize(value.v1)
            )
        }
        is SetupCmdResponse.Derive -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeContinueFromDerive.allocationSize(value.v1)
            )
        }
        is SetupCmdResponse.Complete -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSignerSetupComplete.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: SetupCmdResponse, buf: ByteBuffer) {
        when(value) {
            is SetupCmdResponse.Init -> {
                buf.putInt(1)
                FfiConverterTypeContinueFromInit.write(value.v1, buf)
                Unit
            }
            is SetupCmdResponse.Backup -> {
                buf.putInt(2)
                FfiConverterTypeContinueFromBackup.write(value.v1, buf)
                Unit
            }
            is SetupCmdResponse.Derive -> {
                buf.putInt(3)
                FfiConverterTypeContinueFromDerive.write(value.v1, buf)
                Unit
            }
            is SetupCmdResponse.Complete -> {
                buf.putInt(4)
                FfiConverterTypeTapSignerSetupComplete.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class StoreType {
    
    SQLITE,
    FILE_STORE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeStoreType: FfiConverterRustBuffer<StoreType> {
    override fun read(buf: ByteBuffer) = try {
        StoreType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: StoreType) = 4UL

    override fun write(value: StoreType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





/**
 * A string or data, could be a string or data (bytes)
 */
sealed class StringOrData {
    
    data class String(
        val v1: kotlin.String) : StringOrData()
        
    {
        

        companion object
    }
    
    data class Data(
        val v1: kotlin.ByteArray) : StringOrData()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStringOrData : FfiConverterRustBuffer<StringOrData>{
    override fun read(buf: ByteBuffer): StringOrData {
        return when(buf.getInt()) {
            1 -> StringOrData.String(
                FfiConverterString.read(buf),
                )
            2 -> StringOrData.Data(
                FfiConverterByteArray.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: StringOrData) = when(value) {
        is StringOrData.String -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is StringOrData.Data -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterByteArray.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: StringOrData, buf: ByteBuffer) {
        when(value) {
            is StringOrData.String -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is StringOrData.Data -> {
                buf.putInt(2)
                FfiConverterByteArray.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TapSignerCmd: Disposable  {
    
    data class Setup(
        val v1: SetupCmd) : TapSignerCmd()
        
    {
        

        companion object
    }
    
    data class Backup(
        val `pin`: kotlin.String) : TapSignerCmd()
        
    {
        

        companion object
    }
    
    data class Derive(
        val `pin`: kotlin.String) : TapSignerCmd()
        
    {
        

        companion object
    }
    
    data class Change(
        val `currentPin`: kotlin.String, 
        val `newPin`: kotlin.String) : TapSignerCmd()
        
    {
        

        companion object
    }
    
    data class Sign(
        val `psbt`: Psbt, 
        val `pin`: kotlin.String) : TapSignerCmd()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TapSignerCmd.Setup -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerCmd.Backup -> {
                
    Disposable.destroy(
        this.`pin`
    )
                
            }
            is TapSignerCmd.Derive -> {
                
    Disposable.destroy(
        this.`pin`
    )
                
            }
            is TapSignerCmd.Change -> {
                
    Disposable.destroy(
        this.`currentPin`,
        this.`newPin`
    )
                
            }
            is TapSignerCmd.Sign -> {
                
    Disposable.destroy(
        this.`psbt`,
        this.`pin`
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerCmd : FfiConverterRustBuffer<TapSignerCmd>{
    override fun read(buf: ByteBuffer): TapSignerCmd {
        return when(buf.getInt()) {
            1 -> TapSignerCmd.Setup(
                FfiConverterTypeSetupCmd.read(buf),
                )
            2 -> TapSignerCmd.Backup(
                FfiConverterString.read(buf),
                )
            3 -> TapSignerCmd.Derive(
                FfiConverterString.read(buf),
                )
            4 -> TapSignerCmd.Change(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            5 -> TapSignerCmd.Sign(
                FfiConverterTypePsbt.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TapSignerCmd) = when(value) {
        is TapSignerCmd.Setup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSetupCmd.allocationSize(value.v1)
            )
        }
        is TapSignerCmd.Backup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`pin`)
            )
        }
        is TapSignerCmd.Derive -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`pin`)
            )
        }
        is TapSignerCmd.Change -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.`currentPin`)
                + FfiConverterString.allocationSize(value.`newPin`)
            )
        }
        is TapSignerCmd.Sign -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePsbt.allocationSize(value.`psbt`)
                + FfiConverterString.allocationSize(value.`pin`)
            )
        }
    }

    override fun write(value: TapSignerCmd, buf: ByteBuffer) {
        when(value) {
            is TapSignerCmd.Setup -> {
                buf.putInt(1)
                FfiConverterTypeSetupCmd.write(value.v1, buf)
                Unit
            }
            is TapSignerCmd.Backup -> {
                buf.putInt(2)
                FfiConverterString.write(value.`pin`, buf)
                Unit
            }
            is TapSignerCmd.Derive -> {
                buf.putInt(3)
                FfiConverterString.write(value.`pin`, buf)
                Unit
            }
            is TapSignerCmd.Change -> {
                buf.putInt(4)
                FfiConverterString.write(value.`currentPin`, buf)
                FfiConverterString.write(value.`newPin`, buf)
                Unit
            }
            is TapSignerCmd.Sign -> {
                buf.putInt(5)
                FfiConverterTypePsbt.write(value.`psbt`, buf)
                FfiConverterString.write(value.`pin`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





/**
 * When the user goes through entering the PIN and setting a new one, they are either setting up a new tapsigner
 * or changing the PIN on an existing one
 */

enum class TapSignerPinAction {
    
    SETUP,
    CHANGE;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTapSignerPinAction: FfiConverterRustBuffer<TapSignerPinAction> {
    override fun read(buf: ByteBuffer) = try {
        TapSignerPinAction.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TapSignerPinAction) = 4UL

    override fun write(value: TapSignerPinAction, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class TapSignerReaderException: kotlin.Exception() {
    
    class TapSignerException(
        
        val v1: TransportException
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class PsbtSignException(
        
        val v1: kotlin.String
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ExtractTxException(
        
        val v1: kotlin.String
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnknownCardType(
        
        val v1: kotlin.String
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NoCommand(
        ) : TapSignerReaderException() {
        override val message
            get() = ""
    }
    
    class InvalidPinLength(
        
        val v1: kotlin.UByte
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NonNumericPin(
        
        val v1: kotlin.String
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SetupAlreadyComplete(
        ) : TapSignerReaderException() {
        override val message
            get() = ""
    }
    
    class InvalidChainCodeLength(
        
        val v1: kotlin.UInt
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Unknown(
        
        val v1: kotlin.String
        ) : TapSignerReaderException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<TapSignerReaderException> {
        override fun lift(error_buf: RustBuffer.ByValue): TapSignerReaderException = FfiConverterTypeTapSignerReaderError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerReaderError : FfiConverterRustBuffer<TapSignerReaderException> {
    override fun read(buf: ByteBuffer): TapSignerReaderException {
        

        return when(buf.getInt()) {
            1 -> TapSignerReaderException.TapSignerException(
                FfiConverterTypeTransportError.read(buf),
                )
            2 -> TapSignerReaderException.PsbtSignException(
                FfiConverterString.read(buf),
                )
            3 -> TapSignerReaderException.ExtractTxException(
                FfiConverterString.read(buf),
                )
            4 -> TapSignerReaderException.UnknownCardType(
                FfiConverterString.read(buf),
                )
            5 -> TapSignerReaderException.NoCommand()
            6 -> TapSignerReaderException.InvalidPinLength(
                FfiConverterUByte.read(buf),
                )
            7 -> TapSignerReaderException.NonNumericPin(
                FfiConverterString.read(buf),
                )
            8 -> TapSignerReaderException.SetupAlreadyComplete()
            9 -> TapSignerReaderException.InvalidChainCodeLength(
                FfiConverterUInt.read(buf),
                )
            10 -> TapSignerReaderException.Unknown(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TapSignerReaderException): ULong {
        return when(value) {
            is TapSignerReaderException.TapSignerException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeTransportError.allocationSize(value.v1)
            )
            is TapSignerReaderException.PsbtSignException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TapSignerReaderException.ExtractTxException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TapSignerReaderException.UnknownCardType -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TapSignerReaderException.NoCommand -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is TapSignerReaderException.InvalidPinLength -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUByte.allocationSize(value.v1)
            )
            is TapSignerReaderException.NonNumericPin -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TapSignerReaderException.SetupAlreadyComplete -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is TapSignerReaderException.InvalidChainCodeLength -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterUInt.allocationSize(value.v1)
            )
            is TapSignerReaderException.Unknown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: TapSignerReaderException, buf: ByteBuffer) {
        when(value) {
            is TapSignerReaderException.TapSignerException -> {
                buf.putInt(1)
                FfiConverterTypeTransportError.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.PsbtSignException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.ExtractTxException -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.UnknownCardType -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.NoCommand -> {
                buf.putInt(5)
                Unit
            }
            is TapSignerReaderException.InvalidPinLength -> {
                buf.putInt(6)
                FfiConverterUByte.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.NonNumericPin -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.SetupAlreadyComplete -> {
                buf.putInt(8)
                Unit
            }
            is TapSignerReaderException.InvalidChainCodeLength -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.v1, buf)
                Unit
            }
            is TapSignerReaderException.Unknown -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class TapSignerResponse: Disposable  {
    
    data class Setup(
        val v1: SetupCmdResponse) : TapSignerResponse()
        
    {
        

        companion object
    }
    
    data class Backup(
        val v1: kotlin.ByteArray) : TapSignerResponse()
        
    {
        

        companion object
    }
    
    data class Import(
        val v1: DeriveInfo) : TapSignerResponse()
        
    {
        

        companion object
    }
    
    object Change : TapSignerResponse()
    
    
    data class Sign(
        val v1: Psbt) : TapSignerResponse()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TapSignerResponse.Setup -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerResponse.Backup -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerResponse.Import -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerResponse.Change -> {// Nothing to destroy
            }
            is TapSignerResponse.Sign -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerResponse : FfiConverterRustBuffer<TapSignerResponse>{
    override fun read(buf: ByteBuffer): TapSignerResponse {
        return when(buf.getInt()) {
            1 -> TapSignerResponse.Setup(
                FfiConverterTypeSetupCmdResponse.read(buf),
                )
            2 -> TapSignerResponse.Backup(
                FfiConverterByteArray.read(buf),
                )
            3 -> TapSignerResponse.Import(
                FfiConverterTypeDeriveInfo.read(buf),
                )
            4 -> TapSignerResponse.Change
            5 -> TapSignerResponse.Sign(
                FfiConverterTypePsbt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TapSignerResponse) = when(value) {
        is TapSignerResponse.Setup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSetupCmdResponse.allocationSize(value.v1)
            )
        }
        is TapSignerResponse.Backup -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterByteArray.allocationSize(value.v1)
            )
        }
        is TapSignerResponse.Import -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeDeriveInfo.allocationSize(value.v1)
            )
        }
        is TapSignerResponse.Change -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is TapSignerResponse.Sign -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypePsbt.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: TapSignerResponse, buf: ByteBuffer) {
        when(value) {
            is TapSignerResponse.Setup -> {
                buf.putInt(1)
                FfiConverterTypeSetupCmdResponse.write(value.v1, buf)
                Unit
            }
            is TapSignerResponse.Backup -> {
                buf.putInt(2)
                FfiConverterByteArray.write(value.v1, buf)
                Unit
            }
            is TapSignerResponse.Import -> {
                buf.putInt(3)
                FfiConverterTypeDeriveInfo.write(value.v1, buf)
                Unit
            }
            is TapSignerResponse.Change -> {
                buf.putInt(4)
                Unit
            }
            is TapSignerResponse.Sign -> {
                buf.putInt(5)
                FfiConverterTypePsbt.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TapSignerRoute: Disposable  {
    
    data class InitSelect(
        val v1: TapSigner) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class InitAdvanced(
        val v1: TapSigner) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class StartingPin(
        val `tapSigner`: TapSigner, 
        val `chainCode`: kotlin.String?) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class NewPin(
        val v1: TapSignerNewPinArgs) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class ConfirmPin(
        val v1: TapSignerConfirmPinArgs) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class SetupSuccess(
        val v1: TapSigner, 
        val v2: TapSignerSetupComplete) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class SetupRetry(
        val v1: TapSigner, 
        val v2: SetupCmdResponse) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class ImportSuccess(
        val v1: TapSigner, 
        val v2: DeriveInfo) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class ImportRetry(
        val v1: TapSigner) : TapSignerRoute()
        
    {
        

        companion object
    }
    
    data class EnterPin(
        val `tapSigner`: TapSigner, 
        val `action`: AfterPinAction) : TapSignerRoute()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TapSignerRoute.InitSelect -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerRoute.InitAdvanced -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerRoute.StartingPin -> {
                
    Disposable.destroy(
        this.`tapSigner`,
        this.`chainCode`
    )
                
            }
            is TapSignerRoute.NewPin -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerRoute.ConfirmPin -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerRoute.SetupSuccess -> {
                
    Disposable.destroy(
        this.v1,
        this.v2
    )
                
            }
            is TapSignerRoute.SetupRetry -> {
                
    Disposable.destroy(
        this.v1,
        this.v2
    )
                
            }
            is TapSignerRoute.ImportSuccess -> {
                
    Disposable.destroy(
        this.v1,
        this.v2
    )
                
            }
            is TapSignerRoute.ImportRetry -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is TapSignerRoute.EnterPin -> {
                
    Disposable.destroy(
        this.`tapSigner`,
        this.`action`
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTapSignerRoute : FfiConverterRustBuffer<TapSignerRoute>{
    override fun read(buf: ByteBuffer): TapSignerRoute {
        return when(buf.getInt()) {
            1 -> TapSignerRoute.InitSelect(
                FfiConverterTypeTapSigner.read(buf),
                )
            2 -> TapSignerRoute.InitAdvanced(
                FfiConverterTypeTapSigner.read(buf),
                )
            3 -> TapSignerRoute.StartingPin(
                FfiConverterTypeTapSigner.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            4 -> TapSignerRoute.NewPin(
                FfiConverterTypeTapSignerNewPinArgs.read(buf),
                )
            5 -> TapSignerRoute.ConfirmPin(
                FfiConverterTypeTapSignerConfirmPinArgs.read(buf),
                )
            6 -> TapSignerRoute.SetupSuccess(
                FfiConverterTypeTapSigner.read(buf),
                FfiConverterTypeTapSignerSetupComplete.read(buf),
                )
            7 -> TapSignerRoute.SetupRetry(
                FfiConverterTypeTapSigner.read(buf),
                FfiConverterTypeSetupCmdResponse.read(buf),
                )
            8 -> TapSignerRoute.ImportSuccess(
                FfiConverterTypeTapSigner.read(buf),
                FfiConverterTypeDeriveInfo.read(buf),
                )
            9 -> TapSignerRoute.ImportRetry(
                FfiConverterTypeTapSigner.read(buf),
                )
            10 -> TapSignerRoute.EnterPin(
                FfiConverterTypeTapSigner.read(buf),
                FfiConverterTypeAfterPinAction.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TapSignerRoute) = when(value) {
        is TapSignerRoute.InitSelect -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
            )
        }
        is TapSignerRoute.InitAdvanced -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
            )
        }
        is TapSignerRoute.StartingPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.`tapSigner`)
                + FfiConverterOptionalString.allocationSize(value.`chainCode`)
            )
        }
        is TapSignerRoute.NewPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSignerNewPinArgs.allocationSize(value.v1)
            )
        }
        is TapSignerRoute.ConfirmPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSignerConfirmPinArgs.allocationSize(value.v1)
            )
        }
        is TapSignerRoute.SetupSuccess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
                + FfiConverterTypeTapSignerSetupComplete.allocationSize(value.v2)
            )
        }
        is TapSignerRoute.SetupRetry -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
                + FfiConverterTypeSetupCmdResponse.allocationSize(value.v2)
            )
        }
        is TapSignerRoute.ImportSuccess -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
                + FfiConverterTypeDeriveInfo.allocationSize(value.v2)
            )
        }
        is TapSignerRoute.ImportRetry -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.v1)
            )
        }
        is TapSignerRoute.EnterPin -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTapSigner.allocationSize(value.`tapSigner`)
                + FfiConverterTypeAfterPinAction.allocationSize(value.`action`)
            )
        }
    }

    override fun write(value: TapSignerRoute, buf: ByteBuffer) {
        when(value) {
            is TapSignerRoute.InitSelect -> {
                buf.putInt(1)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                Unit
            }
            is TapSignerRoute.InitAdvanced -> {
                buf.putInt(2)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                Unit
            }
            is TapSignerRoute.StartingPin -> {
                buf.putInt(3)
                FfiConverterTypeTapSigner.write(value.`tapSigner`, buf)
                FfiConverterOptionalString.write(value.`chainCode`, buf)
                Unit
            }
            is TapSignerRoute.NewPin -> {
                buf.putInt(4)
                FfiConverterTypeTapSignerNewPinArgs.write(value.v1, buf)
                Unit
            }
            is TapSignerRoute.ConfirmPin -> {
                buf.putInt(5)
                FfiConverterTypeTapSignerConfirmPinArgs.write(value.v1, buf)
                Unit
            }
            is TapSignerRoute.SetupSuccess -> {
                buf.putInt(6)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                FfiConverterTypeTapSignerSetupComplete.write(value.v2, buf)
                Unit
            }
            is TapSignerRoute.SetupRetry -> {
                buf.putInt(7)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                FfiConverterTypeSetupCmdResponse.write(value.v2, buf)
                Unit
            }
            is TapSignerRoute.ImportSuccess -> {
                buf.putInt(8)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                FfiConverterTypeDeriveInfo.write(value.v2, buf)
                Unit
            }
            is TapSignerRoute.ImportRetry -> {
                buf.putInt(9)
                FfiConverterTypeTapSigner.write(value.v1, buf)
                Unit
            }
            is TapSignerRoute.EnterPin -> {
                buf.putInt(10)
                FfiConverterTypeTapSigner.write(value.`tapSigner`, buf)
                FfiConverterTypeAfterPinAction.write(value.`action`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class Transaction: Disposable  {
    
    data class Confirmed(
        val v1: ConfirmedTransaction) : Transaction()
        
    {
        

        companion object
    }
    
    data class Unconfirmed(
        val v1: UnconfirmedTransaction) : Transaction()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is Transaction.Confirmed -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is Transaction.Unconfirmed -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransaction : FfiConverterRustBuffer<Transaction>{
    override fun read(buf: ByteBuffer): Transaction {
        return when(buf.getInt()) {
            1 -> Transaction.Confirmed(
                FfiConverterTypeConfirmedTransaction.read(buf),
                )
            2 -> Transaction.Unconfirmed(
                FfiConverterTypeUnconfirmedTransaction.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Transaction) = when(value) {
        is Transaction.Confirmed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeConfirmedTransaction.allocationSize(value.v1)
            )
        }
        is Transaction.Unconfirmed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeUnconfirmedTransaction.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: Transaction, buf: ByteBuffer) {
        when(value) {
            is Transaction.Confirmed -> {
                buf.putInt(1)
                FfiConverterTypeConfirmedTransaction.write(value.v1, buf)
                Unit
            }
            is Transaction.Unconfirmed -> {
                buf.putInt(2)
                FfiConverterTypeUnconfirmedTransaction.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class TransactionDetailException: kotlin.Exception() {
    
    class Fee(
        
        val v1: kotlin.String
        ) : TransactionDetailException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class FeeRate(
        
        val v1: kotlin.String
        ) : TransactionDetailException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Address(
        
        val v1: AddressException
        ) : TransactionDetailException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class FiatAmount(
        
        val v1: kotlin.String
        ) : TransactionDetailException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ChangeAddress(
        
        val v1: kotlin.String
        ) : TransactionDetailException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<TransactionDetailException> {
        override fun lift(error_buf: RustBuffer.ByValue): TransactionDetailException = FfiConverterTypeTransactionDetailError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeTransactionDetailError : FfiConverterRustBuffer<TransactionDetailException> {
    override fun read(buf: ByteBuffer): TransactionDetailException {
        

        return when(buf.getInt()) {
            1 -> TransactionDetailException.Fee(
                FfiConverterString.read(buf),
                )
            2 -> TransactionDetailException.FeeRate(
                FfiConverterString.read(buf),
                )
            3 -> TransactionDetailException.Address(
                FfiConverterTypeAddressError.read(buf),
                )
            4 -> TransactionDetailException.FiatAmount(
                FfiConverterString.read(buf),
                )
            5 -> TransactionDetailException.ChangeAddress(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransactionDetailException): ULong {
        return when(value) {
            is TransactionDetailException.Fee -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransactionDetailException.FeeRate -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransactionDetailException.Address -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeAddressError.allocationSize(value.v1)
            )
            is TransactionDetailException.FiatAmount -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransactionDetailException.ChangeAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: TransactionDetailException, buf: ByteBuffer) {
        when(value) {
            is TransactionDetailException.Fee -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransactionDetailException.FeeRate -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransactionDetailException.Address -> {
                buf.putInt(3)
                FfiConverterTypeAddressError.write(value.v1, buf)
                Unit
            }
            is TransactionDetailException.FiatAmount -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransactionDetailException.ChangeAddress -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class TransactionState {
    
    PENDING,
    CONFIRMED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTransactionState: FfiConverterRustBuffer<TransactionState> {
    override fun read(buf: ByteBuffer) = try {
        TransactionState.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TransactionState) = 4UL

    override fun write(value: TransactionState, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class TransportException: kotlin.Exception() {
    
    class CiborDe(
        
        val v1: kotlin.String
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class CiborValue(
        
        val v1: kotlin.String
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class CkTap(
        
        val v1: CkTapException
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class IncorrectSignature(
        
        val v1: kotlin.String
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnknownCardType(
        
        val v1: kotlin.String
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class CvcChangeException(
        
        val v1: kotlin.String
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnknownException(
        
        val v1: kotlin.String
        ) : TransportException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<TransportException> {
        override fun lift(error_buf: RustBuffer.ByValue): TransportException = FfiConverterTypeTransportError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeTransportError : FfiConverterRustBuffer<TransportException> {
    override fun read(buf: ByteBuffer): TransportException {
        

        return when(buf.getInt()) {
            1 -> TransportException.CiborDe(
                FfiConverterString.read(buf),
                )
            2 -> TransportException.CiborValue(
                FfiConverterString.read(buf),
                )
            3 -> TransportException.CkTap(
                FfiConverterTypeCkTapError.read(buf),
                )
            4 -> TransportException.IncorrectSignature(
                FfiConverterString.read(buf),
                )
            5 -> TransportException.UnknownCardType(
                FfiConverterString.read(buf),
                )
            6 -> TransportException.CvcChangeException(
                FfiConverterString.read(buf),
                )
            7 -> TransportException.UnknownException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransportException): ULong {
        return when(value) {
            is TransportException.CiborDe -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransportException.CiborValue -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransportException.CkTap -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeCkTapError.allocationSize(value.v1)
            )
            is TransportException.IncorrectSignature -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransportException.UnknownCardType -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransportException.CvcChangeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is TransportException.UnknownException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: TransportException, buf: ByteBuffer) {
        when(value) {
            is TransportException.CiborDe -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransportException.CiborValue -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransportException.CkTap -> {
                buf.putInt(3)
                FfiConverterTypeCkTapError.write(value.v1, buf)
                Unit
            }
            is TransportException.IncorrectSignature -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransportException.UnknownCardType -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransportException.CvcChangeException -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is TransportException.UnknownException -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class TrickPinException: kotlin.Exception() {
    
    /**
     * Unable to set trick PIN, because PIN is not enabled
     */
    class PinNotEnabled(
        ) : TrickPinException() {
        override val message
            get() = ""
    }
    
    /**
     * Unable to set trick PIN, because its the same as the current pin
     */
    class SameAsCurrentPin(
        ) : TrickPinException() {
        override val message
            get() = ""
    }
    
    /**
     * Unable to set trick PIN, its the same as another PIN
     */
    class SameAsAnotherPin(
        ) : TrickPinException() {
        override val message
            get() = ""
    }
    
    /**
     * Unable to set trick PIN, because biometrics is enabled
     */
    class BiometricsEnabled(
        ) : TrickPinException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<TrickPinException> {
        override fun lift(error_buf: RustBuffer.ByValue): TrickPinException = FfiConverterTypeTrickPinError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeTrickPinError : FfiConverterRustBuffer<TrickPinException> {
    override fun read(buf: ByteBuffer): TrickPinException {
        

        return when(buf.getInt()) {
            1 -> TrickPinException.PinNotEnabled()
            2 -> TrickPinException.SameAsCurrentPin()
            3 -> TrickPinException.SameAsAnotherPin()
            4 -> TrickPinException.BiometricsEnabled()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TrickPinException): ULong {
        return when(value) {
            is TrickPinException.PinNotEnabled -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is TrickPinException.SameAsCurrentPin -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is TrickPinException.SameAsAnotherPin -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is TrickPinException.BiometricsEnabled -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: TrickPinException, buf: ByteBuffer) {
        when(value) {
            is TrickPinException.PinNotEnabled -> {
                buf.putInt(1)
                Unit
            }
            is TrickPinException.SameAsCurrentPin -> {
                buf.putInt(2)
                Unit
            }
            is TrickPinException.SameAsAnotherPin -> {
                buf.putInt(3)
                Unit
            }
            is TrickPinException.BiometricsEnabled -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class UnsignedTransactionsTableException: kotlin.Exception() {
    
    class Save(
        
        val v1: kotlin.String
        ) : UnsignedTransactionsTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Read(
        
        val v1: kotlin.String
        ) : UnsignedTransactionsTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NoRecordFound(
        ) : UnsignedTransactionsTableException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<UnsignedTransactionsTableException> {
        override fun lift(error_buf: RustBuffer.ByValue): UnsignedTransactionsTableException = FfiConverterTypeUnsignedTransactionsTableError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeUnsignedTransactionsTableError : FfiConverterRustBuffer<UnsignedTransactionsTableException> {
    override fun read(buf: ByteBuffer): UnsignedTransactionsTableException {
        

        return when(buf.getInt()) {
            1 -> UnsignedTransactionsTableException.Save(
                FfiConverterString.read(buf),
                )
            2 -> UnsignedTransactionsTableException.Read(
                FfiConverterString.read(buf),
                )
            3 -> UnsignedTransactionsTableException.NoRecordFound()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: UnsignedTransactionsTableException): ULong {
        return when(value) {
            is UnsignedTransactionsTableException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is UnsignedTransactionsTableException.Read -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is UnsignedTransactionsTableException.NoRecordFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: UnsignedTransactionsTableException, buf: ByteBuffer) {
        when(value) {
            is UnsignedTransactionsTableException.Save -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is UnsignedTransactionsTableException.Read -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is UnsignedTransactionsTableException.NoRecordFound -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class WalletAddressType {
    
    NATIVE_SEGWIT,
    WRAPPED_SEGWIT,
    LEGACY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletAddressType: FfiConverterRustBuffer<WalletAddressType> {
    override fun read(buf: ByteBuffer) = try {
        WalletAddressType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: WalletAddressType) = 4UL

    override fun write(value: WalletAddressType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





sealed class WalletColor {
    
    object Red : WalletColor()
    
    
    object Blue : WalletColor()
    
    
    object Green : WalletColor()
    
    
    object Yellow : WalletColor()
    
    
    object Orange : WalletColor()
    
    
    object Purple : WalletColor()
    
    
    object Pink : WalletColor()
    
    
    object CoolGray : WalletColor()
    
    
    data class Custom(
        val `r`: kotlin.UByte, 
        val `g`: kotlin.UByte, 
        val `b`: kotlin.UByte) : WalletColor()
        
    {
        

        companion object
    }
    
    object WAlmostGray : WalletColor()
    
    
    object WAlmostWhite : WalletColor()
    
    
    object WBeige : WalletColor()
    
    
    object WPastelBlue : WalletColor()
    
    
    object WPastelNavy : WalletColor()
    
    
    object WPastelRed : WalletColor()
    
    
    object WPastelYellow : WalletColor()
    
    
    object WLightMint : WalletColor()
    
    
    object WPastelTeal : WalletColor()
    
    
    object WLightPastelYellow : WalletColor()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletColor : FfiConverterRustBuffer<WalletColor>{
    override fun read(buf: ByteBuffer): WalletColor {
        return when(buf.getInt()) {
            1 -> WalletColor.Red
            2 -> WalletColor.Blue
            3 -> WalletColor.Green
            4 -> WalletColor.Yellow
            5 -> WalletColor.Orange
            6 -> WalletColor.Purple
            7 -> WalletColor.Pink
            8 -> WalletColor.CoolGray
            9 -> WalletColor.Custom(
                FfiConverterUByte.read(buf),
                FfiConverterUByte.read(buf),
                FfiConverterUByte.read(buf),
                )
            10 -> WalletColor.WAlmostGray
            11 -> WalletColor.WAlmostWhite
            12 -> WalletColor.WBeige
            13 -> WalletColor.WPastelBlue
            14 -> WalletColor.WPastelNavy
            15 -> WalletColor.WPastelRed
            16 -> WalletColor.WPastelYellow
            17 -> WalletColor.WLightMint
            18 -> WalletColor.WPastelTeal
            19 -> WalletColor.WLightPastelYellow
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletColor) = when(value) {
        is WalletColor.Red -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Blue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Green -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Yellow -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Orange -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Purple -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Pink -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.CoolGray -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUByte.allocationSize(value.`r`)
                + FfiConverterUByte.allocationSize(value.`g`)
                + FfiConverterUByte.allocationSize(value.`b`)
            )
        }
        is WalletColor.WAlmostGray -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WAlmostWhite -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WBeige -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WPastelBlue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WPastelNavy -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WPastelRed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WPastelYellow -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WLightMint -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WPastelTeal -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletColor.WLightPastelYellow -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: WalletColor, buf: ByteBuffer) {
        when(value) {
            is WalletColor.Red -> {
                buf.putInt(1)
                Unit
            }
            is WalletColor.Blue -> {
                buf.putInt(2)
                Unit
            }
            is WalletColor.Green -> {
                buf.putInt(3)
                Unit
            }
            is WalletColor.Yellow -> {
                buf.putInt(4)
                Unit
            }
            is WalletColor.Orange -> {
                buf.putInt(5)
                Unit
            }
            is WalletColor.Purple -> {
                buf.putInt(6)
                Unit
            }
            is WalletColor.Pink -> {
                buf.putInt(7)
                Unit
            }
            is WalletColor.CoolGray -> {
                buf.putInt(8)
                Unit
            }
            is WalletColor.Custom -> {
                buf.putInt(9)
                FfiConverterUByte.write(value.`r`, buf)
                FfiConverterUByte.write(value.`g`, buf)
                FfiConverterUByte.write(value.`b`, buf)
                Unit
            }
            is WalletColor.WAlmostGray -> {
                buf.putInt(10)
                Unit
            }
            is WalletColor.WAlmostWhite -> {
                buf.putInt(11)
                Unit
            }
            is WalletColor.WBeige -> {
                buf.putInt(12)
                Unit
            }
            is WalletColor.WPastelBlue -> {
                buf.putInt(13)
                Unit
            }
            is WalletColor.WPastelNavy -> {
                buf.putInt(14)
                Unit
            }
            is WalletColor.WPastelRed -> {
                buf.putInt(15)
                Unit
            }
            is WalletColor.WPastelYellow -> {
                buf.putInt(16)
                Unit
            }
            is WalletColor.WLightMint -> {
                buf.putInt(17)
                Unit
            }
            is WalletColor.WPastelTeal -> {
                buf.putInt(18)
                Unit
            }
            is WalletColor.WLightPastelYellow -> {
                buf.putInt(19)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class WalletCreationException: kotlin.Exception() {
    
    class Bdk(
        
        val v1: kotlin.String
        ) : WalletCreationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Keychain(
        
        val v1: KeychainException
        ) : WalletCreationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Database(
        
        val v1: DatabaseException
        ) : WalletCreationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Persist(
        
        val v1: kotlin.String
        ) : WalletCreationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Import(
        
        val v1: kotlin.String
        ) : WalletCreationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MultiFormat(
        
        val v1: MultiFormatException
        ) : WalletCreationException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WalletCreationException> {
        override fun lift(error_buf: RustBuffer.ByValue): WalletCreationException = FfiConverterTypeWalletCreationError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletCreationError : FfiConverterRustBuffer<WalletCreationException> {
    override fun read(buf: ByteBuffer): WalletCreationException {
        

        return when(buf.getInt()) {
            1 -> WalletCreationException.Bdk(
                FfiConverterString.read(buf),
                )
            2 -> WalletCreationException.Keychain(
                FfiConverterTypeKeychainError.read(buf),
                )
            3 -> WalletCreationException.Database(
                FfiConverterTypeDatabaseError.read(buf),
                )
            4 -> WalletCreationException.Persist(
                FfiConverterString.read(buf),
                )
            5 -> WalletCreationException.Import(
                FfiConverterString.read(buf),
                )
            6 -> WalletCreationException.MultiFormat(
                FfiConverterTypeMultiFormatError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletCreationException): ULong {
        return when(value) {
            is WalletCreationException.Bdk -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletCreationException.Keychain -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeKeychainError.allocationSize(value.v1)
            )
            is WalletCreationException.Database -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is WalletCreationException.Persist -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletCreationException.Import -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletCreationException.MultiFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeMultiFormatError.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletCreationException, buf: ByteBuffer) {
        when(value) {
            is WalletCreationException.Bdk -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletCreationException.Keychain -> {
                buf.putInt(2)
                FfiConverterTypeKeychainError.write(value.v1, buf)
                Unit
            }
            is WalletCreationException.Database -> {
                buf.putInt(3)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is WalletCreationException.Persist -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletCreationException.Import -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletCreationException.MultiFormat -> {
                buf.putInt(6)
                FfiConverterTypeMultiFormatError.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class WalletDataException: kotlin.Exception() {
    
    class DatabaseAccess(
        
        val `id`: WalletId, 
        
        val `error`: kotlin.String
        ) : WalletDataException() {
        override val message
            get() = "id=${ `id` }, error=${ `error` }"
    }
    
    class TableAccess(
        
        val `id`: WalletId, 
        
        val `error`: kotlin.String
        ) : WalletDataException() {
        override val message
            get() = "id=${ `id` }, error=${ `error` }"
    }
    
    class Read(
        
        val v1: kotlin.String
        ) : WalletDataException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Save(
        
        val v1: kotlin.String
        ) : WalletDataException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WalletDataException> {
        override fun lift(error_buf: RustBuffer.ByValue): WalletDataException = FfiConverterTypeWalletDataError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletDataError : FfiConverterRustBuffer<WalletDataException> {
    override fun read(buf: ByteBuffer): WalletDataException {
        

        return when(buf.getInt()) {
            1 -> WalletDataException.DatabaseAccess(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> WalletDataException.TableAccess(
                FfiConverterTypeWalletId.read(buf),
                FfiConverterString.read(buf),
                )
            3 -> WalletDataException.Read(
                FfiConverterString.read(buf),
                )
            4 -> WalletDataException.Save(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletDataException): ULong {
        return when(value) {
            is WalletDataException.DatabaseAccess -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterString.allocationSize(value.`error`)
            )
            is WalletDataException.TableAccess -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.`id`)
                + FfiConverterString.allocationSize(value.`error`)
            )
            is WalletDataException.Read -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletDataException.Save -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletDataException, buf: ByteBuffer) {
        when(value) {
            is WalletDataException.DatabaseAccess -> {
                buf.putInt(1)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is WalletDataException.TableAccess -> {
                buf.putInt(2)
                FfiConverterTypeWalletId.write(value.`id`, buf)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is WalletDataException.Read -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletDataException.Save -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class WalletDataKey {
    
    data class ScanState(
        val v1: WalletAddressType) : WalletDataKey()
        
    {
        

        companion object
    }
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletDataKey : FfiConverterRustBuffer<WalletDataKey>{
    override fun read(buf: ByteBuffer): WalletDataKey {
        return when(buf.getInt()) {
            1 -> WalletDataKey.ScanState(
                FfiConverterTypeWalletAddressType.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletDataKey) = when(value) {
        is WalletDataKey.ScanState -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletAddressType.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletDataKey, buf: ByteBuffer) {
        when(value) {
            is WalletDataKey.ScanState -> {
                buf.putInt(1)
                FfiConverterTypeWalletAddressType.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class WalletException: kotlin.Exception() {
    
    class BdkException(
        
        val v1: kotlin.String
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnsupportedWallet(
        
        val v1: kotlin.String
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class PersistException(
        
        val v1: kotlin.String
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class LoadException(
        
        val v1: kotlin.String
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Keychain(
        
        val v1: KeychainException
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Database(
        
        val v1: DatabaseException
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletNotFound(
        ) : WalletException() {
        override val message
            get() = ""
    }
    
    class MetadataNotFound(
        ) : WalletException() {
        override val message
            get() = ""
    }
    
    class ParseXpubException(
        
        val v1: XpubException
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletAlreadyExists(
        
        val v1: WalletId
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MultiFormat(
        
        val v1: MultiFormatException
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class DescriptorKeyParseException(
        
        val v1: kotlin.String
        ) : WalletException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WalletException> {
        override fun lift(error_buf: RustBuffer.ByValue): WalletException = FfiConverterTypeWalletError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletError : FfiConverterRustBuffer<WalletException> {
    override fun read(buf: ByteBuffer): WalletException {
        

        return when(buf.getInt()) {
            1 -> WalletException.BdkException(
                FfiConverterString.read(buf),
                )
            2 -> WalletException.UnsupportedWallet(
                FfiConverterString.read(buf),
                )
            3 -> WalletException.PersistException(
                FfiConverterString.read(buf),
                )
            4 -> WalletException.LoadException(
                FfiConverterString.read(buf),
                )
            5 -> WalletException.Keychain(
                FfiConverterTypeKeychainError.read(buf),
                )
            6 -> WalletException.Database(
                FfiConverterTypeDatabaseError.read(buf),
                )
            7 -> WalletException.WalletNotFound()
            8 -> WalletException.MetadataNotFound()
            9 -> WalletException.ParseXpubException(
                FfiConverterTypeXpubError.read(buf),
                )
            10 -> WalletException.WalletAlreadyExists(
                FfiConverterTypeWalletId.read(buf),
                )
            11 -> WalletException.MultiFormat(
                FfiConverterTypeMultiFormatError.read(buf),
                )
            12 -> WalletException.DescriptorKeyParseException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletException): ULong {
        return when(value) {
            is WalletException.BdkException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletException.UnsupportedWallet -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletException.PersistException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletException.LoadException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletException.Keychain -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeKeychainError.allocationSize(value.v1)
            )
            is WalletException.Database -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is WalletException.WalletNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WalletException.MetadataNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WalletException.ParseXpubException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeXpubError.allocationSize(value.v1)
            )
            is WalletException.WalletAlreadyExists -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
            is WalletException.MultiFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeMultiFormatError.allocationSize(value.v1)
            )
            is WalletException.DescriptorKeyParseException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletException, buf: ByteBuffer) {
        when(value) {
            is WalletException.BdkException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletException.UnsupportedWallet -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletException.PersistException -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletException.LoadException -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletException.Keychain -> {
                buf.putInt(5)
                FfiConverterTypeKeychainError.write(value.v1, buf)
                Unit
            }
            is WalletException.Database -> {
                buf.putInt(6)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is WalletException.WalletNotFound -> {
                buf.putInt(7)
                Unit
            }
            is WalletException.MetadataNotFound -> {
                buf.putInt(8)
                Unit
            }
            is WalletException.ParseXpubException -> {
                buf.putInt(9)
                FfiConverterTypeXpubError.write(value.v1, buf)
                Unit
            }
            is WalletException.WalletAlreadyExists -> {
                buf.putInt(10)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
            is WalletException.MultiFormat -> {
                buf.putInt(11)
                FfiConverterTypeMultiFormatError.write(value.v1, buf)
                Unit
            }
            is WalletException.DescriptorKeyParseException -> {
                buf.putInt(12)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class WalletErrorAlert {
    
    data class NodeConnectionFailed(
        val v1: kotlin.String) : WalletErrorAlert()
        
    {
        

        companion object
    }
    
    object NoBalance : WalletErrorAlert()
    
    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletErrorAlert : FfiConverterRustBuffer<WalletErrorAlert>{
    override fun read(buf: ByteBuffer): WalletErrorAlert {
        return when(buf.getInt()) {
            1 -> WalletErrorAlert.NodeConnectionFailed(
                FfiConverterString.read(buf),
                )
            2 -> WalletErrorAlert.NoBalance
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletErrorAlert) = when(value) {
        is WalletErrorAlert.NodeConnectionFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is WalletErrorAlert.NoBalance -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
    }

    override fun write(value: WalletErrorAlert, buf: ByteBuffer) {
        when(value) {
            is WalletErrorAlert.NodeConnectionFailed -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletErrorAlert.NoBalance -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WalletLoadState: Disposable  {
    
    object Loading : WalletLoadState()
    
    
    data class Scanning(
        val v1: List<Transaction>) : WalletLoadState()
        
    {
        

        companion object
    }
    
    data class Loaded(
        val v1: List<Transaction>) : WalletLoadState()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WalletLoadState.Loading -> {// Nothing to destroy
            }
            is WalletLoadState.Scanning -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletLoadState.Loaded -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletLoadState : FfiConverterRustBuffer<WalletLoadState>{
    override fun read(buf: ByteBuffer): WalletLoadState {
        return when(buf.getInt()) {
            1 -> WalletLoadState.Loading
            2 -> WalletLoadState.Scanning(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            3 -> WalletLoadState.Loaded(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletLoadState) = when(value) {
        is WalletLoadState.Loading -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletLoadState.Scanning -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
        is WalletLoadState.Loaded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletLoadState, buf: ByteBuffer) {
        when(value) {
            is WalletLoadState.Loading -> {
                buf.putInt(1)
                Unit
            }
            is WalletLoadState.Scanning -> {
                buf.putInt(2)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
            is WalletLoadState.Loaded -> {
                buf.putInt(3)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class WalletManagerAction: Disposable  {
    
    data class UpdateName(
        val v1: kotlin.String) : WalletManagerAction()
        
    {
        

        companion object
    }
    
    data class UpdateColor(
        val v1: WalletColor) : WalletManagerAction()
        
    {
        

        companion object
    }
    
    data class UpdateUnit(
        val v1: BitcoinUnit) : WalletManagerAction()
        
    {
        

        companion object
    }
    
    data class UpdateFiatOrBtc(
        val v1: FiatOrBtc) : WalletManagerAction()
        
    {
        

        companion object
    }
    
    object ToggleSensitiveVisibility : WalletManagerAction()
    
    
    object ToggleDetailsExpanded : WalletManagerAction()
    
    
    object ToggleFiatOrBtc : WalletManagerAction()
    
    
    object ToggleFiatBtcPrimarySecondary : WalletManagerAction()
    
    
    object ToggleShowLabels : WalletManagerAction()
    
    
    object SelectCurrentWalletAddressType : WalletManagerAction()
    
    
    data class SelectDifferentWalletAddressType(
        val v1: WalletAddressType) : WalletManagerAction()
        
    {
        

        companion object
    }
    
    object SelectedWalletDisappeared : WalletManagerAction()
    
    
    data class StartTransactionWatcher(
        val v1: TxId) : WalletManagerAction()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WalletManagerAction.UpdateName -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerAction.UpdateColor -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerAction.UpdateUnit -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerAction.UpdateFiatOrBtc -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerAction.ToggleSensitiveVisibility -> {// Nothing to destroy
            }
            is WalletManagerAction.ToggleDetailsExpanded -> {// Nothing to destroy
            }
            is WalletManagerAction.ToggleFiatOrBtc -> {// Nothing to destroy
            }
            is WalletManagerAction.ToggleFiatBtcPrimarySecondary -> {// Nothing to destroy
            }
            is WalletManagerAction.ToggleShowLabels -> {// Nothing to destroy
            }
            is WalletManagerAction.SelectCurrentWalletAddressType -> {// Nothing to destroy
            }
            is WalletManagerAction.SelectDifferentWalletAddressType -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerAction.SelectedWalletDisappeared -> {// Nothing to destroy
            }
            is WalletManagerAction.StartTransactionWatcher -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletManagerAction : FfiConverterRustBuffer<WalletManagerAction>{
    override fun read(buf: ByteBuffer): WalletManagerAction {
        return when(buf.getInt()) {
            1 -> WalletManagerAction.UpdateName(
                FfiConverterString.read(buf),
                )
            2 -> WalletManagerAction.UpdateColor(
                FfiConverterTypeWalletColor.read(buf),
                )
            3 -> WalletManagerAction.UpdateUnit(
                FfiConverterTypeBitcoinUnit.read(buf),
                )
            4 -> WalletManagerAction.UpdateFiatOrBtc(
                FfiConverterTypeFiatOrBtc.read(buf),
                )
            5 -> WalletManagerAction.ToggleSensitiveVisibility
            6 -> WalletManagerAction.ToggleDetailsExpanded
            7 -> WalletManagerAction.ToggleFiatOrBtc
            8 -> WalletManagerAction.ToggleFiatBtcPrimarySecondary
            9 -> WalletManagerAction.ToggleShowLabels
            10 -> WalletManagerAction.SelectCurrentWalletAddressType
            11 -> WalletManagerAction.SelectDifferentWalletAddressType(
                FfiConverterTypeWalletAddressType.read(buf),
                )
            12 -> WalletManagerAction.SelectedWalletDisappeared
            13 -> WalletManagerAction.StartTransactionWatcher(
                FfiConverterTypeTxId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletManagerAction) = when(value) {
        is WalletManagerAction.UpdateName -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is WalletManagerAction.UpdateColor -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletColor.allocationSize(value.v1)
            )
        }
        is WalletManagerAction.UpdateUnit -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBitcoinUnit.allocationSize(value.v1)
            )
        }
        is WalletManagerAction.UpdateFiatOrBtc -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFiatOrBtc.allocationSize(value.v1)
            )
        }
        is WalletManagerAction.ToggleSensitiveVisibility -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.ToggleDetailsExpanded -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.ToggleFiatOrBtc -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.ToggleFiatBtcPrimarySecondary -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.ToggleShowLabels -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.SelectCurrentWalletAddressType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.SelectDifferentWalletAddressType -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletAddressType.allocationSize(value.v1)
            )
        }
        is WalletManagerAction.SelectedWalletDisappeared -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerAction.StartTransactionWatcher -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeTxId.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletManagerAction, buf: ByteBuffer) {
        when(value) {
            is WalletManagerAction.UpdateName -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerAction.UpdateColor -> {
                buf.putInt(2)
                FfiConverterTypeWalletColor.write(value.v1, buf)
                Unit
            }
            is WalletManagerAction.UpdateUnit -> {
                buf.putInt(3)
                FfiConverterTypeBitcoinUnit.write(value.v1, buf)
                Unit
            }
            is WalletManagerAction.UpdateFiatOrBtc -> {
                buf.putInt(4)
                FfiConverterTypeFiatOrBtc.write(value.v1, buf)
                Unit
            }
            is WalletManagerAction.ToggleSensitiveVisibility -> {
                buf.putInt(5)
                Unit
            }
            is WalletManagerAction.ToggleDetailsExpanded -> {
                buf.putInt(6)
                Unit
            }
            is WalletManagerAction.ToggleFiatOrBtc -> {
                buf.putInt(7)
                Unit
            }
            is WalletManagerAction.ToggleFiatBtcPrimarySecondary -> {
                buf.putInt(8)
                Unit
            }
            is WalletManagerAction.ToggleShowLabels -> {
                buf.putInt(9)
                Unit
            }
            is WalletManagerAction.SelectCurrentWalletAddressType -> {
                buf.putInt(10)
                Unit
            }
            is WalletManagerAction.SelectDifferentWalletAddressType -> {
                buf.putInt(11)
                FfiConverterTypeWalletAddressType.write(value.v1, buf)
                Unit
            }
            is WalletManagerAction.SelectedWalletDisappeared -> {
                buf.putInt(12)
                Unit
            }
            is WalletManagerAction.StartTransactionWatcher -> {
                buf.putInt(13)
                FfiConverterTypeTxId.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class WalletManagerException: kotlin.Exception() {
    
    class GetSelectedWalletException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletDoesNotExist(
        ) : WalletManagerException() {
        override val message
            get() = ""
    }
    
    class SecretRetrievalException(
        
        val v1: KeychainException
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MarkWalletAsVerifiedException(
        
        val v1: DatabaseException
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class LoadWalletException(
        
        val v1: WalletException
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NodeConnectionFailed(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletScanException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class TransactionsRetrievalException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletBalanceException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NextAddressException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetHeightException(
        ) : WalletManagerException() {
        override val message
            get() = ""
    }
    
    class TransactionDetailsException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ActorNotFound(
        ) : WalletManagerException() {
        override val message
            get() = ""
    }
    
    class UnableToSwitch(
        
        val v1: WalletAddressType, 
        
        val v2: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }, v2=${ v2 }"
    }
    
    class FiatException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class FeesException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class BuildTxException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InsufficientFunds(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetConfirmDetailsException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SignAndBroadcastException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Converter(
        
        val v1: ConverterException
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class UnknownException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class PsbtFinalizeException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class GetHistoricalPricesException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class CsvCreationException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class AddUtxosException(
        
        val v1: kotlin.String
        ) : WalletManagerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WalletManagerException> {
        override fun lift(error_buf: RustBuffer.ByValue): WalletManagerException = FfiConverterTypeWalletManagerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletManagerError : FfiConverterRustBuffer<WalletManagerException> {
    override fun read(buf: ByteBuffer): WalletManagerException {
        

        return when(buf.getInt()) {
            1 -> WalletManagerException.GetSelectedWalletException(
                FfiConverterString.read(buf),
                )
            2 -> WalletManagerException.WalletDoesNotExist()
            3 -> WalletManagerException.SecretRetrievalException(
                FfiConverterTypeKeychainError.read(buf),
                )
            4 -> WalletManagerException.MarkWalletAsVerifiedException(
                FfiConverterTypeDatabaseError.read(buf),
                )
            5 -> WalletManagerException.LoadWalletException(
                FfiConverterTypeWalletError.read(buf),
                )
            6 -> WalletManagerException.NodeConnectionFailed(
                FfiConverterString.read(buf),
                )
            7 -> WalletManagerException.WalletScanException(
                FfiConverterString.read(buf),
                )
            8 -> WalletManagerException.TransactionsRetrievalException(
                FfiConverterString.read(buf),
                )
            9 -> WalletManagerException.WalletBalanceException(
                FfiConverterString.read(buf),
                )
            10 -> WalletManagerException.NextAddressException(
                FfiConverterString.read(buf),
                )
            11 -> WalletManagerException.GetHeightException()
            12 -> WalletManagerException.TransactionDetailsException(
                FfiConverterString.read(buf),
                )
            13 -> WalletManagerException.ActorNotFound()
            14 -> WalletManagerException.UnableToSwitch(
                FfiConverterTypeWalletAddressType.read(buf),
                FfiConverterString.read(buf),
                )
            15 -> WalletManagerException.FiatException(
                FfiConverterString.read(buf),
                )
            16 -> WalletManagerException.FeesException(
                FfiConverterString.read(buf),
                )
            17 -> WalletManagerException.BuildTxException(
                FfiConverterString.read(buf),
                )
            18 -> WalletManagerException.InsufficientFunds(
                FfiConverterString.read(buf),
                )
            19 -> WalletManagerException.GetConfirmDetailsException(
                FfiConverterString.read(buf),
                )
            20 -> WalletManagerException.SignAndBroadcastException(
                FfiConverterString.read(buf),
                )
            21 -> WalletManagerException.Converter(
                FfiConverterTypeConverterError.read(buf),
                )
            22 -> WalletManagerException.UnknownException(
                FfiConverterString.read(buf),
                )
            23 -> WalletManagerException.PsbtFinalizeException(
                FfiConverterString.read(buf),
                )
            24 -> WalletManagerException.GetHistoricalPricesException(
                FfiConverterString.read(buf),
                )
            25 -> WalletManagerException.CsvCreationException(
                FfiConverterString.read(buf),
                )
            26 -> WalletManagerException.AddUtxosException(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletManagerException): ULong {
        return when(value) {
            is WalletManagerException.GetSelectedWalletException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.WalletDoesNotExist -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WalletManagerException.SecretRetrievalException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeKeychainError.allocationSize(value.v1)
            )
            is WalletManagerException.MarkWalletAsVerifiedException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDatabaseError.allocationSize(value.v1)
            )
            is WalletManagerException.LoadWalletException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletError.allocationSize(value.v1)
            )
            is WalletManagerException.NodeConnectionFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.WalletScanException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.TransactionsRetrievalException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.WalletBalanceException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.NextAddressException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.GetHeightException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WalletManagerException.TransactionDetailsException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.ActorNotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WalletManagerException.UnableToSwitch -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletAddressType.allocationSize(value.v1)
                + FfiConverterString.allocationSize(value.v2)
            )
            is WalletManagerException.FiatException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.FeesException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.BuildTxException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.InsufficientFunds -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.GetConfirmDetailsException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.SignAndBroadcastException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.Converter -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeConverterError.allocationSize(value.v1)
            )
            is WalletManagerException.UnknownException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.PsbtFinalizeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.GetHistoricalPricesException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.CsvCreationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletManagerException.AddUtxosException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletManagerException, buf: ByteBuffer) {
        when(value) {
            is WalletManagerException.GetSelectedWalletException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.WalletDoesNotExist -> {
                buf.putInt(2)
                Unit
            }
            is WalletManagerException.SecretRetrievalException -> {
                buf.putInt(3)
                FfiConverterTypeKeychainError.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.MarkWalletAsVerifiedException -> {
                buf.putInt(4)
                FfiConverterTypeDatabaseError.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.LoadWalletException -> {
                buf.putInt(5)
                FfiConverterTypeWalletError.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.NodeConnectionFailed -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.WalletScanException -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.TransactionsRetrievalException -> {
                buf.putInt(8)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.WalletBalanceException -> {
                buf.putInt(9)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.NextAddressException -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.GetHeightException -> {
                buf.putInt(11)
                Unit
            }
            is WalletManagerException.TransactionDetailsException -> {
                buf.putInt(12)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.ActorNotFound -> {
                buf.putInt(13)
                Unit
            }
            is WalletManagerException.UnableToSwitch -> {
                buf.putInt(14)
                FfiConverterTypeWalletAddressType.write(value.v1, buf)
                FfiConverterString.write(value.v2, buf)
                Unit
            }
            is WalletManagerException.FiatException -> {
                buf.putInt(15)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.FeesException -> {
                buf.putInt(16)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.BuildTxException -> {
                buf.putInt(17)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.InsufficientFunds -> {
                buf.putInt(18)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.GetConfirmDetailsException -> {
                buf.putInt(19)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.SignAndBroadcastException -> {
                buf.putInt(20)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.Converter -> {
                buf.putInt(21)
                FfiConverterTypeConverterError.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.UnknownException -> {
                buf.putInt(22)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.PsbtFinalizeException -> {
                buf.putInt(23)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.GetHistoricalPricesException -> {
                buf.putInt(24)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.CsvCreationException -> {
                buf.putInt(25)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerException.AddUtxosException -> {
                buf.putInt(26)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class WalletManagerReconcileMessage: Disposable  {
    
    object StartedInitialFullScan : WalletManagerReconcileMessage()
    
    
    data class StartedExpandedFullScan(
        val v1: List<Transaction>) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class AvailableTransactions(
        val v1: List<Transaction>) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class ScanComplete(
        val v1: List<Transaction>) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UpdatedTransactions(
        val v1: List<Transaction>) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class NodeConnectionFailed(
        val v1: kotlin.String) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class WalletMetadataChanged(
        val v1: WalletMetadata) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class WalletBalanceChanged(
        val v1: Balance) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class WalletException(
        val v1: WalletManagerException) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class UnknownError(
        val v1: kotlin.String) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    data class WalletScannerResponse(
        val v1: ScannerResponse) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    
    object UnsignedTransactionsChanged : WalletManagerReconcileMessage()
    
    
    data class SendFlowException(
        val v1: SendFlowErrorAlert) : WalletManagerReconcileMessage()
        
    {
        

        companion object
    }
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WalletManagerReconcileMessage.StartedInitialFullScan -> {// Nothing to destroy
            }
            is WalletManagerReconcileMessage.StartedExpandedFullScan -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.AvailableTransactions -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.ScanComplete -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.UpdatedTransactions -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.NodeConnectionFailed -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.WalletMetadataChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.WalletBalanceChanged -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.WalletException -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.UnknownError -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.WalletScannerResponse -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
            is WalletManagerReconcileMessage.UnsignedTransactionsChanged -> {// Nothing to destroy
            }
            is WalletManagerReconcileMessage.SendFlowException -> {
                
    Disposable.destroy(
        this.v1
    )
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletManagerReconcileMessage : FfiConverterRustBuffer<WalletManagerReconcileMessage>{
    override fun read(buf: ByteBuffer): WalletManagerReconcileMessage {
        return when(buf.getInt()) {
            1 -> WalletManagerReconcileMessage.StartedInitialFullScan
            2 -> WalletManagerReconcileMessage.StartedExpandedFullScan(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            3 -> WalletManagerReconcileMessage.AvailableTransactions(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            4 -> WalletManagerReconcileMessage.ScanComplete(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            5 -> WalletManagerReconcileMessage.UpdatedTransactions(
                FfiConverterSequenceTypeTransaction.read(buf),
                )
            6 -> WalletManagerReconcileMessage.NodeConnectionFailed(
                FfiConverterString.read(buf),
                )
            7 -> WalletManagerReconcileMessage.WalletMetadataChanged(
                FfiConverterTypeWalletMetadata.read(buf),
                )
            8 -> WalletManagerReconcileMessage.WalletBalanceChanged(
                FfiConverterTypeBalance.read(buf),
                )
            9 -> WalletManagerReconcileMessage.WalletException(
                FfiConverterTypeWalletManagerError.read(buf),
                )
            10 -> WalletManagerReconcileMessage.UnknownError(
                FfiConverterString.read(buf),
                )
            11 -> WalletManagerReconcileMessage.WalletScannerResponse(
                FfiConverterTypeScannerResponse.read(buf),
                )
            12 -> WalletManagerReconcileMessage.UnsignedTransactionsChanged
            13 -> WalletManagerReconcileMessage.SendFlowException(
                FfiConverterTypeSendFlowErrorAlert.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletManagerReconcileMessage) = when(value) {
        is WalletManagerReconcileMessage.StartedInitialFullScan -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerReconcileMessage.StartedExpandedFullScan -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.AvailableTransactions -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.ScanComplete -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.UpdatedTransactions -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterSequenceTypeTransaction.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.NodeConnectionFailed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.WalletMetadataChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletMetadata.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.WalletBalanceChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeBalance.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.WalletException -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeWalletManagerError.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.UnknownError -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.WalletScannerResponse -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeScannerResponse.allocationSize(value.v1)
            )
        }
        is WalletManagerReconcileMessage.UnsignedTransactionsChanged -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is WalletManagerReconcileMessage.SendFlowException -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeSendFlowErrorAlert.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletManagerReconcileMessage, buf: ByteBuffer) {
        when(value) {
            is WalletManagerReconcileMessage.StartedInitialFullScan -> {
                buf.putInt(1)
                Unit
            }
            is WalletManagerReconcileMessage.StartedExpandedFullScan -> {
                buf.putInt(2)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.AvailableTransactions -> {
                buf.putInt(3)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.ScanComplete -> {
                buf.putInt(4)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.UpdatedTransactions -> {
                buf.putInt(5)
                FfiConverterSequenceTypeTransaction.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.NodeConnectionFailed -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.WalletMetadataChanged -> {
                buf.putInt(7)
                FfiConverterTypeWalletMetadata.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.WalletBalanceChanged -> {
                buf.putInt(8)
                FfiConverterTypeBalance.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.WalletException -> {
                buf.putInt(9)
                FfiConverterTypeWalletManagerError.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.UnknownError -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.WalletScannerResponse -> {
                buf.putInt(11)
                FfiConverterTypeScannerResponse.write(value.v1, buf)
                Unit
            }
            is WalletManagerReconcileMessage.UnsignedTransactionsChanged -> {
                buf.putInt(12)
                Unit
            }
            is WalletManagerReconcileMessage.SendFlowException -> {
                buf.putInt(13)
                FfiConverterTypeSendFlowErrorAlert.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class WalletMode {
    
    MAIN,
    DECOY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletMode: FfiConverterRustBuffer<WalletMode> {
    override fun read(buf: ByteBuffer) = try {
        WalletMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: WalletMode) = 4UL

    override fun write(value: WalletMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class WalletScannerException: kotlin.Exception() {
    
    class NoAddressTypes(
        ) : WalletScannerException() {
        override val message
            get() = ""
    }
    
    class WalletCreationException(
        
        val v1: WalletException
        ) : WalletScannerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class NoMnemonicAvailable(
        
        val v1: WalletId
        ) : WalletScannerException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WalletScannerException> {
        override fun lift(error_buf: RustBuffer.ByValue): WalletScannerException = FfiConverterTypeWalletScannerError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletScannerError : FfiConverterRustBuffer<WalletScannerException> {
    override fun read(buf: ByteBuffer): WalletScannerException {
        

        return when(buf.getInt()) {
            1 -> WalletScannerException.NoAddressTypes()
            2 -> WalletScannerException.WalletCreationException(
                FfiConverterTypeWalletError.read(buf),
                )
            3 -> WalletScannerException.NoMnemonicAvailable(
                FfiConverterTypeWalletId.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletScannerException): ULong {
        return when(value) {
            is WalletScannerException.NoAddressTypes -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WalletScannerException.WalletCreationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletError.allocationSize(value.v1)
            )
            is WalletScannerException.NoMnemonicAvailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeWalletId.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: WalletScannerException, buf: ByteBuffer) {
        when(value) {
            is WalletScannerException.NoAddressTypes -> {
                buf.putInt(1)
                Unit
            }
            is WalletScannerException.WalletCreationException -> {
                buf.putInt(2)
                FfiConverterTypeWalletError.write(value.v1, buf)
                Unit
            }
            is WalletScannerException.NoMnemonicAvailable -> {
                buf.putInt(3)
                FfiConverterTypeWalletId.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class WalletSettingsRoute {
    
    MAIN,
    CHANGE_NAME;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletSettingsRoute: FfiConverterRustBuffer<WalletSettingsRoute> {
    override fun read(buf: ByteBuffer) = try {
        WalletSettingsRoute.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: WalletSettingsRoute) = 4UL

    override fun write(value: WalletSettingsRoute, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class WalletTableException: kotlin.Exception() {
    
    class SaveException(
        
        val v1: kotlin.String
        ) : WalletTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ReadException(
        
        val v1: kotlin.String
        ) : WalletTableException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class WalletAlreadyExists(
        ) : WalletTableException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WalletTableException> {
        override fun lift(error_buf: RustBuffer.ByValue): WalletTableException = FfiConverterTypeWalletTableError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeWalletTableError : FfiConverterRustBuffer<WalletTableException> {
    override fun read(buf: ByteBuffer): WalletTableException {
        

        return when(buf.getInt()) {
            1 -> WalletTableException.SaveException(
                FfiConverterString.read(buf),
                )
            2 -> WalletTableException.ReadException(
                FfiConverterString.read(buf),
                )
            3 -> WalletTableException.WalletAlreadyExists()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WalletTableException): ULong {
        return when(value) {
            is WalletTableException.SaveException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletTableException.ReadException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is WalletTableException.WalletAlreadyExists -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: WalletTableException, buf: ByteBuffer) {
        when(value) {
            is WalletTableException.SaveException -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletTableException.ReadException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is WalletTableException.WalletAlreadyExists -> {
                buf.putInt(3)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class WalletType {
    
    HOT,
    COLD,
    XPUB_ONLY,
    /**
     * deprecated, use XpubOnly instead
     */
    WATCH_ONLY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeWalletType: FfiConverterRustBuffer<WalletType> {
    override fun read(buf: ByteBuffer) = try {
        WalletType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: WalletType) = 4UL

    override fun write(value: WalletType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class XpubException: kotlin.Exception() {
    
    class InvalidDescriptor(
        
        val v1: DescriptorException
        ) : XpubException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidJson(
        
        val v1: kotlin.String
        ) : XpubException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidDescriptorInJson(
        ) : XpubException() {
        override val message
            get() = ""
    }
    
    class JsonNoDecriptor(
        ) : XpubException() {
        override val message
            get() = ""
    }
    
    class MissingXpub(
        
        val v1: kotlin.String
        ) : XpubException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidXpub(
        
        val v1: kotlin.String
        ) : XpubException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<XpubException> {
        override fun lift(error_buf: RustBuffer.ByValue): XpubException = FfiConverterTypeXpubError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeXpubError : FfiConverterRustBuffer<XpubException> {
    override fun read(buf: ByteBuffer): XpubException {
        

        return when(buf.getInt()) {
            1 -> XpubException.InvalidDescriptor(
                FfiConverterTypeDescriptorError.read(buf),
                )
            2 -> XpubException.InvalidJson(
                FfiConverterString.read(buf),
                )
            3 -> XpubException.InvalidDescriptorInJson()
            4 -> XpubException.JsonNoDecriptor()
            5 -> XpubException.MissingXpub(
                FfiConverterString.read(buf),
                )
            6 -> XpubException.InvalidXpub(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: XpubException): ULong {
        return when(value) {
            is XpubException.InvalidDescriptor -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeDescriptorError.allocationSize(value.v1)
            )
            is XpubException.InvalidJson -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is XpubException.InvalidDescriptorInJson -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is XpubException.JsonNoDecriptor -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is XpubException.MissingXpub -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is XpubException.InvalidXpub -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: XpubException, buf: ByteBuffer) {
        when(value) {
            is XpubException.InvalidDescriptor -> {
                buf.putInt(1)
                FfiConverterTypeDescriptorError.write(value.v1, buf)
                Unit
            }
            is XpubException.InvalidJson -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is XpubException.InvalidDescriptorInJson -> {
                buf.putInt(3)
                Unit
            }
            is XpubException.JsonNoDecriptor -> {
                buf.putInt(4)
                Unit
            }
            is XpubException.MissingXpub -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is XpubException.InvalidXpub -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





public interface AuthManagerReconciler {
    
    /**
     * Tells the frontend to reconcile the manager changes
     */
    fun `reconcile`(`message`: AuthManagerReconcileMessage)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceAuthManagerReconciler {
    internal object `reconcile`: UniffiCallbackInterfaceAuthManagerReconcilerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeAuthManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypeAuthManagerReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeAuthManagerReconciler.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeAuthManagerReconciler.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceAuthManagerReconciler.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_authmanagerreconciler(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeAuthManagerReconciler: FfiConverterCallbackInterface<AuthManagerReconciler>()





public interface CoinControlManagerReconciler {
    
    /**
     * Tells the frontend to reconcile the manager changes
     */
    fun `reconcile`(`message`: CoinControlManagerReconcileMessage)
    
    fun `reconcileMany`(`messages`: List<CoinControlManagerReconcileMessage>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceCoinControlManagerReconciler {
    internal object `reconcile`: UniffiCallbackInterfaceCoinControlManagerReconcilerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeCoinControlManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypeCoinControlManagerReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `reconcileMany`: UniffiCallbackInterfaceCoinControlManagerReconcilerMethod1 {
        override fun callback(`uniffiHandle`: Long,`messages`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeCoinControlManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcileMany`(
                    FfiConverterSequenceTypeCoinControlManagerReconcileMessage.lift(`messages`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeCoinControlManagerReconciler.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeCoinControlManagerReconciler.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceCoinControlManagerReconciler.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
        `reconcileMany`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_coincontrolmanagerreconciler(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeCoinControlManagerReconciler: FfiConverterCallbackInterface<CoinControlManagerReconciler>()





public interface FfiReconcile {
    
    /**
     * Essentially a callback to the frontend
     */
    fun `reconcile`(`message`: AppStateReconcileMessage)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceFfiReconcile {
    internal object `reconcile`: UniffiCallbackInterfaceFfiReconcileMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeFfiReconcile.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypeAppStateReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeFfiReconcile.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeFfiReconcile.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceFfiReconcile.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_ffireconcile(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeFfiReconcile: FfiConverterCallbackInterface<FfiReconcile>()





public interface ImportWalletManagerReconciler {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    fun `reconcile`(`message`: ImportWalletManagerReconcileMessage)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceImportWalletManagerReconciler {
    internal object `reconcile`: UniffiCallbackInterfaceImportWalletManagerReconcilerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeImportWalletManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypeImportWalletManagerReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeImportWalletManagerReconciler.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeImportWalletManagerReconciler.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceImportWalletManagerReconciler.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_importwalletmanagerreconciler(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeImportWalletManagerReconciler: FfiConverterCallbackInterface<ImportWalletManagerReconciler>()





public interface PendingWalletManagerReconciler {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    fun `reconcile`(`message`: PendingWalletManagerReconcileMessage)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfacePendingWalletManagerReconciler {
    internal object `reconcile`: UniffiCallbackInterfacePendingWalletManagerReconcilerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypePendingWalletManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypePendingWalletManagerReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypePendingWalletManagerReconciler.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypePendingWalletManagerReconciler.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfacePendingWalletManagerReconciler.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_pendingwalletmanagerreconciler(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypePendingWalletManagerReconciler: FfiConverterCallbackInterface<PendingWalletManagerReconciler>()





public interface SendFlowManagerReconciler {
    
    /**
     * tells the frontend to reconcile the manager changes
     */
    fun `reconcile`(`message`: SendFlowManagerReconcileMessage)
    
    fun `reconcileMany`(`messages`: List<SendFlowManagerReconcileMessage>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceSendFlowManagerReconciler {
    internal object `reconcile`: UniffiCallbackInterfaceSendFlowManagerReconcilerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSendFlowManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypeSendFlowManagerReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `reconcileMany`: UniffiCallbackInterfaceSendFlowManagerReconcilerMethod1 {
        override fun callback(`uniffiHandle`: Long,`messages`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeSendFlowManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcileMany`(
                    FfiConverterSequenceTypeSendFlowManagerReconcileMessage.lift(`messages`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeSendFlowManagerReconciler.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeSendFlowManagerReconciler.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceSendFlowManagerReconciler.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
        `reconcileMany`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_sendflowmanagerreconciler(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeSendFlowManagerReconciler: FfiConverterCallbackInterface<SendFlowManagerReconciler>()





public interface TapcardTransportProtocol {
    
    fun `setMessage`(`message`: kotlin.String)
    
    fun `appendMessage`(`message`: kotlin.String)
    
    suspend fun `transmitApdu`(`commandApdu`: kotlin.ByteArray): kotlin.ByteArray
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceTapcardTransportProtocol {
    internal object `setMessage`: UniffiCallbackInterfaceTapcardTransportProtocolMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeTapcardTransportProtocol.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`setMessage`(
                    FfiConverterString.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `appendMessage`: UniffiCallbackInterfaceTapcardTransportProtocolMethod1 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeTapcardTransportProtocol.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`appendMessage`(
                    FfiConverterString.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `transmitApdu`: UniffiCallbackInterfaceTapcardTransportProtocolMethod2 {
        override fun callback(`uniffiHandle`: Long,`commandApdu`: RustBuffer.ByValue,`uniffiFutureCallback`: UniffiForeignFutureCompleteRustBuffer,`uniffiCallbackData`: Long,`uniffiOutDroppedCallback`: UniffiForeignFutureDroppedCallbackStruct,) {
            val uniffiObj = FfiConverterTypeTapcardTransportProtocol.handleMap.get(uniffiHandle)
            val makeCall = suspend { ->
                uniffiObj.`transmitApdu`(
                    FfiConverterByteArray.lift(`commandApdu`),
                )
            }
            val uniffiHandleSuccess = { returnValue: kotlin.ByteArray ->
                val uniffiResult = UniffiForeignFutureResultRustBuffer.UniffiByValue(
                    FfiConverterByteArray.lower(returnValue),
                    UniffiRustCallStatus.ByValue()
                )
                uniffiResult.write()
                uniffiFutureCallback.callback(uniffiCallbackData, uniffiResult)
            }
            val uniffiHandleError = { callStatus: UniffiRustCallStatus.ByValue ->
                uniffiFutureCallback.callback(
                    uniffiCallbackData,
                    UniffiForeignFutureResultRustBuffer.UniffiByValue(
                        RustBuffer.ByValue(),
                        callStatus,
                    ),
                )
            }
            uniffiTraitInterfaceCallAsyncWithError(
                makeCall,
                uniffiHandleSuccess,
                uniffiHandleError,
                { e: TransportException -> FfiConverterTypeTransportError.lower(e) },
                uniffiOutDroppedCallback
            )
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeTapcardTransportProtocol.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeTapcardTransportProtocol.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceTapcardTransportProtocol.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `setMessage`,
        `appendMessage`,
        `transmitApdu`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_tapcardtransportprotocol(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeTapcardTransportProtocol: FfiConverterCallbackInterface<TapcardTransportProtocol>()





public interface WalletManagerReconciler {
    
    fun `reconcile`(`message`: WalletManagerReconcileMessage)
    
    fun `reconcileMany`(`messages`: List<WalletManagerReconcileMessage>)
    
    companion object
}



// Put the implementation in an object so we don't pollute the top-level namespace
internal object uniffiCallbackInterfaceWalletManagerReconciler {
    internal object `reconcile`: UniffiCallbackInterfaceWalletManagerReconcilerMethod0 {
        override fun callback(`uniffiHandle`: Long,`message`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeWalletManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcile`(
                    FfiConverterTypeWalletManagerReconcileMessage.lift(`message`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }
    internal object `reconcileMany`: UniffiCallbackInterfaceWalletManagerReconcilerMethod1 {
        override fun callback(`uniffiHandle`: Long,`messages`: RustBuffer.ByValue,`uniffiOutReturn`: Pointer,uniffiCallStatus: UniffiRustCallStatus,) {
            val uniffiObj = FfiConverterTypeWalletManagerReconciler.handleMap.get(uniffiHandle)
            val makeCall = { ->
                uniffiObj.`reconcileMany`(
                    FfiConverterSequenceTypeWalletManagerReconcileMessage.lift(`messages`),
                )
            }
            val writeReturn = { _: Unit -> Unit }
            uniffiTraitInterfaceCall(uniffiCallStatus, makeCall, writeReturn)
        }
    }

    internal object uniffiFree: UniffiCallbackInterfaceFree {
        override fun callback(handle: Long) {
            FfiConverterTypeWalletManagerReconciler.handleMap.remove(handle)
        }
    }

    internal object uniffiClone: UniffiCallbackInterfaceClone {
        override fun callback(handle: Long): Long {
            return FfiConverterTypeWalletManagerReconciler.handleMap.clone(handle)
        }
    }

    internal var vtable = UniffiVTableCallbackInterfaceWalletManagerReconciler.UniffiByValue(
        uniffiFree,
        uniffiClone,
        `reconcile`,
        `reconcileMany`,
    )

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal fun register(lib: UniffiLib) {
        lib.uniffi_cove_fn_init_callback_vtable_walletmanagerreconciler(vtable)
    }
}

/**
 * The ffiConverter which transforms the Callbacks in to handles to pass to Rust.
 *
 * @suppress
 */
public object FfiConverterTypeWalletManagerReconciler: FfiConverterCallbackInterface<WalletManagerReconciler>()




/**
 * @suppress
 */
public object FfiConverterOptionalUInt: FfiConverterRustBuffer<kotlin.UInt?> {
    override fun read(buf: ByteBuffer): kotlin.UInt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUInt.read(buf)
    }

    override fun allocationSize(value: kotlin.UInt?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterUInt.allocationSize(value)
        }
    }

    override fun write(value: kotlin.UInt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUInt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalULong: FfiConverterRustBuffer<kotlin.ULong?> {
    override fun read(buf: ByteBuffer): kotlin.ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: kotlin.ULong?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalFloat: FfiConverterRustBuffer<kotlin.Float?> {
    override fun read(buf: ByteBuffer): kotlin.Float? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterFloat.read(buf)
    }

    override fun allocationSize(value: kotlin.Float?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterFloat.allocationSize(value)
        }
    }

    override fun write(value: kotlin.Float?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterFloat.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalByteArray: FfiConverterRustBuffer<kotlin.ByteArray?> {
    override fun read(buf: ByteBuffer): kotlin.ByteArray? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterByteArray.read(buf)
    }

    override fun allocationSize(value: kotlin.ByteArray?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterByteArray.allocationSize(value)
        }
    }

    override fun write(value: kotlin.ByteArray?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterByteArray.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalDuration: FfiConverterRustBuffer<java.time.Duration?> {
    override fun read(buf: ByteBuffer): java.time.Duration? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterDuration.read(buf)
    }

    override fun allocationSize(value: java.time.Duration?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterDuration.allocationSize(value)
        }
    }

    override fun write(value: java.time.Duration?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterDuration.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeBitcoinTransaction: FfiConverterRustBuffer<BitcoinTransaction?> {
    override fun read(buf: ByteBuffer): BitcoinTransaction? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeBitcoinTransaction.read(buf)
    }

    override fun allocationSize(value: BitcoinTransaction?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeBitcoinTransaction.allocationSize(value)
        }
    }

    override fun write(value: BitcoinTransaction?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeBitcoinTransaction.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFingerprint: FfiConverterRustBuffer<Fingerprint?> {
    override fun read(buf: ByteBuffer): Fingerprint? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFingerprint.read(buf)
    }

    override fun allocationSize(value: Fingerprint?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFingerprint.allocationSize(value)
        }
    }

    override fun write(value: Fingerprint?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFingerprint.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUnsignedTransactionRecord: FfiConverterRustBuffer<UnsignedTransactionRecord?> {
    override fun read(buf: ByteBuffer): UnsignedTransactionRecord? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUnsignedTransactionRecord.read(buf)
    }

    override fun allocationSize(value: UnsignedTransactionRecord?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUnsignedTransactionRecord.allocationSize(value)
        }
    }

    override fun write(value: UnsignedTransactionRecord?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUnsignedTransactionRecord.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAddress: FfiConverterRustBuffer<Address?> {
    override fun read(buf: ByteBuffer): Address? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAddress.read(buf)
    }

    override fun allocationSize(value: Address?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAddress.allocationSize(value)
        }
    }

    override fun write(value: Address?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAddress.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAmount: FfiConverterRustBuffer<Amount?> {
    override fun read(buf: ByteBuffer): Amount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAmount.read(buf)
    }

    override fun allocationSize(value: Amount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAmount.allocationSize(value)
        }
    }

    override fun write(value: Amount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAmount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypePsbt: FfiConverterRustBuffer<Psbt?> {
    override fun read(buf: ByteBuffer): Psbt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePsbt.read(buf)
    }

    override fun allocationSize(value: Psbt?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePsbt.allocationSize(value)
        }
    }

    override fun write(value: Psbt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePsbt.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeDeriveInfo: FfiConverterRustBuffer<DeriveInfo?> {
    override fun read(buf: ByteBuffer): DeriveInfo? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDeriveInfo.read(buf)
    }

    override fun allocationSize(value: DeriveInfo?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeDeriveInfo.allocationSize(value)
        }
    }

    override fun write(value: DeriveInfo?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDeriveInfo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFeeResponse: FfiConverterRustBuffer<FeeResponse?> {
    override fun read(buf: ByteBuffer): FeeResponse? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFeeResponse.read(buf)
    }

    override fun allocationSize(value: FeeResponse?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFeeResponse.allocationSize(value)
        }
    }

    override fun write(value: FeeResponse?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFeeResponse.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFiatAmount: FfiConverterRustBuffer<FiatAmount?> {
    override fun read(buf: ByteBuffer): FiatAmount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFiatAmount.read(buf)
    }

    override fun allocationSize(value: FiatAmount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFiatAmount.allocationSize(value)
        }
    }

    override fun write(value: FiatAmount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFiatAmount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeWalletMetadata: FfiConverterRustBuffer<WalletMetadata?> {
    override fun read(buf: ByteBuffer): WalletMetadata? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeWalletMetadata.read(buf)
    }

    override fun allocationSize(value: WalletMetadata?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeWalletMetadata.allocationSize(value)
        }
    }

    override fun write(value: WalletMetadata?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeWalletMetadata.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAddressIndex: FfiConverterRustBuffer<AddressIndex?> {
    override fun read(buf: ByteBuffer): AddressIndex? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAddressIndex.read(buf)
    }

    override fun allocationSize(value: AddressIndex?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAddressIndex.allocationSize(value)
        }
    }

    override fun write(value: AddressIndex?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAddressIndex.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeBlockSizeLast: FfiConverterRustBuffer<BlockSizeLast?> {
    override fun read(buf: ByteBuffer): BlockSizeLast? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeBlockSizeLast.read(buf)
    }

    override fun allocationSize(value: BlockSizeLast?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeBlockSizeLast.allocationSize(value)
        }
    }

    override fun write(value: BlockSizeLast?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeBlockSizeLast.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeHardwareWalletMetadata: FfiConverterRustBuffer<HardwareWalletMetadata?> {
    override fun read(buf: ByteBuffer): HardwareWalletMetadata? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeHardwareWalletMetadata.read(buf)
    }

    override fun allocationSize(value: HardwareWalletMetadata?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeHardwareWalletMetadata.allocationSize(value)
        }
    }

    override fun write(value: HardwareWalletMetadata?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeHardwareWalletMetadata.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeNumberOfBip39Words: FfiConverterRustBuffer<NumberOfBip39Words?> {
    override fun read(buf: ByteBuffer): NumberOfBip39Words? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeNumberOfBip39Words.read(buf)
    }

    override fun allocationSize(value: NumberOfBip39Words?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeNumberOfBip39Words.allocationSize(value)
        }
    }

    override fun write(value: NumberOfBip39Words?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeNumberOfBip39Words.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeRoute: FfiConverterRustBuffer<Route?> {
    override fun read(buf: ByteBuffer): Route? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeRoute.read(buf)
    }

    override fun allocationSize(value: Route?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeRoute.allocationSize(value)
        }
    }

    override fun write(value: Route?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeRoute.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSetAmountFocusField: FfiConverterRustBuffer<SetAmountFocusField?> {
    override fun read(buf: ByteBuffer): SetAmountFocusField? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSetAmountFocusField.read(buf)
    }

    override fun allocationSize(value: SetAmountFocusField?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSetAmountFocusField.allocationSize(value)
        }
    }

    override fun write(value: SetAmountFocusField?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSetAmountFocusField.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeSetupCmdResponse: FfiConverterRustBuffer<SetupCmdResponse?> {
    override fun read(buf: ByteBuffer): SetupCmdResponse? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSetupCmdResponse.read(buf)
    }

    override fun allocationSize(value: SetupCmdResponse?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeSetupCmdResponse.allocationSize(value)
        }
    }

    override fun write(value: SetupCmdResponse?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSetupCmdResponse.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeTapSignerCmd: FfiConverterRustBuffer<TapSignerCmd?> {
    override fun read(buf: ByteBuffer): TapSignerCmd? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTapSignerCmd.read(buf)
    }

    override fun allocationSize(value: TapSignerCmd?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTapSignerCmd.allocationSize(value)
        }
    }

    override fun write(value: TapSignerCmd?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTapSignerCmd.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeTapSignerResponse: FfiConverterRustBuffer<TapSignerResponse?> {
    override fun read(buf: ByteBuffer): TapSignerResponse? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTapSignerResponse.read(buf)
    }

    override fun allocationSize(value: TapSignerResponse?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeTapSignerResponse.allocationSize(value)
        }
    }

    override fun write(value: TapSignerResponse?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTapSignerResponse.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeUtxo: FfiConverterRustBuffer<List<Utxo>?> {
    override fun read(buf: ByteBuffer): List<Utxo>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceTypeUtxo.read(buf)
    }

    override fun allocationSize(value: List<Utxo>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceTypeUtxo.allocationSize(value)
        }
    }

    override fun write(value: List<Utxo>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceTypeUtxo.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalSequenceSequenceString: FfiConverterRustBuffer<List<List<kotlin.String>>?> {
    override fun read(buf: ByteBuffer): List<List<kotlin.String>>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceSequenceString.read(buf)
    }

    override fun allocationSize(value: List<List<kotlin.String>>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceSequenceString.allocationSize(value)
        }
    }

    override fun write(value: List<List<kotlin.String>>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceSequenceString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeWalletId: FfiConverterRustBuffer<WalletId?> {
    override fun read(buf: ByteBuffer): WalletId? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeWalletId.read(buf)
    }

    override fun allocationSize(value: WalletId?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeWalletId.allocationSize(value)
        }
    }

    override fun write(value: WalletId?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeWalletId.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceUInt: FfiConverterRustBuffer<List<kotlin.UInt>> {
    override fun read(buf: ByteBuffer): List<kotlin.UInt> {
        val len = buf.getInt()
        return List<kotlin.UInt>(len) {
            FfiConverterUInt.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.UInt>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterUInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.UInt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterUInt.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeBoxedRoute: FfiConverterRustBuffer<List<BoxedRoute>> {
    override fun read(buf: ByteBuffer): List<BoxedRoute> {
        val len = buf.getInt()
        return List<BoxedRoute>(len) {
            FfiConverterTypeBoxedRoute.read(buf)
        }
    }

    override fun allocationSize(value: List<BoxedRoute>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeBoxedRoute.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<BoxedRoute>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeBoxedRoute.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeUnsignedTransaction: FfiConverterRustBuffer<List<UnsignedTransaction>> {
    override fun read(buf: ByteBuffer): List<UnsignedTransaction> {
        val len = buf.getInt()
        return List<UnsignedTransaction>(len) {
            FfiConverterTypeUnsignedTransaction.read(buf)
        }
    }

    override fun allocationSize(value: List<UnsignedTransaction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUnsignedTransaction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UnsignedTransaction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUnsignedTransaction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer<List<OutPoint>> {
    override fun read(buf: ByteBuffer): List<OutPoint> {
        val len = buf.getInt()
        return List<OutPoint>(len) {
            FfiConverterTypeOutPoint.read(buf)
        }
    }

    override fun allocationSize(value: List<OutPoint>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeOutPoint.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<OutPoint>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeOutPoint.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeFoundAddress: FfiConverterRustBuffer<List<FoundAddress>> {
    override fun read(buf: ByteBuffer): List<FoundAddress> {
        val len = buf.getInt()
        return List<FoundAddress>(len) {
            FfiConverterTypeFoundAddress.read(buf)
        }
    }

    override fun allocationSize(value: List<FoundAddress>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFoundAddress.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<FoundAddress>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFoundAddress.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeGroupedWord: FfiConverterRustBuffer<List<GroupedWord>> {
    override fun read(buf: ByteBuffer): List<GroupedWord> {
        val len = buf.getInt()
        return List<GroupedWord>(len) {
            FfiConverterTypeGroupedWord.read(buf)
        }
    }

    override fun allocationSize(value: List<GroupedWord>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeGroupedWord.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<GroupedWord>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeGroupedWord.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeWalletMetadata: FfiConverterRustBuffer<List<WalletMetadata>> {
    override fun read(buf: ByteBuffer): List<WalletMetadata> {
        val len = buf.getInt()
        return List<WalletMetadata>(len) {
            FfiConverterTypeWalletMetadata.read(buf)
        }
    }

    override fun allocationSize(value: List<WalletMetadata>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeWalletMetadata.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<WalletMetadata>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeWalletMetadata.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAddressAndAmount: FfiConverterRustBuffer<List<AddressAndAmount>> {
    override fun read(buf: ByteBuffer): List<AddressAndAmount> {
        val len = buf.getInt()
        return List<AddressAndAmount>(len) {
            FfiConverterTypeAddressAndAmount.read(buf)
        }
    }

    override fun allocationSize(value: List<AddressAndAmount>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAddressAndAmount.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AddressAndAmount>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAddressAndAmount.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer<List<Utxo>> {
    override fun read(buf: ByteBuffer): List<Utxo> {
        val len = buf.getInt()
        return List<Utxo>(len) {
            FfiConverterTypeUtxo.read(buf)
        }
    }

    override fun allocationSize(value: List<Utxo>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUtxo.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Utxo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUtxo.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCoinControlManagerReconcileMessage: FfiConverterRustBuffer<List<CoinControlManagerReconcileMessage>> {
    override fun read(buf: ByteBuffer): List<CoinControlManagerReconcileMessage> {
        val len = buf.getInt()
        return List<CoinControlManagerReconcileMessage>(len) {
            FfiConverterTypeCoinControlManagerReconcileMessage.read(buf)
        }
    }

    override fun allocationSize(value: List<CoinControlManagerReconcileMessage>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCoinControlManagerReconcileMessage.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<CoinControlManagerReconcileMessage>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCoinControlManagerReconcileMessage.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer<List<FiatCurrency>> {
    override fun read(buf: ByteBuffer): List<FiatCurrency> {
        val len = buf.getInt()
        return List<FiatCurrency>(len) {
            FfiConverterTypeFiatCurrency.read(buf)
        }
    }

    override fun allocationSize(value: List<FiatCurrency>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeFiatCurrency.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<FiatCurrency>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeFiatCurrency.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeNodeSelection: FfiConverterRustBuffer<List<NodeSelection>> {
    override fun read(buf: ByteBuffer): List<NodeSelection> {
        val len = buf.getInt()
        return List<NodeSelection>(len) {
            FfiConverterTypeNodeSelection.read(buf)
        }
    }

    override fun allocationSize(value: List<NodeSelection>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeNodeSelection.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<NodeSelection>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeNodeSelection.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeRoute: FfiConverterRustBuffer<List<Route>> {
    override fun read(buf: ByteBuffer): List<Route> {
        val len = buf.getInt()
        return List<Route>(len) {
            FfiConverterTypeRoute.read(buf)
        }
    }

    override fun allocationSize(value: List<Route>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeRoute.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Route>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeRoute.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeSendFlowManagerReconcileMessage: FfiConverterRustBuffer<List<SendFlowManagerReconcileMessage>> {
    override fun read(buf: ByteBuffer): List<SendFlowManagerReconcileMessage> {
        val len = buf.getInt()
        return List<SendFlowManagerReconcileMessage>(len) {
            FfiConverterTypeSendFlowManagerReconcileMessage.read(buf)
        }
    }

    override fun allocationSize(value: List<SendFlowManagerReconcileMessage>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeSendFlowManagerReconcileMessage.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SendFlowManagerReconcileMessage>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeSendFlowManagerReconcileMessage.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer<List<Transaction>> {
    override fun read(buf: ByteBuffer): List<Transaction> {
        val len = buf.getInt()
        return List<Transaction>(len) {
            FfiConverterTypeTransaction.read(buf)
        }
    }

    override fun allocationSize(value: List<Transaction>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeTransaction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Transaction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeTransaction.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeWalletColor: FfiConverterRustBuffer<List<WalletColor>> {
    override fun read(buf: ByteBuffer): List<WalletColor> {
        val len = buf.getInt()
        return List<WalletColor>(len) {
            FfiConverterTypeWalletColor.read(buf)
        }
    }

    override fun allocationSize(value: List<WalletColor>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeWalletColor.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<WalletColor>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeWalletColor.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeWalletManagerReconcileMessage: FfiConverterRustBuffer<List<WalletManagerReconcileMessage>> {
    override fun read(buf: ByteBuffer): List<WalletManagerReconcileMessage> {
        val len = buf.getInt()
        return List<WalletManagerReconcileMessage>(len) {
            FfiConverterTypeWalletManagerReconcileMessage.read(buf)
        }
    }

    override fun allocationSize(value: List<WalletManagerReconcileMessage>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeWalletManagerReconcileMessage.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<WalletManagerReconcileMessage>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeWalletManagerReconcileMessage.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceSequenceString: FfiConverterRustBuffer<List<List<kotlin.String>>> {
    override fun read(buf: ByteBuffer): List<List<kotlin.String>> {
        val len = buf.getInt()
        return List<List<kotlin.String>>(len) {
            FfiConverterSequenceString.read(buf)
        }
    }

    override fun allocationSize(value: List<List<kotlin.String>>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterSequenceString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<List<kotlin.String>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterSequenceString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceSequenceTypeGroupedWord: FfiConverterRustBuffer<List<List<GroupedWord>>> {
    override fun read(buf: ByteBuffer): List<List<GroupedWord>> {
        val len = buf.getInt()
        return List<List<GroupedWord>>(len) {
            FfiConverterSequenceTypeGroupedWord.read(buf)
        }
    }

    override fun allocationSize(value: List<List<GroupedWord>>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterSequenceTypeGroupedWord.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<List<GroupedWord>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterSequenceTypeGroupedWord.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeWalletId: FfiConverterRustBuffer<List<WalletId>> {
    override fun read(buf: ByteBuffer): List<WalletId> {
        val len = buf.getInt()
        return List<WalletId>(len) {
            FfiConverterTypeWalletId.read(buf)
        }
    }

    override fun allocationSize(value: List<WalletId>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeWalletId.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<WalletId>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeWalletId.write(it, buf)
        }
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Timestamp = kotlin.ULong
public typealias FfiConverterTypeTimestamp = FfiConverterULong















































object KeychainExceptionExternalErrorHandler : UniffiRustCallStatusErrorHandler<KeychainException> {
    override fun lift(error_buf: RustBuffer.ByValue): KeychainException =
        org.bitcoinppl.cove.device.KeychainException.ErrorHandler.lift(
            RustBufferKeychainError.ByValue().apply {
                capacity = error_buf.capacity
                len = error_buf.len
                data = error_buf.data
            }
        )
}



object TapCardParseExceptionExternalErrorHandler : UniffiRustCallStatusErrorHandler<TapCardParseException> {
    override fun lift(error_buf: RustBuffer.ByValue): TapCardParseException =
        org.bitcoinppl.cove.tapcard.TapCardParseException.ErrorHandler.lift(
            RustBufferTapCardParseError.ByValue().apply {
                capacity = error_buf.capacity
                len = error_buf.len
                data = error_buf.data
            }
        )
}



object AddressExceptionExternalErrorHandler : UniffiRustCallStatusErrorHandler<AddressException> {
    override fun lift(error_buf: RustBuffer.ByValue): AddressException =
        org.bitcoinppl.cove.types.AddressException.ErrorHandler.lift(
            RustBufferAddressError.ByValue().apply {
                capacity = error_buf.capacity
                len = error_buf.len
                data = error_buf.data
            }
        )
}

























 fun `addressErrorToAlertState`(`error`: AddressException, `address`: kotlin.String): SendFlowAlertState {
            return FfiConverterTypeSendFlowAlertState.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_address_error_to_alert_state(
    
        FfiConverterTypeAddressError.lower(`error`),FfiConverterString.lower(`address`),_status)
}
    )
    }
    
 fun `afterPinActionUserMessage`(`action`: AfterPinAction): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_after_pin_action_user_message(
    
        FfiConverterTypeAfterPinAction.lower(`action`),_status)
}
    )
    }
    
 fun `allFiatCurrencies`(): List<FiatCurrency> {
            return FfiConverterSequenceTypeFiatCurrency.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_all_fiat_currencies(
    
        _status)
}
    )
    }
    
 fun `coinControlListSortKeyToString`(`key`: CoinControlListSortKey): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_coin_control_list_sort_key_to_string(
    
        FfiConverterTypeCoinControlListSortKey.lower(`key`),_status)
}
    )
    }
    
 fun `createTransportErrorFromCode`(`code`: kotlin.UShort, `message`: kotlin.String): TransportException {
            return FfiConverterTypeTransportError.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_create_transport_error_from_code(
    
        FfiConverterUShort.lower(`code`),FfiConverterString.lower(`message`),_status)
}
    )
    }
    
 fun `defaultNodeSelection`(): NodeSelection {
            return FfiConverterTypeNodeSelection.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_default_node_selection(
    
        _status)
}
    )
    }
    
 fun `defaultWalletColors`(): List<WalletColor> {
            return FfiConverterSequenceTypeWalletColor.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_default_wallet_colors(
    
        _status)
}
    )
    }
    
 fun `describeAuthManagerError`(`error`: AuthManagerException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_auth_manager_error(
    
        FfiConverterTypeAuthManagerError.lower(`error`),_status)
}
    )
    }
    
 fun `describeMultiFormatError`(`error`: MultiFormatException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_multi_format_error(
    
        FfiConverterTypeMultiFormatError.lower(`error`),_status)
}
    )
    }
    
 fun `describeSendFlowError`(`error`: SendFlowException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_send_flow_error(
    
        FfiConverterTypeSendFlowError.lower(`error`),_status)
}
    )
    }
    
 fun `describeSendFlowFiatOnChangeError`(`error`: SendFlowFiatOnChangeError): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_send_flow_fiat_on_change_error(
    
        FfiConverterTypeSendFlowFiatOnChangeError.lower(`error`),_status)
}
    )
    }
    
 fun `describeTapSignerReaderError`(`error`: TapSignerReaderException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_tap_signer_reader_error(
    
        FfiConverterTypeTapSignerReaderError.lower(`error`),_status)
}
    )
    }
    
 fun `describeTransportError`(`error`: TransportException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_transport_error(
    
        FfiConverterTypeTransportError.lower(`error`),_status)
}
    )
    }
    
 fun `describeWalletError`(`error`: WalletException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_wallet_error(
    
        FfiConverterTypeWalletError.lower(`error`),_status)
}
    )
    }
    
 fun `describeWalletManagerError`(`error`: WalletManagerException): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_describe_wallet_manager_error(
    
        FfiConverterTypeWalletManagerError.lower(`error`),_status)
}
    )
    }
    
 fun `discoveryStateIsEqual`(`lhs`: DiscoveryState, `rhs`: DiscoveryState): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_discovery_state_is_equal(
    
        FfiConverterTypeDiscoveryState.lower(`lhs`),FfiConverterTypeDiscoveryState.lower(`rhs`),_status)
}
    )
    }
    
 fun `ffiMinSendAmount`(): Amount {
            return FfiConverterTypeAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_ffi_min_send_amount(
    
        _status)
}
    )
    }
    
 fun `ffiMinSendSats`(): kotlin.ULong {
            return FfiConverterULong.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_ffi_min_send_sats(
    
        _status)
}
    )
    }
    
 fun `fiatAmountPreviewNew`(): FiatAmount {
            return FfiConverterTypeFiatAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_fiat_amount_preview_new(
    
        _status)
}
    )
    }
    
 fun `fiatCurrencyEmoji`(`fiatCurrency`: FiatCurrency): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_fiat_currency_emoji(
    
        FfiConverterTypeFiatCurrency.lower(`fiatCurrency`),_status)
}
    )
    }
    
 fun `fiatCurrencySuffix`(`fiatCurrency`: FiatCurrency): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_fiat_currency_suffix(
    
        FfiConverterTypeFiatCurrency.lower(`fiatCurrency`),_status)
}
    )
    }
    
 fun `fiatCurrencySymbol`(`fiatCurrency`: FiatCurrency): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_fiat_currency_symbol(
    
        FfiConverterTypeFiatCurrency.lower(`fiatCurrency`),_status)
}
    )
    }
    
 fun `fiatCurrencyToString`(`fiatCurrency`: FiatCurrency): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_fiat_currency_to_string(
    
        FfiConverterTypeFiatCurrency.lower(`fiatCurrency`),_status)
}
    )
    }
    

    @Throws(MnemonicParseException::class) fun `groupedPlainWordsOf`(`mnemonic`: kotlin.String, `groups`: kotlin.UByte): List<List<kotlin.String>> {
            return FfiConverterSequenceSequenceString.lift(
    uniffiRustCallWithError(MnemonicParseException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_grouped_plain_words_of(
    
        FfiConverterString.lower(`mnemonic`),FfiConverterUByte.lower(`groups`),_status)
}
    )
    }
    
 fun `hardwareWalletIsTapSigner`(`hardwareWallet`: HardwareWalletMetadata): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_hardware_wallet_is_tap_signer(
    
        FfiConverterTypeHardwareWalletMetadata.lower(`hardwareWallet`),_status)
}
    )
    }
    
 fun `hashRoute`(`route`: Route): kotlin.ULong {
            return FfiConverterULong.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_hash_route(
    
        FfiConverterTypeRoute.lower(`route`),_status)
}
    )
    }
    
 fun `isFiatCurrencySymbol`(`symbol`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_is_fiat_currency_symbol(
    
        FfiConverterString.lower(`symbol`),_status)
}
    )
    }
    
 fun `isRouteEqual`(`route`: Route, `routeToCheck`: Route): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_is_route_equal(
    
        FfiConverterTypeRoute.lower(`route`),FfiConverterTypeRoute.lower(`routeToCheck`),_status)
}
    )
    }
    
 fun `isTapSignerRouteEqual`(`lhs`: TapSignerRoute, `rhs`: TapSignerRoute): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_is_tap_signer_route_equal(
    
        FfiConverterTypeTapSignerRoute.lower(`lhs`),FfiConverterTypeTapSignerRoute.lower(`rhs`),_status)
}
    )
    }
    
 fun `isValidChainCode`(`chainCode`: kotlin.String): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_is_valid_chain_code(
    
        FfiConverterString.lower(`chainCode`),_status)
}
    )
    }
    

    @Throws(MultiFormatException::class) fun `multiFormatTryFromNfcMessage`(`nfcMessage`: NfcMessage): MultiFormat {
            return FfiConverterTypeMultiFormat.lift(
    uniffiRustCallWithError(MultiFormatException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_multi_format_try_from_nfc_message(
    
        FfiConverterTypeNfcMessage.lower(`nfcMessage`),_status)
}
    )
    }
    
 fun `nodeSelectionToNode`(`node`: NodeSelection): Node {
            return FfiConverterTypeNode.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_node_selection_to_node(
    
        FfiConverterTypeNodeSelection.lower(`node`),_status)
}
    )
    }
    
 fun `numberOfWordsInGroups`(`me`: NumberOfBip39Words, `of`: kotlin.UByte): List<List<kotlin.String>> {
            return FfiConverterSequenceSequenceString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_number_of_words_in_groups(
    
        FfiConverterTypeNumberOfBip39Words.lower(`me`),FfiConverterUByte.lower(`of`),_status)
}
    )
    }
    
 fun `numberOfWordsToWordCount`(`me`: NumberOfBip39Words): kotlin.UByte {
            return FfiConverterUByte.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_number_of_words_to_word_count(
    
        FfiConverterTypeNumberOfBip39Words.lower(`me`),_status)
}
    )
    }
    
 fun `previewNewLegacyFoundAddress`(): FoundAddress {
            return FfiConverterTypeFoundAddress.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_preview_new_legacy_found_address(
    
        _status)
}
    )
    }
    
 fun `previewNewWrappedFoundAddress`(): FoundAddress {
            return FfiConverterTypeFoundAddress.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_preview_new_wrapped_found_address(
    
        _status)
}
    )
    }
    
 fun `pricesAreEqual`(`lhs`: PriceResponse, `rhs`: PriceResponse): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_prices_are_equal(
    
        FfiConverterTypePriceResponse.lower(`lhs`),FfiConverterTypePriceResponse.lower(`rhs`),_status)
}
    )
    }
    

    @Throws(MultiFormatException::class) fun `stringOrDataTryIntoMultiFormat`(`stringOrData`: StringOrData): MultiFormat {
            return FfiConverterTypeMultiFormat.lift(
    uniffiRustCallWithError(MultiFormatException) { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_string_or_data_try_into_multi_format(
    
        FfiConverterTypeStringOrData.lower(`stringOrData`),_status)
}
    )
    }
    
 fun `tapSignerConfirmPinArgsNewFromNewPin`(`args`: TapSignerNewPinArgs, `newPin`: kotlin.String): TapSignerConfirmPinArgs {
            return FfiConverterTypeTapSignerConfirmPinArgs.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_confirm_pin_args_new_from_new_pin(
    
        FfiConverterTypeTapSignerNewPinArgs.lower(`args`),FfiConverterString.lower(`newPin`),_status)
}
    )
    }
    
 fun `tapSignerErrorIsAuthError`(`error`: TapSignerReaderException): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_error_is_auth_error(
    
        FfiConverterTypeTapSignerReaderError.lower(`error`),_status)
}
    )
    }
    
 fun `tapSignerErrorIsNoBackupError`(`error`: TapSignerReaderException): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_error_is_no_backup_error(
    
        FfiConverterTypeTapSignerReaderError.lower(`error`),_status)
}
    )
    }
    
 fun `tapSignerResponseBackupResponse`(`response`: TapSignerResponse): kotlin.ByteArray? {
            return FfiConverterOptionalByteArray.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_response_backup_response(
    
        FfiConverterTypeTapSignerResponse.lower(`response`),_status)
}
    )
    }
    
 fun `tapSignerResponseChangeResponse`(`response`: TapSignerResponse): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_response_change_response(
    
        FfiConverterTypeTapSignerResponse.lower(`response`),_status)
}
    )
    }
    
 fun `tapSignerResponseDeriveResponse`(`response`: TapSignerResponse): DeriveInfo? {
            return FfiConverterOptionalTypeDeriveInfo.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_response_derive_response(
    
        FfiConverterTypeTapSignerResponse.lower(`response`),_status)
}
    )
    }
    
 fun `tapSignerResponseSetupResponse`(`response`: TapSignerResponse): SetupCmdResponse? {
            return FfiConverterOptionalTypeSetupCmdResponse.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_response_setup_response(
    
        FfiConverterTypeTapSignerResponse.lower(`response`),_status)
}
    )
    }
    
 fun `tapSignerResponseSignResponse`(`response`: TapSignerResponse): Psbt? {
            return FfiConverterOptionalTypePsbt.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_response_sign_response(
    
        FfiConverterTypeTapSignerResponse.lower(`response`),_status)
}
    )
    }
    
 fun `tapSignerSetupCompleteNew`(`preview`: kotlin.Boolean): TapSignerSetupComplete {
            return FfiConverterTypeTapSignerSetupComplete.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_setup_complete_new(
    
        FfiConverterBoolean.lower(`preview`),_status)
}
    )
    }
    
 fun `tapSignerSetupRetryContinueCmd`(`preview`: kotlin.Boolean): SetupCmdResponse {
            return FfiConverterTypeSetupCmdResponse.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_tap_signer_setup_retry_continue_cmd(
    
        FfiConverterBoolean.lower(`preview`),_status)
}
    )
    }
    
 fun `transactionPreviewConfirmedNew`(): Transaction {
            return FfiConverterTypeTransaction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_transaction_preview_confirmed_new(
    
        _status)
}
    )
    }
    
 fun `transactionPreviewUnconfirmedNew`(): Transaction {
            return FfiConverterTypeTransaction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_transaction_preview_unconfirmed_new(
    
        _status)
}
    )
    }
    
 fun `transactionsPreviewNew`(`confirmed`: kotlin.UByte, `unconfirmed`: kotlin.UByte): List<Transaction> {
            return FfiConverterSequenceTypeTransaction.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_transactions_preview_new(
    
        FfiConverterUByte.lower(`confirmed`),FfiConverterUByte.lower(`unconfirmed`),_status)
}
    )
    }
    

    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
     suspend fun `updatePricesIfNeeded`() {
        return uniffiRustCallAsync(
        UniffiLib.INSTANCE.uniffi_cove_fn_func_update_prices_if_needed(),
        { future, callback, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_poll_void(future, callback, continuation) },
        { future, continuation -> UniffiLib.INSTANCE.ffi_cove_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_cove_rust_future_free_void(future) },
        // lift function
        { Unit },
        
        // Error FFI converter
        UniffiNullRustCallStatusErrorHandler,
    )
    }
 fun `walletAddressTypeLessThan`(`lhs`: WalletAddressType, `rhs`: WalletAddressType): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_address_type_less_than(
    
        FfiConverterTypeWalletAddressType.lower(`lhs`),FfiConverterTypeWalletAddressType.lower(`rhs`),_status)
}
    )
    }
    
 fun `walletAddressTypeToString`(`walletAddressType`: WalletAddressType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_address_type_to_string(
    
        FfiConverterTypeWalletAddressType.lower(`walletAddressType`),_status)
}
    )
    }
    
 fun `walletMetadataHash`(`metadata`: WalletMetadata): kotlin.ULong {
            return FfiConverterULong.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_metadata_hash(
    
        FfiConverterTypeWalletMetadata.lower(`metadata`),_status)
}
    )
    }
    
 fun `walletMetadataIsEqual`(`lhs`: WalletMetadata, `rhs`: WalletMetadata): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_metadata_is_equal(
    
        FfiConverterTypeWalletMetadata.lower(`lhs`),FfiConverterTypeWalletMetadata.lower(`rhs`),_status)
}
    )
    }
    
 fun `walletMetadataPreview`(): WalletMetadata {
            return FfiConverterTypeWalletMetadata.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_metadata_preview(
    
        _status)
}
    )
    }
    
 fun `walletStateIsEqual`(`lhs`: WalletLoadState, `rhs`: WalletLoadState): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_state_is_equal(
    
        FfiConverterTypeWalletLoadState.lower(`lhs`),FfiConverterTypeWalletLoadState.lower(`rhs`),_status)
}
    )
    }
    
 fun `walletTypeToString`(`walletType`: WalletType): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_cove_fn_func_wallet_type_to_string(
    
        FfiConverterTypeWalletType.lower(`walletType`),_status)
}
    )
    }
    


