// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package org.bitcoinppl.cove_core.types

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.ffi_cove_types_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.ffi_cove_types_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        val err = try { e.stackTraceToString() } catch(_: Throwable) { "" }
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(err)
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            val err = try { e.stackTraceToString() } catch(_: Throwable) { "" }
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(err)
        }
    }
}
// Initial value and increment amount for handles. 
// These ensure that Kotlin-generated handles always have the lowest bit set
private const val UNIFFI_HANDLEMAP_INITIAL = 1.toLong()
private const val UNIFFI_HANDLEMAP_DELTA = 2.toLong()

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    // Start 
    private val counter = java.util.concurrent.atomic.AtomicLong(UNIFFI_HANDLEMAP_INITIAL)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(UNIFFI_HANDLEMAP_DELTA)
        map.put(handle, obj)
        return handle
    }

    // Clone a handle, creating a new one
    fun clone(handle: Long): Long {
        val obj = map.get(handle) ?: throw InternalException("UniffiHandleMap.clone: Invalid handle")
        return insert(obj)
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "coveffi"
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureDroppedCallback : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceClone : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
    : Long
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFutureDroppedCallbackStruct(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureDroppedCallback? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureDroppedCallback? = null,
    ): UniffiForeignFutureDroppedCallbackStruct(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureDroppedCallbackStruct) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureResultVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultVoid.UniffiByValue,)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is
// rather `InterfaceTooLargeException`, caused by too many methods
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib (this)
// * IntegrityCheckingUniffiLib
// And all checksum methods are put into `IntegrityCheckingUniffiLib`
// we allow for ~2x as many methods in the UniffiLib interface.
//
// Note: above all written when we used JNA's `loadIndirect` etc.
// We now use JNA's "direct mapping" - unclear if same considerations apply exactly.
internal object IntegrityCheckingUniffiLib {
    init {
        Native.register(IntegrityCheckingUniffiLib::class.java, findLibraryName(componentName = "cove_types"))
        uniffiCheckContractApiVersion(this)
        uniffiCheckApiChecksums(this)
    }
    external fun uniffi_cove_types_checksum_func_address_is_valid(
): Short
external fun uniffi_cove_types_checksum_func_address_is_valid_for_network(
): Short
external fun uniffi_cove_types_checksum_func_address_string_spaced_out(
): Short
external fun uniffi_cove_types_checksum_func_all_color_schemes(
): Short
external fun uniffi_cove_types_checksum_func_color_scheme_selection_capitalized_string(
): Short
external fun uniffi_cove_types_checksum_func_confirm_details_preview_new(
): Short
external fun uniffi_cove_types_checksum_func_qr_density_is_equal(
): Short
external fun uniffi_cove_types_checksum_func_fee_rate_options_with_total_fee_is_equal(
): Short
external fun uniffi_cove_types_checksum_func_fee_speed_duration(
): Short
external fun uniffi_cove_types_checksum_func_fee_speed_is_custom(
): Short
external fun uniffi_cove_types_checksum_func_fee_speed_to_circle_color(
): Short
external fun uniffi_cove_types_checksum_func_all_networks(
): Short
external fun uniffi_cove_types_checksum_func_network_to_string(
): Short
external fun uniffi_cove_types_checksum_func_all_units(
): Short
external fun uniffi_cove_types_checksum_func_previewnewutxolist(
): Short
external fun uniffi_cove_types_checksum_func_utxo_date(
): Short
external fun uniffi_cove_types_checksum_func_utxo_hash_to_uint(
): Short
external fun uniffi_cove_types_checksum_func_utxo_is_equal(
): Short
external fun uniffi_cove_types_checksum_func_utxo_name(
): Short
external fun uniffi_cove_types_checksum_method_address_hashtouint(
): Short
external fun uniffi_cove_types_checksum_method_address_spaced_out(
): Short
external fun uniffi_cove_types_checksum_method_address_string(
): Short
external fun uniffi_cove_types_checksum_method_address_unformatted(
): Short
external fun uniffi_cove_types_checksum_method_addressinfo_address(
): Short
external fun uniffi_cove_types_checksum_method_addressinfo_address_unformatted(
): Short
external fun uniffi_cove_types_checksum_method_addressinfo_index(
): Short
external fun uniffi_cove_types_checksum_method_addressinfowithderivation_address(
): Short
external fun uniffi_cove_types_checksum_method_addressinfowithderivation_address_spaced_out(
): Short
external fun uniffi_cove_types_checksum_method_addressinfowithderivation_address_unformatted(
): Short
external fun uniffi_cove_types_checksum_method_addressinfowithderivation_derivation_path(
): Short
external fun uniffi_cove_types_checksum_method_addressinfowithderivation_index(
): Short
external fun uniffi_cove_types_checksum_method_addresswithnetwork_address(
): Short
external fun uniffi_cove_types_checksum_method_addresswithnetwork_amount(
): Short
external fun uniffi_cove_types_checksum_method_addresswithnetwork_isvalidfornetwork(
): Short
external fun uniffi_cove_types_checksum_method_addresswithnetwork_network(
): Short
external fun uniffi_cove_types_checksum_method_amount_as_btc(
): Short
external fun uniffi_cove_types_checksum_method_amount_as_sats(
): Short
external fun uniffi_cove_types_checksum_method_amount_btc_string(
): Short
external fun uniffi_cove_types_checksum_method_amount_btc_string_with_unit(
): Short
external fun uniffi_cove_types_checksum_method_amount_fmt_string(
): Short
external fun uniffi_cove_types_checksum_method_amount_fmt_string_with_unit(
): Short
external fun uniffi_cove_types_checksum_method_amount_sats_string(
): Short
external fun uniffi_cove_types_checksum_method_amount_sats_string_with_unit(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_fee_percentage(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_fee_rate(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_fee_total(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_id(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_id_hash(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_inputs(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_normalized_id(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_outputs(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_bytes(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr_with_density(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr_with_max_version(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_to_hex(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_to_ur(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_psbt_to_ur_with_density(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_sending_amount(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_sending_to(
): Short
external fun uniffi_cove_types_checksum_method_confirmdetails_spending_amount(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_bbqr_animation_interval_ms(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_bbqr_max_version(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_can_decrease(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_can_increase(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_decrease(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_increase(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_ur_animation_interval_ms(
): Short
external fun uniffi_cove_types_checksum_method_qrdensity_ur_fragment_len(
): Short
external fun uniffi_cove_types_checksum_method_feerate_sat_per_vb(
): Short
external fun uniffi_cove_types_checksum_method_feerateoption_duration(
): Short
external fun uniffi_cove_types_checksum_method_feerateoption_fee_rate(
): Short
external fun uniffi_cove_types_checksum_method_feerateoption_fee_speed(
): Short
external fun uniffi_cove_types_checksum_method_feerateoption_is_equal(
): Short
external fun uniffi_cove_types_checksum_method_feerateoption_sat_per_vb(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_duration(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate_options(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_speed(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_custom(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_equal(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_sat_per_vb(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_total_fee(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptions_fast(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptions_medium(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptions_slow(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_add_custom_fee_rate(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_calculate_custom_fee_speed(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_custom(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fast(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fee_rate_options(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_get_fee_rate_with(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_medium(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_remove_custom_fee(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_slow(
): Short
external fun uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_transaction_size(
): Short
external fun uniffi_cove_types_checksum_method_psbt_fee(
): Short
external fun uniffi_cove_types_checksum_method_psbt_output_total_amount(
): Short
external fun uniffi_cove_types_checksum_method_psbt_tx_id(
): Short
external fun uniffi_cove_types_checksum_method_psbt_weight(
): Short
external fun uniffi_cove_types_checksum_method_outpoint_eq(
): Short
external fun uniffi_cove_types_checksum_method_outpoint_hashtouint(
): Short
external fun uniffi_cove_types_checksum_method_outpoint_txid(
): Short
external fun uniffi_cove_types_checksum_method_outpoint_txid_str(
): Short
external fun uniffi_cove_types_checksum_method_outpoint_txn_link(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_amount(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_amount_fmt(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_direction(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_external_sent(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_label(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_received(
): Short
external fun uniffi_cove_types_checksum_method_sentandreceived_sent(
): Short
external fun uniffi_cove_types_checksum_method_txid_as_hash_string(
): Short
external fun uniffi_cove_types_checksum_constructor_address_from_string(
): Short
external fun uniffi_cove_types_checksum_constructor_address_preview_new(
): Short
external fun uniffi_cove_types_checksum_constructor_address_random(
): Short
external fun uniffi_cove_types_checksum_constructor_addresswithnetwork_new(
): Short
external fun uniffi_cove_types_checksum_constructor_amount_from_sat(
): Short
external fun uniffi_cove_types_checksum_constructor_amount_one_btc(
): Short
external fun uniffi_cove_types_checksum_constructor_amount_one_sat(
): Short
external fun uniffi_cove_types_checksum_constructor_qrdensity_new(
): Short
external fun uniffi_cove_types_checksum_constructor_feerate_from_sat_per_vb(
): Short
external fun uniffi_cove_types_checksum_constructor_feerateoption_new(
): Short
external fun uniffi_cove_types_checksum_constructor_feerateoptionwithtotalfee_new(
): Short
external fun uniffi_cove_types_checksum_constructor_feerateoptions_previewnew(
): Short
external fun uniffi_cove_types_checksum_constructor_feerateoptionswithtotalfee_previewnew(
): Short
external fun uniffi_cove_types_checksum_constructor_psbt_new(
): Short
external fun uniffi_cove_types_checksum_constructor_outpoint_previewnew(
): Short
external fun uniffi_cove_types_checksum_constructor_outpoint_withvout(
): Short
external fun ffi_cove_types_uniffi_contract_version(
): Int

    
}

internal object UniffiLib {
    
    // The Cleaner for the whole library
    internal val CLEANER: UniffiCleaner by lazy {
        UniffiCleaner.create()
    }
    

    init {
        Native.register(UniffiLib::class.java, findLibraryName(componentName = "cove_types"))
        
    }
    external fun uniffi_cove_types_fn_clone_address(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_address(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_address_from_string(`address`: RustBuffer.ByValue,`network`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_constructor_address_preview_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_constructor_address_random(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_address_hashtouint(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_address_spaced_out(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_address_string(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_address_unformatted(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_address_uniffi_trait_eq_eq(`ptr`: Long,`other`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_address_uniffi_trait_eq_ne(`ptr`: Long,`other`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_address_uniffi_trait_hash(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_addressinfo(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_addressinfo(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_method_addressinfo_address(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_addressinfo_address_unformatted(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_addressinfo_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun uniffi_cove_types_fn_clone_addressinfowithderivation(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_addressinfowithderivation(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_method_addressinfowithderivation_address(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_addressinfowithderivation_address_spaced_out(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_addressinfowithderivation_address_unformatted(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_addressinfowithderivation_derivation_path(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_addressinfowithderivation_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun uniffi_cove_types_fn_clone_addresswithnetwork(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_addresswithnetwork(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_addresswithnetwork_new(`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_addresswithnetwork_address(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_addresswithnetwork_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_addresswithnetwork_isvalidfornetwork(`ptr`: Long,`network`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_addresswithnetwork_network(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_clone_amount(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_amount(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_amount_from_sat(`sats`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_constructor_amount_one_btc(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_constructor_amount_one_sat(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_amount_as_btc(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
external fun uniffi_cove_types_fn_method_amount_as_sats(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_amount_btc_string(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_amount_btc_string_with_unit(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_amount_fmt_string(`ptr`: Long,`unit`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_amount_fmt_string_with_unit(`ptr`: Long,`unit`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_amount_sats_string(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_amount_sats_string_with_unit(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_clone_chainposition(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_chainposition(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_clone_confirmdetails(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_confirmdetails(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_method_confirmdetails_fee_percentage(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_fee_rate(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_fee_total(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_id_hash(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_inputs(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_normalized_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_outputs(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr_with_density(`ptr`: Long,`density`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr_with_max_version(`ptr`: Long,`maxVersion`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_to_hex(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_to_ur(`ptr`: Long,`maxFragmentLen`: Int,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_psbt_to_ur_with_density(`ptr`: Long,`density`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_confirmdetails_sending_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_sending_to(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_confirmdetails_spending_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_inputoutputdetails(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_inputoutputdetails(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_clone_qrdensity(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_qrdensity(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_qrdensity_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_qrdensity_bbqr_animation_interval_ms(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun uniffi_cove_types_fn_method_qrdensity_bbqr_max_version(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_qrdensity_can_decrease(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_qrdensity_can_increase(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_qrdensity_decrease(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_qrdensity_increase(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_qrdensity_ur_animation_interval_ms(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun uniffi_cove_types_fn_method_qrdensity_ur_fragment_len(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun uniffi_cove_types_fn_clone_feerate(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_feerate(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_feerate_from_sat_per_vb(`satPerVb`: Float,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerate_sat_per_vb(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
external fun uniffi_cove_types_fn_clone_feerateoption(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_feerateoption(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_feerateoption_new(`feeSpeed`: RustBuffer.ByValue,`feeRate`: Float,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoption_duration(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoption_fee_rate(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoption_fee_speed(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoption_is_equal(`ptr`: Long,`rhs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_feerateoption_sat_per_vb(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
external fun uniffi_cove_types_fn_clone_feerateoptionwithtotalfee(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_feerateoptionwithtotalfee(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_feerateoptionwithtotalfee_new(`feeSpeed`: RustBuffer.ByValue,`feeRate`: Long,`totalFee`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_duration(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate_options(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_speed(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_custom(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_equal(`ptr`: Long,`rhs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_sat_per_vb(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
external fun uniffi_cove_types_fn_method_feerateoptionwithtotalfee_total_fee(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_feerateoptions(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_feerateoptions(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_feerateoptions_previewnew(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptions_fast(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptions_medium(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptions_slow(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_feerateoptionswithtotalfee(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_feerateoptionswithtotalfee(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_feerateoptionswithtotalfee_previewnew(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_add_custom_fee_rate(`ptr`: Long,`feeRate`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_calculate_custom_fee_speed(`ptr`: Long,`feeRate`: Float,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_custom(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fast(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fee_rate_options(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_get_fee_rate_with(`ptr`: Long,`feeRate`: Float,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_medium(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_remove_custom_fee(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_slow(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_feerateoptionswithtotalfee_transaction_size(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_psbt(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_psbt(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_psbt_new(`data`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_psbt_fee(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_psbt_output_total_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_psbt_tx_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_psbt_weight(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_outpoint(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_outpoint(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_constructor_outpoint_previewnew(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_constructor_outpoint_withvout(`vout`: Int,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_outpoint_eq(`ptr`: Long,`rhs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_outpoint_hashtouint(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_outpoint_txid(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_outpoint_txid_str(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_outpoint_txn_link(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_clone_sentandreceived(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_sentandreceived(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_method_sentandreceived_amount(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_sentandreceived_amount_fmt(`ptr`: Long,`unit`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_sentandreceived_direction(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_sentandreceived_external_sent(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_sentandreceived_label(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_sentandreceived_received(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_sentandreceived_sent(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_clone_txid(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_txid(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_method_txid_as_hash_string(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_txid_uniffi_trait_display(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_txid_uniffi_trait_eq_eq(`ptr`: Long,`other`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_txid_uniffi_trait_eq_ne(`ptr`: Long,`other`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_txid_uniffi_trait_hash(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_method_txid_uniffi_trait_ord_cmp(`ptr`: Long,`other`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_clone_txin(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_txin(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_clone_txout(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_txout(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_clone_utxolist(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_free_utxolist(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_method_qrexportformat_uniffi_trait_display(`ptr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_feespeed_uniffi_trait_display(`ptr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_network_uniffi_trait_display(`ptr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_bitcoinunit_uniffi_trait_display(`ptr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_method_utxo_uniffi_trait_eq_eq(`ptr`: RustBuffer.ByValue,`other`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_utxo_uniffi_trait_eq_ne(`ptr`: RustBuffer.ByValue,`other`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_method_utxo_uniffi_trait_hash(`ptr`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_func_address_is_valid(`address`: RustBuffer.ByValue,`network`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_func_address_is_valid_for_network(`address`: RustBuffer.ByValue,`network`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun uniffi_cove_types_fn_func_address_string_spaced_out(`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_all_color_schemes(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_color_scheme_selection_capitalized_string(`colorScheme`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_confirm_details_preview_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_func_qr_density_is_equal(`lhs`: Long,`rhs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_func_fee_rate_options_with_total_fee_is_equal(`lhs`: Long,`rhs`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_func_fee_speed_duration(`feeSpeed`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_fee_speed_is_custom(`feeSpeed`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_func_fee_speed_to_circle_color(`feeSpeed`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_all_networks(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_network_to_string(`network`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_all_units(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_previewnewutxolist(`outputCount`: Byte,`changeCount`: Byte,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_utxo_date(`utxo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun uniffi_cove_types_fn_func_utxo_hash_to_uint(`utxo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun uniffi_cove_types_fn_func_utxo_is_equal(`lhs`: RustBuffer.ByValue,`rhs`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun uniffi_cove_types_fn_func_utxo_name(`utxo`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_cove_types_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_cove_types_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_cove_types_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
external fun ffi_cove_types_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_cove_types_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_u8(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_u8(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun ffi_cove_types_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_i8(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_i8(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
external fun ffi_cove_types_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_u16(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_u16(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
external fun ffi_cove_types_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_i16(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_i16(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
external fun ffi_cove_types_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_u32(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_u32(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun ffi_cove_types_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_i32(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_i32(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
external fun ffi_cove_types_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_u64(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_u64(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun ffi_cove_types_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_i64(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_i64(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
external fun ffi_cove_types_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_f32(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_f32(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
external fun ffi_cove_types_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_f64(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_f64(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
external fun ffi_cove_types_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_rust_buffer(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
external fun ffi_cove_types_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
external fun ffi_cove_types_rust_future_cancel_void(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_free_void(`handle`: Long,
): Unit
external fun ffi_cove_types_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

    
}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_cove_types_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_cove_types_checksum_func_address_is_valid() != 40004.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_address_is_valid_for_network() != 34573.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_address_string_spaced_out() != 27769.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_all_color_schemes() != 49693.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_color_scheme_selection_capitalized_string() != 30731.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_confirm_details_preview_new() != 21539.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_qr_density_is_equal() != 3265.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_fee_rate_options_with_total_fee_is_equal() != 17627.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_fee_speed_duration() != 51667.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_fee_speed_is_custom() != 38261.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_fee_speed_to_circle_color() != 20193.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_all_networks() != 5848.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_network_to_string() != 16428.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_all_units() != 35208.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_previewnewutxolist() != 31621.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_utxo_date() != 26239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_utxo_hash_to_uint() != 33471.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_utxo_is_equal() != 34078.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_func_utxo_name() != 48729.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_address_hashtouint() != 25307.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_address_spaced_out() != 7307.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_address_string() != 24375.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_address_unformatted() != 36743.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfo_address() != 18333.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfo_address_unformatted() != 30474.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfo_index() != 1190.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfowithderivation_address() != 22537.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfowithderivation_address_spaced_out() != 2711.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfowithderivation_address_unformatted() != 38193.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfowithderivation_derivation_path() != 62550.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addressinfowithderivation_index() != 40232.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addresswithnetwork_address() != 33829.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addresswithnetwork_amount() != 15414.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addresswithnetwork_isvalidfornetwork() != 42219.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_addresswithnetwork_network() != 25441.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_as_btc() != 12153.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_as_sats() != 8712.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_btc_string() != 40813.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_btc_string_with_unit() != 4146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_fmt_string() != 3973.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_fmt_string_with_unit() != 64791.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_sats_string() != 46414.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_amount_sats_string_with_unit() != 53544.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_fee_percentage() != 7228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_fee_rate() != 11989.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_fee_total() != 14255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_id() != 1448.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_id_hash() != 43019.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_inputs() != 61203.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_normalized_id() != 43735.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_outputs() != 11686.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt() != 47244.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_bytes() != 64298.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr() != 44475.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr_with_density() != 46679.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr_with_max_version() != 52826.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_to_hex() != 28844.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_to_ur() != 51534.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_psbt_to_ur_with_density() != 61309.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_sending_amount() != 32253.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_sending_to() != 38424.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_confirmdetails_spending_amount() != 58334.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_bbqr_animation_interval_ms() != 33981.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_bbqr_max_version() != 14183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_can_decrease() != 33353.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_can_increase() != 15365.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_decrease() != 5016.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_increase() != 45150.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_ur_animation_interval_ms() != 35006.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_qrdensity_ur_fragment_len() != 56660.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerate_sat_per_vb() != 25940.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoption_duration() != 37929.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoption_fee_rate() != 45273.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoption_fee_speed() != 40949.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoption_is_equal() != 33304.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoption_sat_per_vb() != 38044.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_duration() != 34003.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate() != 46441.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate_options() != 5569.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_speed() != 51786.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_custom() != 33675.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_equal() != 12772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_sat_per_vb() != 61796.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_total_fee() != 47307.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptions_fast() != 36416.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptions_medium() != 6247.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptions_slow() != 30350.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_add_custom_fee_rate() != 4884.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_calculate_custom_fee_speed() != 37692.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_custom() != 13008.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fast() != 50276.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fee_rate_options() != 44824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_get_fee_rate_with() != 34987.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_medium() != 37448.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_remove_custom_fee() != 54242.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_slow() != 50247.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_transaction_size() != 16234.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_psbt_fee() != 23286.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_psbt_output_total_amount() != 21225.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_psbt_tx_id() != 3954.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_psbt_weight() != 28925.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_outpoint_eq() != 14112.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_outpoint_hashtouint() != 51667.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_outpoint_txid() != 38543.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_outpoint_txid_str() != 43489.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_outpoint_txn_link() != 14032.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_amount() != 64130.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_amount_fmt() != 34174.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_direction() != 54585.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_external_sent() != 46394.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_label() != 13733.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_received() != 51331.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_sentandreceived_sent() != 46998.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_method_txid_as_hash_string() != 7916.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_address_from_string() != 58026.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_address_preview_new() != 38108.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_address_random() != 40923.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_addresswithnetwork_new() != 11084.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_amount_from_sat() != 32795.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_amount_one_btc() != 13254.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_amount_one_sat() != 27159.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_qrdensity_new() != 57563.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_feerate_from_sat_per_vb() != 23120.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_feerateoption_new() != 46851.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_feerateoptionwithtotalfee_new() != 48098.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_feerateoptions_previewnew() != 40621.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_feerateoptionswithtotalfee_previewnew() != 31010.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_psbt_new() != 33253.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_outpoint_previewnew() != 32440.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_cove_types_checksum_constructor_outpoint_withvout() != 16885.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    IntegrityCheckingUniffiLib
    // UniffiLib() initialized as objects are used, but we still need to explicitly
    // reference it so initialization across crates works as expected.
    UniffiLib
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Placeholder object used to signal that we're constructing an interface with a FFI handle.
 *
 * This is the first argument for interface constructors that input a raw handle. It exists is that
 * so we can avoid signature conflicts when an interface has a regular constructor than inputs a
 * Long.
 *
 * @suppress
 * */
object UniffiWithHandle

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoHandle
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterByte: FfiConverter<Byte, Byte> {
    override fun lift(value: Byte): Byte {
        return value
    }

    override fun read(buf: ByteBuffer): Byte {
        return buf.get()
    }

    override fun lower(value: Byte): Byte {
        return value
    }

    override fun allocationSize(value: Byte) = 1UL

    override fun write(value: Byte, buf: ByteBuffer) {
        buf.put(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterFloat: FfiConverter<Float, Float> {
    override fun lift(value: Float): Float {
        return value
    }

    override fun read(buf: ByteBuffer): Float {
        return buf.getFloat()
    }

    override fun lower(value: Float): Float {
        return value
    }

    override fun allocationSize(value: Float) = 4UL

    override fun write(value: Float, buf: ByteBuffer) {
        buf.putFloat(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble: FfiConverter<Double, Double> {
    override fun lift(value: Double): Double {
        return value
    }

    override fun read(buf: ByteBuffer): Double {
        return buf.getDouble()
    }

    override fun lower(value: Double): Double {
        return value
    }

    override fun allocationSize(value: Double) = 8UL

    override fun write(value: Double, buf: ByteBuffer) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


/**
 * @suppress
 */
public object FfiConverterDuration: FfiConverterRustBuffer<java.time.Duration> {
    override fun read(buf: ByteBuffer): java.time.Duration {
        // Type mismatch (should be u64) but we check for overflow/underflow below
        val seconds = buf.getLong()
        // Type mismatch (should be u32) but we check for overflow/underflow below
        val nanoseconds = buf.getInt().toLong()
        if (seconds < 0) {
            throw java.time.DateTimeException("Duration exceeds minimum or maximum value supported by uniffi")
        }
        if (nanoseconds < 0) {
            throw java.time.DateTimeException("Duration nanoseconds exceed minimum or maximum supported by uniffi")
        }
        return java.time.Duration.ofSeconds(seconds, nanoseconds)
    }

    // 8 bytes for seconds, 4 bytes for nanoseconds
    override fun allocationSize(value: java.time.Duration) = 12UL

    override fun write(value: java.time.Duration, buf: ByteBuffer) {
        if (value.seconds < 0) {
            // Rust does not support negative Durations
            throw IllegalArgumentException("Invalid duration, must be non-negative")
        }

        if (value.nano < 0) {
            // Java docs provide guarantee that nano will always be positive, so this should be impossible
            // See: https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html
            throw IllegalArgumentException("Invalid duration, nano value must be non-negative")
        }

        // Type mismatch (should be u64) but since Rust doesn't support negative durations we should be OK
        buf.putLong(value.seconds)
        // Type mismatch (should be u32) but since values will always be between 0 and 999,999,999 it should be OK
        buf.putInt(value.nano)
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface AddressInterface {
    
    fun `hashToUint`(): kotlin.ULong
    
    fun `spacedOut`(): kotlin.String
    
    fun `string`(): kotlin.String
    
    fun `unformatted`(): kotlin.String
    
    companion object
}

open class Address: Disposable, AutoCloseable, AddressInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_address(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_address(handle, status)
        }
    }

    override fun `hashToUint`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_address_hashtouint(
        it,
        _status)
}
    }
    )
    }
    

    override fun `spacedOut`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_address_spaced_out(
        it,
        _status)
}
    }
    )
    }
    

    override fun `string`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_address_string(
        it,
        _status)
}
    }
    )
    }
    

    override fun `unformatted`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_address_unformatted(
        it,
        _status)
}
    }
    )
    }
    

    

    

    // The local Rust `Eq` implementation - only `eq` is used.
    override fun equals(other: Any?): Boolean {
        if (other !is Address) return false
        return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_address_uniffi_trait_eq_eq(
        it,
        FfiConverterTypeAddress.lower(`other`),_status)
}
    }
    )
    }
    // The local Rust `Hash` implementation
    override fun hashCode(): Int {
        return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_address_uniffi_trait_hash(
        it,
        _status)
}
    }
    ).toInt()
    }

    
    companion object {
        
    @Throws(AddressException::class) fun `fromString`(`address`: kotlin.String, `network`: Network): Address {
            return FfiConverterTypeAddress.lift(
    uniffiRustCallWithError(AddressException) { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_address_from_string(
    
        FfiConverterString.lower(`address`),FfiConverterTypeNetwork.lower(`network`),_status)
}
    )
    }
    

         fun `previewNew`(): Address {
            return FfiConverterTypeAddress.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_address_preview_new(
    
        _status)
}
    )
    }
    

         fun `random`(): Address {
            return FfiConverterTypeAddress.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_address_random(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAddress: FfiConverter<Address, Long> {
    override fun lower(value: Address): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Address {
        return Address(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Address {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Address) = 8UL

    override fun write(value: Address, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface AddressInfoInterface {
    
    fun `address`(): Address
    
    fun `addressUnformatted`(): kotlin.String
    
    fun `index`(): kotlin.UInt
    
    companion object
}

open class AddressInfo: Disposable, AutoCloseable, AddressInfoInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_addressinfo(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_addressinfo(handle, status)
        }
    }

    override fun `address`(): Address {
            return FfiConverterTypeAddress.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfo_address(
        it,
        _status)
}
    }
    )
    }
    

    override fun `addressUnformatted`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfo_address_unformatted(
        it,
        _status)
}
    }
    )
    }
    

    override fun `index`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfo_index(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAddressInfo: FfiConverter<AddressInfo, Long> {
    override fun lower(value: AddressInfo): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): AddressInfo {
        return AddressInfo(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): AddressInfo {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AddressInfo) = 8UL

    override fun write(value: AddressInfo, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface AddressInfoWithDerivationInterface {
    
    fun `address`(): Address
    
    fun `addressSpacedOut`(): kotlin.String
    
    fun `addressUnformatted`(): kotlin.String
    
    fun `derivationPath`(): kotlin.String?
    
    fun `index`(): kotlin.UInt
    
    companion object
}

open class AddressInfoWithDerivation: Disposable, AutoCloseable, AddressInfoWithDerivationInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_addressinfowithderivation(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_addressinfowithderivation(handle, status)
        }
    }

    override fun `address`(): Address {
            return FfiConverterTypeAddress.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfowithderivation_address(
        it,
        _status)
}
    }
    )
    }
    

    override fun `addressSpacedOut`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfowithderivation_address_spaced_out(
        it,
        _status)
}
    }
    )
    }
    

    override fun `addressUnformatted`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfowithderivation_address_unformatted(
        it,
        _status)
}
    }
    )
    }
    

    override fun `derivationPath`(): kotlin.String? {
            return FfiConverterOptionalString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfowithderivation_derivation_path(
        it,
        _status)
}
    }
    )
    }
    

    override fun `index`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addressinfowithderivation_index(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAddressInfoWithDerivation: FfiConverter<AddressInfoWithDerivation, Long> {
    override fun lower(value: AddressInfoWithDerivation): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): AddressInfoWithDerivation {
        return AddressInfoWithDerivation(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): AddressInfoWithDerivation {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AddressInfoWithDerivation) = 8UL

    override fun write(value: AddressInfoWithDerivation, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface AddressWithNetworkInterface {
    
    fun `address`(): Address
    
    fun `amount`(): Amount?
    
    fun `isValidForNetwork`(`network`: Network): kotlin.Boolean
    
    fun `network`(): Network
    
    companion object
}

open class AddressWithNetwork: Disposable, AutoCloseable, AddressWithNetworkInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }
    constructor(`address`: kotlin.String) :
        this(UniffiWithHandle, 
    uniffiRustCallWithError(AddressException) { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_addresswithnetwork_new(
    
        FfiConverterString.lower(`address`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_addresswithnetwork(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_addresswithnetwork(handle, status)
        }
    }

    override fun `address`(): Address {
            return FfiConverterTypeAddress.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addresswithnetwork_address(
        it,
        _status)
}
    }
    )
    }
    

    override fun `amount`(): Amount? {
            return FfiConverterOptionalTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addresswithnetwork_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isValidForNetwork`(`network`: Network): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addresswithnetwork_isvalidfornetwork(
        it,
        FfiConverterTypeNetwork.lower(`network`),_status)
}
    }
    )
    }
    

    override fun `network`(): Network {
            return FfiConverterTypeNetwork.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_addresswithnetwork_network(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAddressWithNetwork: FfiConverter<AddressWithNetwork, Long> {
    override fun lower(value: AddressWithNetwork): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): AddressWithNetwork {
        return AddressWithNetwork(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): AddressWithNetwork {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AddressWithNetwork) = 8UL

    override fun write(value: AddressWithNetwork, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface AmountInterface {
    
    fun `asBtc`(): kotlin.Double
    
    fun `asSats`(): kotlin.ULong
    
    fun `btcString`(): kotlin.String
    
    fun `btcStringWithUnit`(): kotlin.String
    
    fun `fmtString`(`unit`: BitcoinUnit): kotlin.String
    
    fun `fmtStringWithUnit`(`unit`: BitcoinUnit): kotlin.String
    
    fun `satsString`(): kotlin.String
    
    fun `satsStringWithUnit`(): kotlin.String
    
    companion object
}

open class Amount: Disposable, AutoCloseable, AmountInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_amount(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_amount(handle, status)
        }
    }

    override fun `asBtc`(): kotlin.Double {
            return FfiConverterDouble.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_as_btc(
        it,
        _status)
}
    }
    )
    }
    

    override fun `asSats`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_as_sats(
        it,
        _status)
}
    }
    )
    }
    

    override fun `btcString`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_btc_string(
        it,
        _status)
}
    }
    )
    }
    

    override fun `btcStringWithUnit`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_btc_string_with_unit(
        it,
        _status)
}
    }
    )
    }
    

    override fun `fmtString`(`unit`: BitcoinUnit): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_fmt_string(
        it,
        FfiConverterTypeBitcoinUnit.lower(`unit`),_status)
}
    }
    )
    }
    

    override fun `fmtStringWithUnit`(`unit`: BitcoinUnit): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_fmt_string_with_unit(
        it,
        FfiConverterTypeBitcoinUnit.lower(`unit`),_status)
}
    }
    )
    }
    

    override fun `satsString`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_sats_string(
        it,
        _status)
}
    }
    )
    }
    

    override fun `satsStringWithUnit`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_amount_sats_string_with_unit(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `fromSat`(`sats`: kotlin.ULong): Amount {
            return FfiConverterTypeAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_amount_from_sat(
    
        FfiConverterULong.lower(`sats`),_status)
}
    )
    }
    

         fun `oneBtc`(): Amount {
            return FfiConverterTypeAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_amount_one_btc(
    
        _status)
}
    )
    }
    

         fun `oneSat`(): Amount {
            return FfiConverterTypeAmount.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_amount_one_sat(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAmount: FfiConverter<Amount, Long> {
    override fun lower(value: Amount): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Amount {
        return Amount(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Amount {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Amount) = 8UL

    override fun write(value: Amount, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ChainPositionInterface {
    
    companion object
}

open class ChainPosition: Disposable, AutoCloseable, ChainPositionInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_chainposition(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_chainposition(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeChainPosition: FfiConverter<ChainPosition, Long> {
    override fun lower(value: ChainPosition): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): ChainPosition {
        return ChainPosition(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): ChainPosition {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ChainPosition) = 8UL

    override fun write(value: ChainPosition, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface ConfirmDetailsInterface {
    
    fun `feePercentage`(): kotlin.ULong
    
    fun `feeRate`(): FeeRate
    
    fun `feeTotal`(): Amount
    
    fun `id`(): TxId
    
    fun `idHash`(): kotlin.String
    
    fun `inputs`(): List<AddressAndAmount>
    
    fun `normalizedId`(): kotlin.String
    
    fun `outputs`(): List<AddressAndAmount>
    
    fun `psbt`(): Psbt
    
    fun `psbtBytes`(): kotlin.ByteArray
    
    fun `psbtToBbqr`(): List<kotlin.String>
    
    /**
     * Export PSBT as BBQr with specified max version
     */
    fun `psbtToBbqrWithDensity`(`density`: QrDensity): List<kotlin.String>
    
    fun `psbtToBbqrWithMaxVersion`(`maxVersion`: kotlin.UByte): List<kotlin.String>
    
    fun `psbtToHex`(): kotlin.String
    
    /**
     * Export PSBT as UR-encoded QR strings for animated display
     */
    fun `psbtToUr`(`maxFragmentLen`: kotlin.UInt): List<kotlin.String>
    
    /**
     * Export PSBT as UR with specified density
     */
    fun `psbtToUrWithDensity`(`density`: QrDensity): List<kotlin.String>
    
    fun `sendingAmount`(): Amount
    
    fun `sendingTo`(): Address
    
    fun `spendingAmount`(): Amount
    
    companion object
}

open class ConfirmDetails: Disposable, AutoCloseable, ConfirmDetailsInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_confirmdetails(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_confirmdetails(handle, status)
        }
    }

    override fun `feePercentage`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_fee_percentage(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeRate`(): FeeRate {
            return FfiConverterTypeFeeRate.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_fee_rate(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeTotal`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_fee_total(
        it,
        _status)
}
    }
    )
    }
    

    override fun `id`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `idHash`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_id_hash(
        it,
        _status)
}
    }
    )
    }
    

    override fun `inputs`(): List<AddressAndAmount> {
            return FfiConverterSequenceTypeAddressAndAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_inputs(
        it,
        _status)
}
    }
    )
    }
    

    override fun `normalizedId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_normalized_id(
        it,
        _status)
}
    }
    )
    }
    

    override fun `outputs`(): List<AddressAndAmount> {
            return FfiConverterSequenceTypeAddressAndAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_outputs(
        it,
        _status)
}
    }
    )
    }
    

    override fun `psbt`(): Psbt {
            return FfiConverterTypePsbt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt(
        it,
        _status)
}
    }
    )
    }
    

    override fun `psbtBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_bytes(
        it,
        _status)
}
    }
    )
    }
    

    
    @Throws(ConfirmDetailsException::class)override fun `psbtToBbqr`(): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(ConfirmDetailsException) { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Export PSBT as BBQr with specified max version
     */
    @Throws(ConfirmDetailsException::class)override fun `psbtToBbqrWithDensity`(`density`: QrDensity): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(ConfirmDetailsException) { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr_with_density(
        it,
        FfiConverterTypeQrDensity.lower(`density`),_status)
}
    }
    )
    }
    

    
    @Throws(ConfirmDetailsException::class)override fun `psbtToBbqrWithMaxVersion`(`maxVersion`: kotlin.UByte): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(ConfirmDetailsException) { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr_with_max_version(
        it,
        FfiConverterUByte.lower(`maxVersion`),_status)
}
    }
    )
    }
    

    override fun `psbtToHex`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_to_hex(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Export PSBT as UR-encoded QR strings for animated display
     */
    @Throws(ConfirmDetailsException::class)override fun `psbtToUr`(`maxFragmentLen`: kotlin.UInt): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(ConfirmDetailsException) { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_to_ur(
        it,
        FfiConverterUInt.lower(`maxFragmentLen`),_status)
}
    }
    )
    }
    

    
    /**
     * Export PSBT as UR with specified density
     */
    @Throws(ConfirmDetailsException::class)override fun `psbtToUrWithDensity`(`density`: QrDensity): List<kotlin.String> {
            return FfiConverterSequenceString.lift(
    callWithHandle {
    uniffiRustCallWithError(ConfirmDetailsException) { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_psbt_to_ur_with_density(
        it,
        FfiConverterTypeQrDensity.lower(`density`),_status)
}
    }
    )
    }
    

    override fun `sendingAmount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_sending_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sendingTo`(): Address {
            return FfiConverterTypeAddress.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_sending_to(
        it,
        _status)
}
    }
    )
    }
    

    override fun `spendingAmount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_confirmdetails_spending_amount(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeConfirmDetails: FfiConverter<ConfirmDetails, Long> {
    override fun lower(value: ConfirmDetails): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): ConfirmDetails {
        return ConfirmDetails(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): ConfirmDetails {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ConfirmDetails) = 8UL

    override fun write(value: ConfirmDetails, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FeeRateInterface {
    
    fun `satPerVb`(): kotlin.Float
    
    companion object
}

open class FeeRate: Disposable, AutoCloseable, FeeRateInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_feerate(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_feerate(handle, status)
        }
    }

    override fun `satPerVb`(): kotlin.Float {
            return FfiConverterFloat.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerate_sat_per_vb(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `fromSatPerVb`(`satPerVb`: kotlin.Float): FeeRate {
            return FfiConverterTypeFeeRate.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_feerate_from_sat_per_vb(
    
        FfiConverterFloat.lower(`satPerVb`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFeeRate: FfiConverter<FeeRate, Long> {
    override fun lower(value: FeeRate): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FeeRate {
        return FeeRate(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FeeRate {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FeeRate) = 8UL

    override fun write(value: FeeRate, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FeeRateOptionInterface {
    
    fun `duration`(): kotlin.String
    
    fun `feeRate`(): FeeRate
    
    fun `feeSpeed`(): FeeSpeed
    
    fun `isEqual`(`rhs`: FeeRateOption): kotlin.Boolean
    
    fun `satPerVb`(): kotlin.Float
    
    companion object
}

open class FeeRateOption: Disposable, AutoCloseable, FeeRateOptionInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }
    constructor(`feeSpeed`: FeeSpeed, `feeRate`: kotlin.Float) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_feerateoption_new(
    
        FfiConverterTypeFeeSpeed.lower(`feeSpeed`),FfiConverterFloat.lower(`feeRate`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_feerateoption(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_feerateoption(handle, status)
        }
    }

    override fun `duration`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoption_duration(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeRate`(): FeeRate {
            return FfiConverterTypeFeeRate.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoption_fee_rate(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeSpeed`(): FeeSpeed {
            return FfiConverterTypeFeeSpeed.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoption_fee_speed(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isEqual`(`rhs`: FeeRateOption): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoption_is_equal(
        it,
        FfiConverterTypeFeeRateOption.lower(`rhs`),_status)
}
    }
    )
    }
    

    override fun `satPerVb`(): kotlin.Float {
            return FfiConverterFloat.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoption_sat_per_vb(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFeeRateOption: FfiConverter<FeeRateOption, Long> {
    override fun lower(value: FeeRateOption): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FeeRateOption {
        return FeeRateOption(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FeeRateOption {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FeeRateOption) = 8UL

    override fun write(value: FeeRateOption, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FeeRateOptionWithTotalFeeInterface {
    
    fun `duration`(): kotlin.String
    
    fun `feeRate`(): FeeRate
    
    fun `feeRateOptions`(): FeeRateOption
    
    fun `feeSpeed`(): FeeSpeed
    
    fun `isCustom`(): kotlin.Boolean
    
    fun `isEqual`(`rhs`: FeeRateOptionWithTotalFee): kotlin.Boolean
    
    fun `satPerVb`(): kotlin.Float
    
    fun `totalFee`(): Amount
    
    companion object
}

open class FeeRateOptionWithTotalFee: Disposable, AutoCloseable, FeeRateOptionWithTotalFeeInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }
    constructor(`feeSpeed`: FeeSpeed, `feeRate`: FeeRate, `totalFee`: Amount) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_feerateoptionwithtotalfee_new(
    
        FfiConverterTypeFeeSpeed.lower(`feeSpeed`),FfiConverterTypeFeeRate.lower(`feeRate`),FfiConverterTypeAmount.lower(`totalFee`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_feerateoptionwithtotalfee(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_feerateoptionwithtotalfee(handle, status)
        }
    }

    override fun `duration`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_duration(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeRate`(): FeeRate {
            return FfiConverterTypeFeeRate.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeRateOptions`(): FeeRateOption {
            return FfiConverterTypeFeeRateOption.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate_options(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeSpeed`(): FeeSpeed {
            return FfiConverterTypeFeeSpeed.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_speed(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isCustom`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_custom(
        it,
        _status)
}
    }
    )
    }
    

    override fun `isEqual`(`rhs`: FeeRateOptionWithTotalFee): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_equal(
        it,
        FfiConverterTypeFeeRateOptionWithTotalFee.lower(`rhs`),_status)
}
    }
    )
    }
    

    override fun `satPerVb`(): kotlin.Float {
            return FfiConverterFloat.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_sat_per_vb(
        it,
        _status)
}
    }
    )
    }
    

    override fun `totalFee`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionwithtotalfee_total_fee(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFeeRateOptionWithTotalFee: FfiConverter<FeeRateOptionWithTotalFee, Long> {
    override fun lower(value: FeeRateOptionWithTotalFee): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FeeRateOptionWithTotalFee {
        return FeeRateOptionWithTotalFee(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FeeRateOptionWithTotalFee {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FeeRateOptionWithTotalFee) = 8UL

    override fun write(value: FeeRateOptionWithTotalFee, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FeeRateOptionsInterface {
    
    fun `fast`(): FeeRateOption
    
    fun `medium`(): FeeRateOption
    
    fun `slow`(): FeeRateOption
    
    companion object
}

open class FeeRateOptions: Disposable, AutoCloseable, FeeRateOptionsInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_feerateoptions(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_feerateoptions(handle, status)
        }
    }

    override fun `fast`(): FeeRateOption {
            return FfiConverterTypeFeeRateOption.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptions_fast(
        it,
        _status)
}
    }
    )
    }
    

    override fun `medium`(): FeeRateOption {
            return FfiConverterTypeFeeRateOption.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptions_medium(
        it,
        _status)
}
    }
    )
    }
    

    override fun `slow`(): FeeRateOption {
            return FfiConverterTypeFeeRateOption.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptions_slow(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewNew`(): FeeRateOptions {
            return FfiConverterTypeFeeRateOptions.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_feerateoptions_previewnew(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFeeRateOptions: FfiConverter<FeeRateOptions, Long> {
    override fun lower(value: FeeRateOptions): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FeeRateOptions {
        return FeeRateOptions(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FeeRateOptions {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FeeRateOptions) = 8UL

    override fun write(value: FeeRateOptions, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface FeeRateOptionsWithTotalFeeInterface {
    
    fun `addCustomFeeRate`(`feeRate`: FeeRateOptionWithTotalFee): FeeRateOptionsWithTotalFee
    
    fun `calculateCustomFeeSpeed`(`feeRate`: kotlin.Float): FeeSpeed
    
    fun `custom`(): FeeRateOptionWithTotalFee?
    
    fun `fast`(): FeeRateOptionWithTotalFee
    
    fun `feeRateOptions`(): FeeRateOptions
    
    fun `getFeeRateWith`(`feeRate`: kotlin.Float): FeeRateOptionWithTotalFee?
    
    fun `medium`(): FeeRateOptionWithTotalFee
    
    fun `removeCustomFee`(): FeeRateOptionsWithTotalFee
    
    fun `slow`(): FeeRateOptionWithTotalFee
    
    fun `transactionSize`(): kotlin.ULong
    
    companion object
}

open class FeeRateOptionsWithTotalFee: Disposable, AutoCloseable, FeeRateOptionsWithTotalFeeInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_feerateoptionswithtotalfee(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_feerateoptionswithtotalfee(handle, status)
        }
    }

    override fun `addCustomFeeRate`(`feeRate`: FeeRateOptionWithTotalFee): FeeRateOptionsWithTotalFee {
            return FfiConverterTypeFeeRateOptionsWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_add_custom_fee_rate(
        it,
        FfiConverterTypeFeeRateOptionWithTotalFee.lower(`feeRate`),_status)
}
    }
    )
    }
    

    override fun `calculateCustomFeeSpeed`(`feeRate`: kotlin.Float): FeeSpeed {
            return FfiConverterTypeFeeSpeed.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_calculate_custom_fee_speed(
        it,
        FfiConverterFloat.lower(`feeRate`),_status)
}
    }
    )
    }
    

    override fun `custom`(): FeeRateOptionWithTotalFee? {
            return FfiConverterOptionalTypeFeeRateOptionWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_custom(
        it,
        _status)
}
    }
    )
    }
    

    override fun `fast`(): FeeRateOptionWithTotalFee {
            return FfiConverterTypeFeeRateOptionWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fast(
        it,
        _status)
}
    }
    )
    }
    

    override fun `feeRateOptions`(): FeeRateOptions {
            return FfiConverterTypeFeeRateOptions.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fee_rate_options(
        it,
        _status)
}
    }
    )
    }
    

    override fun `getFeeRateWith`(`feeRate`: kotlin.Float): FeeRateOptionWithTotalFee? {
            return FfiConverterOptionalTypeFeeRateOptionWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_get_fee_rate_with(
        it,
        FfiConverterFloat.lower(`feeRate`),_status)
}
    }
    )
    }
    

    override fun `medium`(): FeeRateOptionWithTotalFee {
            return FfiConverterTypeFeeRateOptionWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_medium(
        it,
        _status)
}
    }
    )
    }
    

    override fun `removeCustomFee`(): FeeRateOptionsWithTotalFee {
            return FfiConverterTypeFeeRateOptionsWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_remove_custom_fee(
        it,
        _status)
}
    }
    )
    }
    

    override fun `slow`(): FeeRateOptionWithTotalFee {
            return FfiConverterTypeFeeRateOptionWithTotalFee.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_slow(
        it,
        _status)
}
    }
    )
    }
    

    override fun `transactionSize`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feerateoptionswithtotalfee_transaction_size(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewNew`(): FeeRateOptionsWithTotalFee {
            return FfiConverterTypeFeeRateOptionsWithTotalFee.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_feerateoptionswithtotalfee_previewnew(
    
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeFeeRateOptionsWithTotalFee: FfiConverter<FeeRateOptionsWithTotalFee, Long> {
    override fun lower(value: FeeRateOptionsWithTotalFee): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): FeeRateOptionsWithTotalFee {
        return FeeRateOptionsWithTotalFee(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): FeeRateOptionsWithTotalFee {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: FeeRateOptionsWithTotalFee) = 8UL

    override fun write(value: FeeRateOptionsWithTotalFee, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface InputOutputDetailsInterface {
    
    companion object
}

open class InputOutputDetails: Disposable, AutoCloseable, InputOutputDetailsInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_inputoutputdetails(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_inputoutputdetails(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeInputOutputDetails: FfiConverter<InputOutputDetails, Long> {
    override fun lower(value: InputOutputDetails): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): InputOutputDetails {
        return InputOutputDetails(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): InputOutputDetails {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: InputOutputDetails) = 8UL

    override fun write(value: InputOutputDetails, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface OutPointInterface {
    
    fun `eq`(`rhs`: OutPoint): kotlin.Boolean
    
    fun `hashToUint`(): kotlin.ULong
    
    fun `txid`(): TxId
    
    fun `txidStr`(): kotlin.String
    
    fun `txnLink`(): kotlin.String
    
    companion object
}

open class OutPoint: Disposable, AutoCloseable, OutPointInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_outpoint(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_outpoint(handle, status)
        }
    }

    override fun `eq`(`rhs`: OutPoint): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_outpoint_eq(
        it,
        FfiConverterTypeOutPoint.lower(`rhs`),_status)
}
    }
    )
    }
    

    override fun `hashToUint`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_outpoint_hashtouint(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txid`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_outpoint_txid(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txidStr`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_outpoint_txid_str(
        it,
        _status)
}
    }
    )
    }
    

    override fun `txnLink`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_outpoint_txn_link(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    companion object {
         fun `previewNew`(): OutPoint {
            return FfiConverterTypeOutPoint.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_outpoint_previewnew(
    
        _status)
}
    )
    }
    

         fun `withVout`(`vout`: kotlin.UInt): OutPoint {
            return FfiConverterTypeOutPoint.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_outpoint_withvout(
    
        FfiConverterUInt.lower(`vout`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOutPoint: FfiConverter<OutPoint, Long> {
    override fun lower(value: OutPoint): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OutPoint {
        return OutPoint(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OutPoint {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OutPoint) = 8UL

    override fun write(value: OutPoint, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface PsbtInterface {
    
    /**
     * Total fee in sats.
     */
    fun `fee`(): Amount
    
    /**
     * Get total sending amount of all outputs
     */
    fun `outputTotalAmount`(): Amount
    
    /**
     * Get the transaction id of the unsigned transaction
     */
    fun `txId`(): TxId
    
    /**
     * The virtual size of the transaction.
     */
    fun `weight`(): kotlin.ULong
    
    companion object
}

open class Psbt: Disposable, AutoCloseable, PsbtInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }
    constructor(`data`: kotlin.ByteArray) :
        this(UniffiWithHandle, 
    uniffiRustCallWithError(PsbtException) { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_psbt_new(
    
        FfiConverterByteArray.lower(`data`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_psbt(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_psbt(handle, status)
        }
    }

    
    /**
     * Total fee in sats.
     */
    @Throws(PsbtException::class)override fun `fee`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCallWithError(PsbtException) { _status ->
    UniffiLib.uniffi_cove_types_fn_method_psbt_fee(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Get total sending amount of all outputs
     */override fun `outputTotalAmount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_psbt_output_total_amount(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Get the transaction id of the unsigned transaction
     */override fun `txId`(): TxId {
            return FfiConverterTypeTxId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_psbt_tx_id(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * The virtual size of the transaction.
     */override fun `weight`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_psbt_weight(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypePsbt: FfiConverter<Psbt, Long> {
    override fun lower(value: Psbt): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Psbt {
        return Psbt(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Psbt {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Psbt) = 8UL

    override fun write(value: Psbt, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


/**
 * QR code density settings for export
 *
 * Controls how much data is packed into each QR code frame.
 * Higher density = larger/more complex QRs, fewer animation frames.
 * Lower density = smaller/simpler QRs, more animation frames.
 */
public interface QrDensityInterface {
    
    /**
     * Get the recommended animation interval in milliseconds for BBQR format
     * Lower density (smaller max version) = slower animation for better scanning
     */
    fun `bbqrAnimationIntervalMs`(): kotlin.UInt
    
    fun `bbqrMaxVersion`(): kotlin.UByte
    
    fun `canDecrease`(): kotlin.Boolean
    
    fun `canIncrease`(): kotlin.Boolean
    
    /**
     * Decrease density (smaller QRs, more animation frames)
     */
    fun `decrease`(): QrDensity
    
    /**
     * Increase density (larger QRs, fewer animation frames)
     */
    fun `increase`(): QrDensity
    
    /**
     * Get the recommended animation interval in milliseconds for UR format
     * Lower density (smaller fragments) = slower animation for better scanning
     */
    fun `urAnimationIntervalMs`(): kotlin.UInt
    
    fun `urFragmentLen`(): kotlin.UInt
    
    companion object
}

/**
 * QR code density settings for export
 *
 * Controls how much data is packed into each QR code frame.
 * Higher density = larger/more complex QRs, fewer animation frames.
 * Lower density = smaller/simpler QRs, more animation frames.
 */
open class QrDensity: Disposable, AutoCloseable, QrDensityInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_constructor_qrdensity_new(
    
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_qrdensity(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_qrdensity(handle, status)
        }
    }

    
    /**
     * Get the recommended animation interval in milliseconds for BBQR format
     * Lower density (smaller max version) = slower animation for better scanning
     */override fun `bbqrAnimationIntervalMs`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_bbqr_animation_interval_ms(
        it,
        _status)
}
    }
    )
    }
    

    override fun `bbqrMaxVersion`(): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_bbqr_max_version(
        it,
        _status)
}
    }
    )
    }
    

    override fun `canDecrease`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_can_decrease(
        it,
        _status)
}
    }
    )
    }
    

    override fun `canIncrease`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_can_increase(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Decrease density (smaller QRs, more animation frames)
     */override fun `decrease`(): QrDensity {
            return FfiConverterTypeQrDensity.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_decrease(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Increase density (larger QRs, fewer animation frames)
     */override fun `increase`(): QrDensity {
            return FfiConverterTypeQrDensity.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_increase(
        it,
        _status)
}
    }
    )
    }
    

    
    /**
     * Get the recommended animation interval in milliseconds for UR format
     * Lower density (smaller fragments) = slower animation for better scanning
     */override fun `urAnimationIntervalMs`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_ur_animation_interval_ms(
        it,
        _status)
}
    }
    )
    }
    

    override fun `urFragmentLen`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrdensity_ur_fragment_len(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeQrDensity: FfiConverter<QrDensity, Long> {
    override fun lower(value: QrDensity): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): QrDensity {
        return QrDensity(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): QrDensity {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: QrDensity) = 8UL

    override fun write(value: QrDensity, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface SentAndReceivedInterface {
    
    fun `amount`(): Amount
    
    fun `amountFmt`(`unit`: BitcoinUnit): kotlin.String
    
    fun `direction`(): TransactionDirection
    
    fun `externalSent`(): Amount
    
    fun `label`(): kotlin.String
    
    fun `received`(): Amount
    
    fun `sent`(): Amount
    
    companion object
}

open class SentAndReceived: Disposable, AutoCloseable, SentAndReceivedInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_sentandreceived(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_sentandreceived(handle, status)
        }
    }

    override fun `amount`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_amount(
        it,
        _status)
}
    }
    )
    }
    

    override fun `amountFmt`(`unit`: BitcoinUnit): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_amount_fmt(
        it,
        FfiConverterTypeBitcoinUnit.lower(`unit`),_status)
}
    }
    )
    }
    

    override fun `direction`(): TransactionDirection {
            return FfiConverterTypeTransactionDirection.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_direction(
        it,
        _status)
}
    }
    )
    }
    

    override fun `externalSent`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_external_sent(
        it,
        _status)
}
    }
    )
    }
    

    override fun `label`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_label(
        it,
        _status)
}
    }
    )
    }
    

    override fun `received`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_received(
        it,
        _status)
}
    }
    )
    }
    

    override fun `sent`(): Amount {
            return FfiConverterTypeAmount.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_sentandreceived_sent(
        it,
        _status)
}
    }
    )
    }
    

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSentAndReceived: FfiConverter<SentAndReceived, Long> {
    override fun lower(value: SentAndReceived): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SentAndReceived {
        return SentAndReceived(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SentAndReceived {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SentAndReceived) = 8UL

    override fun write(value: SentAndReceived, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TxIdInterface {
    
    fun `asHashString`(): kotlin.String
    
    companion object
}

open class TxId: Disposable, AutoCloseable, TxIdInterface
, Comparable<TxId>
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_txid(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_txid(handle, status)
        }
    }

    override fun `asHashString`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_txid_as_hash_string(
        it,
        _status)
}
    }
    )
    }
    

    

    

    // The local Rust `Display`/`Debug` implementation.
    override fun toString(): String {
        return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_txid_uniffi_trait_display(
        it,
        _status)
}
    }
    )
    }
    // The local Rust `Eq` implementation - only `eq` is used.
    override fun equals(other: Any?): Boolean {
        if (other !is TxId) return false
        return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_txid_uniffi_trait_eq_eq(
        it,
        FfiConverterTypeTxId.lower(`other`),_status)
}
    }
    )
    }
    // The local Rust `Hash` implementation
    override fun hashCode(): Int {
        return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_txid_uniffi_trait_hash(
        it,
        _status)
}
    }
    ).toInt()
    }
    // The local Rust `Ord` implementation
    override fun compareTo(other: TxId): Int {
        return FfiConverterByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_txid_uniffi_trait_ord_cmp(
        it,
        FfiConverterTypeTxId.lower(`other`),_status)
}
    }
    ).toInt()
    }

    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeTxId: FfiConverter<TxId, Long> {
    override fun lower(value: TxId): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): TxId {
        return TxId(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): TxId {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TxId) = 8UL

    override fun write(value: TxId, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TxInInterface {
    
    companion object
}

open class TxIn: Disposable, AutoCloseable, TxInInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_txin(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_txin(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeTxIn: FfiConverter<TxIn, Long> {
    override fun lower(value: TxIn): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): TxIn {
        return TxIn(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): TxIn {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TxIn) = 8UL

    override fun write(value: TxIn, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface TxOutInterface {
    
    companion object
}

open class TxOut: Disposable, AutoCloseable, TxOutInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_txout(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_txout(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeTxOut: FfiConverter<TxOut, Long> {
    override fun lower(value: TxOut): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): TxOut {
        return TxOut(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): TxOut {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: TxOut) = 8UL

    override fun write(value: TxOut, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


public interface UtxoListInterface {
    
    companion object
}

open class UtxoList: Disposable, AutoCloseable, UtxoListInterface
{

    @Suppress("UNUSED_PARAMETER")
    /**
     * @suppress
     */
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * @suppress
     *
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = null
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable?

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable?.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.uniffi_cove_types_fn_free_utxolist(handle, status)
            }
        }
    }

    /**
     * @suppress
     */
    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.uniffi_cove_types_fn_clone_utxolist(handle, status)
        }
    }

    

    


    
    
    /**
     * @suppress
     */
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeUtxoList: FfiConverter<UtxoList, Long> {
    override fun lower(value: UtxoList): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): UtxoList {
        return UtxoList(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): UtxoList {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: UtxoList) = 8UL

    override fun write(value: UtxoList, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}



data class AddressAndAmount (
    var `label`: kotlin.String?
    , 
    var `utxoType`: UtxoType?
    , 
    var `address`: Address
    , 
    var `amount`: Amount
    
): Disposable{
    

    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`label`,
        this.`utxoType`,
        this.`address`,
        this.`amount`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddressAndAmount: FfiConverterRustBuffer<AddressAndAmount> {
    override fun read(buf: ByteBuffer): AddressAndAmount {
        return AddressAndAmount(
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalTypeUtxoType.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAmount.read(buf),
        )
    }

    override fun allocationSize(value: AddressAndAmount) = (
            FfiConverterOptionalString.allocationSize(value.`label`) +
            FfiConverterOptionalTypeUtxoType.allocationSize(value.`utxoType`) +
            FfiConverterTypeAddress.allocationSize(value.`address`) +
            FfiConverterTypeAmount.allocationSize(value.`amount`)
    )

    override fun write(value: AddressAndAmount, buf: ByteBuffer) {
            FfiConverterOptionalString.write(value.`label`, buf)
            FfiConverterOptionalTypeUtxoType.write(value.`utxoType`, buf)
            FfiConverterTypeAddress.write(value.`address`, buf)
            FfiConverterTypeAmount.write(value.`amount`, buf)
    }
}



data class AddressIndex (
    var `lastSeenIndex`: kotlin.UByte
    , 
    var `addressListHash`: kotlin.ULong
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAddressIndex: FfiConverterRustBuffer<AddressIndex> {
    override fun read(buf: ByteBuffer): AddressIndex {
        return AddressIndex(
            FfiConverterUByte.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: AddressIndex) = (
            FfiConverterUByte.allocationSize(value.`lastSeenIndex`) +
            FfiConverterULong.allocationSize(value.`addressListHash`)
    )

    override fun write(value: AddressIndex, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`lastSeenIndex`, buf)
            FfiConverterULong.write(value.`addressListHash`, buf)
    }
}



data class BlockSizeLast (
    var `blockHeight`: kotlin.ULong
    , 
    var `lastSeen`: java.time.Duration
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBlockSizeLast: FfiConverterRustBuffer<BlockSizeLast> {
    override fun read(buf: ByteBuffer): BlockSizeLast {
        return BlockSizeLast(
            FfiConverterULong.read(buf),
            FfiConverterDuration.read(buf),
        )
    }

    override fun allocationSize(value: BlockSizeLast) = (
            FfiConverterULong.allocationSize(value.`blockHeight`) +
            FfiConverterDuration.allocationSize(value.`lastSeen`)
    )

    override fun write(value: BlockSizeLast, buf: ByteBuffer) {
            FfiConverterULong.write(value.`blockHeight`, buf)
            FfiConverterDuration.write(value.`lastSeen`, buf)
    }
}



data class Rgb (
    var `r`: kotlin.UByte
    , 
    var `g`: kotlin.UByte
    , 
    var `b`: kotlin.UByte
    
){
    

    

    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeRgb: FfiConverterRustBuffer<Rgb> {
    override fun read(buf: ByteBuffer): Rgb {
        return Rgb(
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: Rgb) = (
            FfiConverterUByte.allocationSize(value.`r`) +
            FfiConverterUByte.allocationSize(value.`g`) +
            FfiConverterUByte.allocationSize(value.`b`)
    )

    override fun write(value: Rgb, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`r`, buf)
            FfiConverterUByte.write(value.`g`, buf)
            FfiConverterUByte.write(value.`b`, buf)
    }
}



data class SplitOutput (
    var `external`: List<AddressAndAmount>
    , 
    var `internal`: List<AddressAndAmount>
    
): Disposable{
    

    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`external`,
        this.`internal`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSplitOutput: FfiConverterRustBuffer<SplitOutput> {
    override fun read(buf: ByteBuffer): SplitOutput {
        return SplitOutput(
            FfiConverterSequenceTypeAddressAndAmount.read(buf),
            FfiConverterSequenceTypeAddressAndAmount.read(buf),
        )
    }

    override fun allocationSize(value: SplitOutput) = (
            FfiConverterSequenceTypeAddressAndAmount.allocationSize(value.`external`) +
            FfiConverterSequenceTypeAddressAndAmount.allocationSize(value.`internal`)
    )

    override fun write(value: SplitOutput, buf: ByteBuffer) {
            FfiConverterSequenceTypeAddressAndAmount.write(value.`external`, buf)
            FfiConverterSequenceTypeAddressAndAmount.write(value.`internal`, buf)
    }
}



data class Utxo (
    var `outpoint`: OutPoint
    , 
    var `label`: kotlin.String?
    , 
    var `datetime`: kotlin.ULong
    , 
    var `amount`: Amount
    , 
    var `address`: Address
    , 
    var `derivationIndex`: kotlin.UInt
    , 
    var `blockHeight`: kotlin.UInt
    , 
    var `type`: UtxoType
    
): Disposable{
    

    

    // The local Rust `Eq` implementation - only `eq` is used.
    override fun equals(other: Any?): Boolean {
        if (other !is Utxo) return false
        return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_utxo_uniffi_trait_eq_eq(FfiConverterTypeUtxo.lower(this),
        FfiConverterTypeUtxo.lower(`other`),_status)
}
    )
    }
    // The local Rust `Hash` implementation
    override fun hashCode(): Int {
        return FfiConverterULong.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_utxo_uniffi_trait_hash(FfiConverterTypeUtxo.lower(this),
        _status)
}
    ).toInt()
    }
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`outpoint`,
        this.`label`,
        this.`datetime`,
        this.`amount`,
        this.`address`,
        this.`derivationIndex`,
        this.`blockHeight`,
        this.`type`
    )
    }
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeUtxo: FfiConverterRustBuffer<Utxo> {
    override fun read(buf: ByteBuffer): Utxo {
        return Utxo(
            FfiConverterTypeOutPoint.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeAmount.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypeUtxoType.read(buf),
        )
    }

    override fun allocationSize(value: Utxo) = (
            FfiConverterTypeOutPoint.allocationSize(value.`outpoint`) +
            FfiConverterOptionalString.allocationSize(value.`label`) +
            FfiConverterULong.allocationSize(value.`datetime`) +
            FfiConverterTypeAmount.allocationSize(value.`amount`) +
            FfiConverterTypeAddress.allocationSize(value.`address`) +
            FfiConverterUInt.allocationSize(value.`derivationIndex`) +
            FfiConverterUInt.allocationSize(value.`blockHeight`) +
            FfiConverterTypeUtxoType.allocationSize(value.`type`)
    )

    override fun write(value: Utxo, buf: ByteBuffer) {
            FfiConverterTypeOutPoint.write(value.`outpoint`, buf)
            FfiConverterOptionalString.write(value.`label`, buf)
            FfiConverterULong.write(value.`datetime`, buf)
            FfiConverterTypeAmount.write(value.`amount`, buf)
            FfiConverterTypeAddress.write(value.`address`, buf)
            FfiConverterUInt.write(value.`derivationIndex`, buf)
            FfiConverterUInt.write(value.`blockHeight`, buf)
            FfiConverterTypeUtxoType.write(value.`type`, buf)
    }
}





sealed class AddressException: kotlin.Exception() {
    
    class NoOutputs(
        ) : AddressException() {
        override val message
            get() = ""
    }
    
    class ScriptException(
        
        val v1: kotlin.String
        ) : AddressException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class InvalidAddress(
        ) : AddressException() {
        override val message
            get() = ""
    }
    
    class UnsupportedNetwork(
        ) : AddressException() {
        override val message
            get() = ""
    }
    
    class WrongNetwork(
        
        val `current`: Network, 
        
        val `validFor`: Network
        ) : AddressException() {
        override val message
            get() = "current=${ `current` }, validFor=${ `validFor` }"
    }
    
    class EmptyAddress(
        ) : AddressException() {
        override val message
            get() = ""
    }
    

    


    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<AddressException> {
        override fun lift(error_buf: RustBuffer.ByValue): AddressException = FfiConverterTypeAddressError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeAddressError : FfiConverterRustBuffer<AddressException> {
    override fun read(buf: ByteBuffer): AddressException {
        

        return when(buf.getInt()) {
            1 -> AddressException.NoOutputs()
            2 -> AddressException.ScriptException(
                FfiConverterString.read(buf),
                )
            3 -> AddressException.InvalidAddress()
            4 -> AddressException.UnsupportedNetwork()
            5 -> AddressException.WrongNetwork(
                FfiConverterTypeNetwork.read(buf),
                FfiConverterTypeNetwork.read(buf),
                )
            6 -> AddressException.EmptyAddress()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AddressException): ULong {
        return when(value) {
            is AddressException.NoOutputs -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is AddressException.ScriptException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is AddressException.InvalidAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is AddressException.UnsupportedNetwork -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is AddressException.WrongNetwork -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterTypeNetwork.allocationSize(value.`current`)
                + FfiConverterTypeNetwork.allocationSize(value.`validFor`)
            )
            is AddressException.EmptyAddress -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }
    }

    override fun write(value: AddressException, buf: ByteBuffer) {
        when(value) {
            is AddressException.NoOutputs -> {
                buf.putInt(1)
                Unit
            }
            is AddressException.ScriptException -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is AddressException.InvalidAddress -> {
                buf.putInt(3)
                Unit
            }
            is AddressException.UnsupportedNetwork -> {
                buf.putInt(4)
                Unit
            }
            is AddressException.WrongNetwork -> {
                buf.putInt(5)
                FfiConverterTypeNetwork.write(value.`current`, buf)
                FfiConverterTypeNetwork.write(value.`validFor`, buf)
                Unit
            }
            is AddressException.EmptyAddress -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




enum class BitcoinUnit {
    
    BTC,
    SAT;

    

    // The local Rust `Display`/`Debug` implementation.
    override fun toString(): String {
        return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_bitcoinunit_uniffi_trait_display(FfiConverterTypeBitcoinUnit.lower(this),
        _status)
}
    )
    }

    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeBitcoinUnit: FfiConverterRustBuffer<BitcoinUnit> {
    override fun read(buf: ByteBuffer) = try {
        BitcoinUnit.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: BitcoinUnit) = 4UL

    override fun write(value: BitcoinUnit, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ColorSchemeSelection {
    
    LIGHT,
    DARK,
    SYSTEM;

    


    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeColorSchemeSelection: FfiConverterRustBuffer<ColorSchemeSelection> {
    override fun read(buf: ByteBuffer) = try {
        ColorSchemeSelection.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ColorSchemeSelection) = 4UL

    override fun write(value: ColorSchemeSelection, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class ConfirmDetailsException: kotlin.Exception() {
    
    class QrCodeCreation(
        
        val v1: kotlin.String
        ) : ConfirmDetailsException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    


    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ConfirmDetailsException> {
        override fun lift(error_buf: RustBuffer.ByValue): ConfirmDetailsException = FfiConverterTypeConfirmDetailsError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeConfirmDetailsError : FfiConverterRustBuffer<ConfirmDetailsException> {
    override fun read(buf: ByteBuffer): ConfirmDetailsException {
        

        return when(buf.getInt()) {
            1 -> ConfirmDetailsException.QrCodeCreation(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ConfirmDetailsException): ULong {
        return when(value) {
            is ConfirmDetailsException.QrCodeCreation -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: ConfirmDetailsException, buf: ByteBuffer) {
        when(value) {
            is ConfirmDetailsException.QrCodeCreation -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class FeeSpeed {
    
    object Fast : FeeSpeed()
    
    
    object Medium : FeeSpeed()
    
    
    object Slow : FeeSpeed()
    
    
    data class Custom(
        val `durationMins`: kotlin.UInt) : FeeSpeed()
        
    {
        

    // The local Rust `Display`/`Debug` implementation.
    override fun toString(): String {
        return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feespeed_uniffi_trait_display(FfiConverterTypeFeeSpeed.lower(this),
        _status)
}
    )
    }
        companion object
    }
    

    

    
    

    // The local Rust `Display`/`Debug` implementation.
    override fun toString(): String {
        return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_feespeed_uniffi_trait_display(FfiConverterTypeFeeSpeed.lower(this),
        _status)
}
    )
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFeeSpeed : FfiConverterRustBuffer<FeeSpeed>{
    override fun read(buf: ByteBuffer): FeeSpeed {
        return when(buf.getInt()) {
            1 -> FeeSpeed.Fast
            2 -> FeeSpeed.Medium
            3 -> FeeSpeed.Slow
            4 -> FeeSpeed.Custom(
                FfiConverterUInt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FeeSpeed) = when(value) {
        is FeeSpeed.Fast -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is FeeSpeed.Medium -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is FeeSpeed.Slow -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
            )
        }
        is FeeSpeed.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterUInt.allocationSize(value.`durationMins`)
            )
        }
    }

    override fun write(value: FeeSpeed, buf: ByteBuffer) {
        when(value) {
            is FeeSpeed.Fast -> {
                buf.putInt(1)
                Unit
            }
            is FeeSpeed.Medium -> {
                buf.putInt(2)
                Unit
            }
            is FeeSpeed.Slow -> {
                buf.putInt(3)
                Unit
            }
            is FeeSpeed.Custom -> {
                buf.putInt(4)
                FfiConverterUInt.write(value.`durationMins`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class FfiColor {
    
    data class Red(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Blue(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Green(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Yellow(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Orange(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Purple(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Pink(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class White(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Black(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Gray(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class CoolGray(
        val v1: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    
    data class Custom(
        val v1: org.bitcoinppl.cove_core.types.Rgb, 
        val v2: org.bitcoinppl.cove_core.types.FfiOpacity) : FfiColor()
        
    {
        

        companion object
    }
    

    

    
    


    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFfiColor : FfiConverterRustBuffer<FfiColor>{
    override fun read(buf: ByteBuffer): FfiColor {
        return when(buf.getInt()) {
            1 -> FfiColor.Red(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            2 -> FfiColor.Blue(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            3 -> FfiColor.Green(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            4 -> FfiColor.Yellow(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            5 -> FfiColor.Orange(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            6 -> FfiColor.Purple(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            7 -> FfiColor.Pink(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            8 -> FfiColor.White(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            9 -> FfiColor.Black(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            10 -> FfiColor.Gray(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            11 -> FfiColor.CoolGray(
                FfiConverterTypeFfiOpacity.read(buf),
                )
            12 -> FfiColor.Custom(
                FfiConverterTypeRgb.read(buf),
                FfiConverterTypeFfiOpacity.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: FfiColor) = when(value) {
        is FfiColor.Red -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Blue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Green -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Yellow -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Orange -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Purple -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Pink -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.White -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Black -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Gray -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.CoolGray -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeFfiOpacity.allocationSize(value.v1)
            )
        }
        is FfiColor.Custom -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4UL
                + FfiConverterTypeRgb.allocationSize(value.v1)
                + FfiConverterTypeFfiOpacity.allocationSize(value.v2)
            )
        }
    }

    override fun write(value: FfiColor, buf: ByteBuffer) {
        when(value) {
            is FfiColor.Red -> {
                buf.putInt(1)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Blue -> {
                buf.putInt(2)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Green -> {
                buf.putInt(3)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Yellow -> {
                buf.putInt(4)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Orange -> {
                buf.putInt(5)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Purple -> {
                buf.putInt(6)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Pink -> {
                buf.putInt(7)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.White -> {
                buf.putInt(8)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Black -> {
                buf.putInt(9)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Gray -> {
                buf.putInt(10)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.CoolGray -> {
                buf.putInt(11)
                FfiConverterTypeFfiOpacity.write(value.v1, buf)
                Unit
            }
            is FfiColor.Custom -> {
                buf.putInt(12)
                FfiConverterTypeRgb.write(value.v1, buf)
                FfiConverterTypeFfiOpacity.write(value.v2, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class FfiColorScheme {
    
    LIGHT,
    DARK;

    


    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeFfiColorScheme: FfiConverterRustBuffer<FfiColorScheme> {
    override fun read(buf: ByteBuffer) = try {
        FfiColorScheme.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: FfiColorScheme) = 4UL

    override fun write(value: FfiColorScheme, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class Network {
    
    BITCOIN,
    TESTNET,
    TESTNET4,
    SIGNET;

    

    // The local Rust `Display`/`Debug` implementation.
    override fun toString(): String {
        return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_network_uniffi_trait_display(FfiConverterTypeNetwork.lower(this),
        _status)
}
    )
    }

    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeNetwork: FfiConverterRustBuffer<Network> {
    override fun read(buf: ByteBuffer) = try {
        Network.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Network) = 4UL

    override fun write(value: Network, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class PsbtException: kotlin.Exception() {
    
    class MissingUtxo(
        ) : PsbtException() {
        override val message
            get() = ""
    }
    
    class NegativeFee(
        ) : PsbtException() {
        override val message
            get() = ""
    }
    
    class FeeOverflow(
        ) : PsbtException() {
        override val message
            get() = ""
    }
    
    class Other(
        
        val v1: kotlin.String
        ) : PsbtException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    


    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PsbtException> {
        override fun lift(error_buf: RustBuffer.ByValue): PsbtException = FfiConverterTypePsbtError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypePsbtError : FfiConverterRustBuffer<PsbtException> {
    override fun read(buf: ByteBuffer): PsbtException {
        

        return when(buf.getInt()) {
            1 -> PsbtException.MissingUtxo()
            2 -> PsbtException.NegativeFee()
            3 -> PsbtException.FeeOverflow()
            4 -> PsbtException.Other(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PsbtException): ULong {
        return when(value) {
            is PsbtException.MissingUtxo -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PsbtException.NegativeFee -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PsbtException.FeeOverflow -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PsbtException.Other -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: PsbtException, buf: ByteBuffer) {
        when(value) {
            is PsbtException.MissingUtxo -> {
                buf.putInt(1)
                Unit
            }
            is PsbtException.NegativeFee -> {
                buf.putInt(2)
                Unit
            }
            is PsbtException.FeeOverflow -> {
                buf.putInt(3)
                Unit
            }
            is PsbtException.Other -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



/**
 * QR code export format for PSBTs
 */

enum class QrExportFormat {
    
    /**
     * BBQr format (Binary Bitcoin QR)
     */
    BBQR,
    /**
     * UR format (Uniform Resources)
     */
    UR;

    

    // The local Rust `Display`/`Debug` implementation.
    override fun toString(): String {
        return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_method_qrexportformat_uniffi_trait_display(FfiConverterTypeQrExportFormat.lower(this),
        _status)
}
    )
    }

    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeQrExportFormat: FfiConverterRustBuffer<QrExportFormat> {
    override fun read(buf: ByteBuffer) = try {
        QrExportFormat.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: QrExportFormat) = 4UL

    override fun write(value: QrExportFormat, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class TransactionDirection {
    
    INCOMING,
    OUTGOING;

    


    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeTransactionDirection: FfiConverterRustBuffer<TransactionDirection> {
    override fun read(buf: ByteBuffer) = try {
        TransactionDirection.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: TransactionDirection) = 4UL

    override fun write(value: TransactionDirection, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class UtxoType {
    
    OUTPUT,
    CHANGE;

    


    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeUtxoType: FfiConverterRustBuffer<UtxoType> {
    override fun read(buf: ByteBuffer) = try {
        UtxoType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: UtxoType) = 4UL

    override fun write(value: UtxoType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






/**
 * @suppress
 */
public object FfiConverterOptionalString: FfiConverterRustBuffer<kotlin.String?> {
    override fun read(buf: ByteBuffer): kotlin.String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: kotlin.String?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: kotlin.String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeAmount: FfiConverterRustBuffer<Amount?> {
    override fun read(buf: ByteBuffer): Amount? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAmount.read(buf)
    }

    override fun allocationSize(value: Amount?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeAmount.allocationSize(value)
        }
    }

    override fun write(value: Amount?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAmount.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeFeeRateOptionWithTotalFee: FfiConverterRustBuffer<FeeRateOptionWithTotalFee?> {
    override fun read(buf: ByteBuffer): FeeRateOptionWithTotalFee? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeFeeRateOptionWithTotalFee.read(buf)
    }

    override fun allocationSize(value: FeeRateOptionWithTotalFee?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeFeeRateOptionWithTotalFee.allocationSize(value)
        }
    }

    override fun write(value: FeeRateOptionWithTotalFee?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeFeeRateOptionWithTotalFee.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeUtxoType: FfiConverterRustBuffer<UtxoType?> {
    override fun read(buf: ByteBuffer): UtxoType? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeUtxoType.read(buf)
    }

    override fun allocationSize(value: UtxoType?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeUtxoType.allocationSize(value)
        }
    }

    override fun write(value: UtxoType?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeUtxoType.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceString: FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeAddressAndAmount: FfiConverterRustBuffer<List<AddressAndAmount>> {
    override fun read(buf: ByteBuffer): List<AddressAndAmount> {
        val len = buf.getInt()
        return List<AddressAndAmount>(len) {
            FfiConverterTypeAddressAndAmount.read(buf)
        }
    }

    override fun allocationSize(value: List<AddressAndAmount>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeAddressAndAmount.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<AddressAndAmount>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeAddressAndAmount.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer<List<Utxo>> {
    override fun read(buf: ByteBuffer): List<Utxo> {
        val len = buf.getInt()
        return List<Utxo>(len) {
            FfiConverterTypeUtxo.read(buf)
        }
    }

    override fun allocationSize(value: List<Utxo>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeUtxo.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Utxo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeUtxo.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeBitcoinUnit: FfiConverterRustBuffer<List<BitcoinUnit>> {
    override fun read(buf: ByteBuffer): List<BitcoinUnit> {
        val len = buf.getInt()
        return List<BitcoinUnit>(len) {
            FfiConverterTypeBitcoinUnit.read(buf)
        }
    }

    override fun allocationSize(value: List<BitcoinUnit>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeBitcoinUnit.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<BitcoinUnit>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeBitcoinUnit.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeColorSchemeSelection: FfiConverterRustBuffer<List<ColorSchemeSelection>> {
    override fun read(buf: ByteBuffer): List<ColorSchemeSelection> {
        val len = buf.getInt()
        return List<ColorSchemeSelection>(len) {
            FfiConverterTypeColorSchemeSelection.read(buf)
        }
    }

    override fun allocationSize(value: List<ColorSchemeSelection>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeColorSchemeSelection.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ColorSchemeSelection>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeColorSchemeSelection.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer<List<Network>> {
    override fun read(buf: ByteBuffer): List<Network> {
        val len = buf.getInt()
        return List<Network>(len) {
            FfiConverterTypeNetwork.read(buf)
        }
    }

    override fun allocationSize(value: List<Network>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeNetwork.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Network>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeNetwork.write(it, buf)
        }
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias FfiOpacity = kotlin.UByte
public typealias FfiConverterTypeFfiOpacity = FfiConverterUByte



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias WalletId = kotlin.String
public typealias FfiConverterTypeWalletId = FfiConverterString
    @Throws(AddressException::class) fun `addressIsValid`(`address`: kotlin.String, `network`: Network)
        = 
    uniffiRustCallWithError(AddressException) { _status ->
    UniffiLib.uniffi_cove_types_fn_func_address_is_valid(
    
        FfiConverterString.lower(`address`),FfiConverterTypeNetwork.lower(`network`),_status)
}
    
    

    @Throws(AddressException::class) fun `addressIsValidForNetwork`(`address`: kotlin.String, `network`: Network)
        = 
    uniffiRustCallWithError(AddressException) { _status ->
    UniffiLib.uniffi_cove_types_fn_func_address_is_valid_for_network(
    
        FfiConverterString.lower(`address`),FfiConverterTypeNetwork.lower(`network`),_status)
}
    
    
 fun `addressStringSpacedOut`(`address`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_address_string_spaced_out(
    
        FfiConverterString.lower(`address`),_status)
}
    )
    }
    
 fun `allColorSchemes`(): List<ColorSchemeSelection> {
            return FfiConverterSequenceTypeColorSchemeSelection.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_all_color_schemes(
    
        _status)
}
    )
    }
    
 fun `colorSchemeSelectionCapitalizedString`(`colorScheme`: ColorSchemeSelection): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_color_scheme_selection_capitalized_string(
    
        FfiConverterTypeColorSchemeSelection.lower(`colorScheme`),_status)
}
    )
    }
    

        /**
         * Preview ConfirmDetails for SwiftUI previews
         */ fun `confirmDetailsPreviewNew`(): ConfirmDetails {
            return FfiConverterTypeConfirmDetails.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_confirm_details_preview_new(
    
        _status)
}
    )
    }
    

        /**
         * Check if two QrDensity values are equal (for Swift Equatable conformance)
         */ fun `qrDensityIsEqual`(`lhs`: QrDensity, `rhs`: QrDensity): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_qr_density_is_equal(
    
        FfiConverterTypeQrDensity.lower(`lhs`),FfiConverterTypeQrDensity.lower(`rhs`),_status)
}
    )
    }
    
 fun `feeRateOptionsWithTotalFeeIsEqual`(`lhs`: FeeRateOptionsWithTotalFee, `rhs`: FeeRateOptionsWithTotalFee): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_fee_rate_options_with_total_fee_is_equal(
    
        FfiConverterTypeFeeRateOptionsWithTotalFee.lower(`lhs`),FfiConverterTypeFeeRateOptionsWithTotalFee.lower(`rhs`),_status)
}
    )
    }
    
 fun `feeSpeedDuration`(`feeSpeed`: FeeSpeed): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_fee_speed_duration(
    
        FfiConverterTypeFeeSpeed.lower(`feeSpeed`),_status)
}
    )
    }
    
 fun `feeSpeedIsCustom`(`feeSpeed`: FeeSpeed): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_fee_speed_is_custom(
    
        FfiConverterTypeFeeSpeed.lower(`feeSpeed`),_status)
}
    )
    }
    
 fun `feeSpeedToCircleColor`(`feeSpeed`: FeeSpeed): FfiColor {
            return FfiConverterTypeFfiColor.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_fee_speed_to_circle_color(
    
        FfiConverterTypeFeeSpeed.lower(`feeSpeed`),_status)
}
    )
    }
    
 fun `allNetworks`(): List<Network> {
            return FfiConverterSequenceTypeNetwork.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_all_networks(
    
        _status)
}
    )
    }
    
 fun `networkToString`(`network`: Network): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_network_to_string(
    
        FfiConverterTypeNetwork.lower(`network`),_status)
}
    )
    }
    
 fun `allUnits`(): List<BitcoinUnit> {
            return FfiConverterSequenceTypeBitcoinUnit.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_all_units(
    
        _status)
}
    )
    }
    
 fun `previewNewUtxoList`(`outputCount`: kotlin.UByte, `changeCount`: kotlin.UByte): List<Utxo> {
            return FfiConverterSequenceTypeUtxo.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_previewnewutxolist(
    
        FfiConverterUByte.lower(`outputCount`),FfiConverterUByte.lower(`changeCount`),_status)
}
    )
    }
    
 fun `utxoDate`(`utxo`: Utxo): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_utxo_date(
    
        FfiConverterTypeUtxo.lower(`utxo`),_status)
}
    )
    }
    
 fun `utxoHashToUint`(`utxo`: Utxo): kotlin.ULong {
            return FfiConverterULong.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_utxo_hash_to_uint(
    
        FfiConverterTypeUtxo.lower(`utxo`),_status)
}
    )
    }
    
 fun `utxoIsEqual`(`lhs`: Utxo, `rhs`: Utxo): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_utxo_is_equal(
    
        FfiConverterTypeUtxo.lower(`lhs`),FfiConverterTypeUtxo.lower(`rhs`),_status)
}
    )
    }
    
 fun `utxoName`(`utxo`: Utxo): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.uniffi_cove_types_fn_func_utxo_name(
    
        FfiConverterTypeUtxo.lower(`utxo`),_status)
}
    )
    }
    


