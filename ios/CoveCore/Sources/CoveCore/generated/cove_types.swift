// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cove_typesFFI)
import cove_typesFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cove_types_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cove_types_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureCoveTypesInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AddressProtocol: AnyObject, Sendable {
    
    func hashToUint()  -> UInt64
    
    func spacedOut()  -> String
    
    func string()  -> String
    
    func unformatted()  -> String
    
}
open class Address: AddressProtocol, @unchecked Sendable, Equatable, Hashable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_address(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_address(handle, $0) }
    }

    
public static func fromString(address: String, network: Network)throws  -> Address  {
    return try  FfiConverterTypeAddress_lift(try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_constructor_address_from_string(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func previewNew() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_address_preview_new($0
    )
})
}
    
public static func random() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_address_random($0
    )
})
}
    

    
open func hashToUint() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_hashtouint(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func spacedOut() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_spaced_out(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func string() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_string(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func unformatted() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_unformatted(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: Address, other: Address) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_address_uniffi_trait_eq_eq(
            self.uniffiCloneHandle(),
        FfiConverterTypeAddress_lower(other),$0
    )
}
    )
}
// The local Rust `Hash` implementation
public func hash(into hasher: inout Hasher) {
    let val = try!  FfiConverterUInt64.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_address_uniffi_trait_hash(
            self.uniffiCloneHandle(),$0
    )
}
    )
    hasher.combine(val)
}
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Address

    public static func lift(_ handle: UInt64) throws -> Address {
        return Address(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Address) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ handle: UInt64) throws -> Address {
    return try FfiConverterTypeAddress.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> UInt64 {
    return FfiConverterTypeAddress.lower(value)
}






public protocol AddressInfoProtocol: AnyObject, Sendable {
    
    func address()  -> Address
    
    func addressUnformatted()  -> String
    
    func index()  -> UInt32
    
}
open class AddressInfo: AddressInfoProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_addressinfo(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_addressinfo(handle, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfo_address(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func addressUnformatted() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfo_address_unformatted(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func index() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfo_index(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressInfo: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = AddressInfo

    public static func lift(_ handle: UInt64) throws -> AddressInfo {
        return AddressInfo(unsafeFromHandle: handle)
    }

    public static func lower(_ value: AddressInfo) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lift(_ handle: UInt64) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> UInt64 {
    return FfiConverterTypeAddressInfo.lower(value)
}






public protocol AddressInfoWithDerivationProtocol: AnyObject, Sendable {
    
    func address()  -> Address
    
    func addressSpacedOut()  -> String
    
    func addressUnformatted()  -> String
    
    func derivationPath()  -> String?
    
    func index()  -> UInt32
    
}
open class AddressInfoWithDerivation: AddressInfoWithDerivationProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_addressinfowithderivation(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_addressinfowithderivation(handle, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfowithderivation_address(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func addressSpacedOut() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfowithderivation_address_spaced_out(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func addressUnformatted() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfowithderivation_address_unformatted(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func derivationPath() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfowithderivation_derivation_path(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func index() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfowithderivation_index(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressInfoWithDerivation: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = AddressInfoWithDerivation

    public static func lift(_ handle: UInt64) throws -> AddressInfoWithDerivation {
        return AddressInfoWithDerivation(unsafeFromHandle: handle)
    }

    public static func lower(_ value: AddressInfoWithDerivation) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfoWithDerivation {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: AddressInfoWithDerivation, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfoWithDerivation_lift(_ handle: UInt64) throws -> AddressInfoWithDerivation {
    return try FfiConverterTypeAddressInfoWithDerivation.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfoWithDerivation_lower(_ value: AddressInfoWithDerivation) -> UInt64 {
    return FfiConverterTypeAddressInfoWithDerivation.lower(value)
}






public protocol AddressWithNetworkProtocol: AnyObject, Sendable {
    
    func address()  -> Address
    
    func amount()  -> Amount?
    
    func isValidForNetwork(network: Network)  -> Bool
    
    func network()  -> Network
    
}
open class AddressWithNetwork: AddressWithNetworkProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_addresswithnetwork(self.handle, $0) }
    }
public convenience init(address: String)throws  {
    let handle =
        try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_constructor_addresswithnetwork_new(
        FfiConverterString.lower(address),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_addresswithnetwork(handle, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_address(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amount() -> Amount?  {
    return try!  FfiConverterOptionTypeAmount.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isValidForNetwork(network: Network) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_isvalidfornetwork(
            self.uniffiCloneHandle(),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_network(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressWithNetwork: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = AddressWithNetwork

    public static func lift(_ handle: UInt64) throws -> AddressWithNetwork {
        return AddressWithNetwork(unsafeFromHandle: handle)
    }

    public static func lower(_ value: AddressWithNetwork) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressWithNetwork {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: AddressWithNetwork, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressWithNetwork_lift(_ handle: UInt64) throws -> AddressWithNetwork {
    return try FfiConverterTypeAddressWithNetwork.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressWithNetwork_lower(_ value: AddressWithNetwork) -> UInt64 {
    return FfiConverterTypeAddressWithNetwork.lower(value)
}






public protocol AmountProtocol: AnyObject, Sendable {
    
    func asBtc()  -> Double
    
    func asSats()  -> UInt64
    
    func btcString()  -> String
    
    func btcStringWithUnit()  -> String
    
    func fmtString(unit: BitcoinUnit)  -> String
    
    func fmtStringWithUnit(unit: BitcoinUnit)  -> String
    
    func satsString()  -> String
    
    func satsStringWithUnit()  -> String
    
}
open class Amount: AmountProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_amount(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_amount(handle, $0) }
    }

    
public static func fromSat(sats: UInt64) -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_amount_from_sat(
        FfiConverterUInt64.lower(sats),$0
    )
})
}
    
public static func oneBtc() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_amount_one_btc($0
    )
})
}
    
public static func oneSat() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_amount_one_sat($0
    )
})
}
    

    
open func asBtc() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_as_btc(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func asSats() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_as_sats(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func btcString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_btc_string(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func btcStringWithUnit() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_btc_string_with_unit(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func fmtString(unit: BitcoinUnit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_fmt_string(
            self.uniffiCloneHandle(),
        FfiConverterTypeBitcoinUnit_lower(unit),$0
    )
})
}
    
open func fmtStringWithUnit(unit: BitcoinUnit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_fmt_string_with_unit(
            self.uniffiCloneHandle(),
        FfiConverterTypeBitcoinUnit_lower(unit),$0
    )
})
}
    
open func satsString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_sats_string(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func satsStringWithUnit() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_sats_string_with_unit(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Amount

    public static func lift(_ handle: UInt64) throws -> Amount {
        return Amount(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Amount) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ handle: UInt64) throws -> Amount {
    return try FfiConverterTypeAmount.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> UInt64 {
    return FfiConverterTypeAmount.lower(value)
}






public protocol ChainPositionProtocol: AnyObject, Sendable {
    
}
open class ChainPosition: ChainPositionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_chainposition(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_chainposition(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainPosition: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ChainPosition

    public static func lift(_ handle: UInt64) throws -> ChainPosition {
        return ChainPosition(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ChainPosition) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainPosition {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ChainPosition, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lift(_ handle: UInt64) throws -> ChainPosition {
    return try FfiConverterTypeChainPosition.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lower(_ value: ChainPosition) -> UInt64 {
    return FfiConverterTypeChainPosition.lower(value)
}






public protocol ConfirmDetailsProtocol: AnyObject, Sendable {
    
    func feePercentage()  -> UInt64
    
    func feeRate()  -> FeeRate
    
    func feeTotal()  -> Amount
    
    func id()  -> TxId
    
    func idHash()  -> String
    
    func inputs()  -> [AddressAndAmount]
    
    func normalizedId()  -> String
    
    func outputs()  -> [AddressAndAmount]
    
    func psbt()  -> Psbt
    
    func psbtBytes()  -> Data
    
    func psbtToBbqr() throws  -> [String]
    
    func psbtToHex()  -> String
    
    /**
     * Export PSBT as UR-encoded QR strings for animated display
     */
    func psbtToUr(maxFragmentLen: UInt32) throws  -> [String]
    
    /**
     * Export PSBT as single UR string (for small PSBTs)
     */
    func psbtToUrSingle() throws  -> String
    
    func sendingAmount()  -> Amount
    
    func sendingTo()  -> Address
    
    func spendingAmount()  -> Amount
    
}
open class ConfirmDetails: ConfirmDetailsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_confirmdetails(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_confirmdetails(handle, $0) }
    }

    
public static func previewNew(amount: UInt64 = UInt64(20448)) -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_confirmdetails_previewnew(
        FfiConverterUInt64.lower(amount),$0
    )
})
}
    

    
open func feePercentage() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_fee_percentage(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_fee_rate(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeTotal() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_fee_total(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func idHash() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_id_hash(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func inputs() -> [AddressAndAmount]  {
    return try!  FfiConverterSequenceTypeAddressAndAmount.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_inputs(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func normalizedId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_normalized_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func outputs() -> [AddressAndAmount]  {
    return try!  FfiConverterSequenceTypeAddressAndAmount.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_outputs(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func psbt() -> Psbt  {
    return try!  FfiConverterTypePsbt_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_psbt(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func psbtBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_psbt_bytes(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func psbtToBbqr()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeConfirmDetailsError_lift) {
    uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func psbtToHex() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_psbt_to_hex(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Export PSBT as UR-encoded QR strings for animated display
     */
open func psbtToUr(maxFragmentLen: UInt32)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeConfirmDetailsError_lift) {
    uniffi_cove_types_fn_method_confirmdetails_psbt_to_ur(
            self.uniffiCloneHandle(),
        FfiConverterUInt32.lower(maxFragmentLen),$0
    )
})
}
    
    /**
     * Export PSBT as single UR string (for small PSBTs)
     */
open func psbtToUrSingle()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeConfirmDetailsError_lift) {
    uniffi_cove_types_fn_method_confirmdetails_psbt_to_ur_single(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_sending_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sendingTo() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_sending_to(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func spendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_spending_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmDetails: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ConfirmDetails

    public static func lift(_ handle: UInt64) throws -> ConfirmDetails {
        return ConfirmDetails(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ConfirmDetails) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmDetails {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ConfirmDetails, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetails_lift(_ handle: UInt64) throws -> ConfirmDetails {
    return try FfiConverterTypeConfirmDetails.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetails_lower(_ value: ConfirmDetails) -> UInt64 {
    return FfiConverterTypeConfirmDetails.lower(value)
}






public protocol FeeRateProtocol: AnyObject, Sendable {
    
    func satPerVb()  -> Float
    
}
open class FeeRate: FeeRateProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_feerate(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerate(handle, $0) }
    }

    
public static func fromSatPerVb(satPerVb: Float) -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_feerate_from_sat_per_vb(
        FfiConverterFloat.lower(satPerVb),$0
    )
})
}
    

    
open func satPerVb() -> Float  {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerate_sat_per_vb(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRate: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FeeRate

    public static func lift(_ handle: UInt64) throws -> FeeRate {
        return FeeRate(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FeeRate) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lift(_ handle: UInt64) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UInt64 {
    return FfiConverterTypeFeeRate.lower(value)
}






public protocol FeeRateOptionProtocol: AnyObject, Sendable {
    
    func duration()  -> String
    
    func feeRate()  -> FeeRate
    
    func feeSpeed()  -> FeeSpeed
    
    func isEqual(rhs: FeeRateOption)  -> Bool
    
    func satPerVb()  -> Float
    
}
open class FeeRateOption: FeeRateOptionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoption(self.handle, $0) }
    }
public convenience init(feeSpeed: FeeSpeed, feeRate: Float) {
    let handle =
        try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoption_new(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),
        FfiConverterFloat.lower(feeRate),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoption(handle, $0) }
    }

    

    
open func duration() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_duration(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_fee_rate(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeSpeed() -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_fee_speed(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isEqual(rhs: FeeRateOption) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_is_equal(
            self.uniffiCloneHandle(),
        FfiConverterTypeFeeRateOption_lower(rhs),$0
    )
})
}
    
open func satPerVb() -> Float  {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_sat_per_vb(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOption: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FeeRateOption

    public static func lift(_ handle: UInt64) throws -> FeeRateOption {
        return FeeRateOption(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FeeRateOption) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOption {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FeeRateOption, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOption_lift(_ handle: UInt64) throws -> FeeRateOption {
    return try FfiConverterTypeFeeRateOption.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOption_lower(_ value: FeeRateOption) -> UInt64 {
    return FfiConverterTypeFeeRateOption.lower(value)
}






public protocol FeeRateOptionWithTotalFeeProtocol: AnyObject, Sendable {
    
    func duration()  -> String
    
    func feeRate()  -> FeeRate
    
    func feeRateOptions()  -> FeeRateOption
    
    func feeSpeed()  -> FeeSpeed
    
    func isCustom()  -> Bool
    
    func isEqual(rhs: FeeRateOptionWithTotalFee)  -> Bool
    
    func satPerVb()  -> Float
    
    func totalFee()  -> Amount
    
}
open class FeeRateOptionWithTotalFee: FeeRateOptionWithTotalFeeProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoptionwithtotalfee(self.handle, $0) }
    }
public convenience init(feeSpeed: FeeSpeed, feeRate: FeeRate, totalFee: Amount) {
    let handle =
        try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoptionwithtotalfee_new(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),
        FfiConverterTypeFeeRate_lower(feeRate),
        FfiConverterTypeAmount_lower(totalFee),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoptionwithtotalfee(handle, $0) }
    }

    

    
open func duration() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_duration(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeRateOptions() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate_options(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeSpeed() -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_speed(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isCustom() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_custom(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isEqual(rhs: FeeRateOptionWithTotalFee) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_equal(
            self.uniffiCloneHandle(),
        FfiConverterTypeFeeRateOptionWithTotalFee_lower(rhs),$0
    )
})
}
    
open func satPerVb() -> Float  {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_sat_per_vb(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func totalFee() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_total_fee(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptionWithTotalFee: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FeeRateOptionWithTotalFee

    public static func lift(_ handle: UInt64) throws -> FeeRateOptionWithTotalFee {
        return FeeRateOptionWithTotalFee(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FeeRateOptionWithTotalFee) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptionWithTotalFee {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FeeRateOptionWithTotalFee, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionWithTotalFee_lift(_ handle: UInt64) throws -> FeeRateOptionWithTotalFee {
    return try FfiConverterTypeFeeRateOptionWithTotalFee.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionWithTotalFee_lower(_ value: FeeRateOptionWithTotalFee) -> UInt64 {
    return FfiConverterTypeFeeRateOptionWithTotalFee.lower(value)
}






public protocol FeeRateOptionsProtocol: AnyObject, Sendable {
    
    func fast()  -> FeeRateOption
    
    func medium()  -> FeeRateOption
    
    func slow()  -> FeeRateOption
    
}
open class FeeRateOptions: FeeRateOptionsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoptions(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoptions(handle, $0) }
    }

    
public static func previewNew() -> FeeRateOptions  {
    return try!  FfiConverterTypeFeeRateOptions_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoptions_previewnew($0
    )
})
}
    

    
open func fast() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptions_fast(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func medium() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptions_medium(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func slow() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptions_slow(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptions: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FeeRateOptions

    public static func lift(_ handle: UInt64) throws -> FeeRateOptions {
        return FeeRateOptions(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FeeRateOptions) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptions {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FeeRateOptions, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptions_lift(_ handle: UInt64) throws -> FeeRateOptions {
    return try FfiConverterTypeFeeRateOptions.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptions_lower(_ value: FeeRateOptions) -> UInt64 {
    return FfiConverterTypeFeeRateOptions.lower(value)
}






public protocol FeeRateOptionsWithTotalFeeProtocol: AnyObject, Sendable {
    
    func addCustomFeeRate(feeRate: FeeRateOptionWithTotalFee)  -> FeeRateOptionsWithTotalFee
    
    func calculateCustomFeeSpeed(feeRate: Float)  -> FeeSpeed
    
    func custom()  -> FeeRateOptionWithTotalFee?
    
    func fast()  -> FeeRateOptionWithTotalFee
    
    func feeRateOptions()  -> FeeRateOptions
    
    func getFeeRateWith(feeRate: Float)  -> FeeRateOptionWithTotalFee?
    
    func medium()  -> FeeRateOptionWithTotalFee
    
    func removeCustomFee()  -> FeeRateOptionsWithTotalFee
    
    func slow()  -> FeeRateOptionWithTotalFee
    
    func transactionSize()  -> UInt64
    
}
open class FeeRateOptionsWithTotalFee: FeeRateOptionsWithTotalFeeProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoptionswithtotalfee(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoptionswithtotalfee(handle, $0) }
    }

    
public static func previewNew() -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoptionswithtotalfee_previewnew($0
    )
})
}
    

    
open func addCustomFeeRate(feeRate: FeeRateOptionWithTotalFee) -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_add_custom_fee_rate(
            self.uniffiCloneHandle(),
        FfiConverterTypeFeeRateOptionWithTotalFee_lower(feeRate),$0
    )
})
}
    
open func calculateCustomFeeSpeed(feeRate: Float) -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_calculate_custom_fee_speed(
            self.uniffiCloneHandle(),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func custom() -> FeeRateOptionWithTotalFee?  {
    return try!  FfiConverterOptionTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_custom(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func fast() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fast(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeRateOptions() -> FeeRateOptions  {
    return try!  FfiConverterTypeFeeRateOptions_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fee_rate_options(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func getFeeRateWith(feeRate: Float) -> FeeRateOptionWithTotalFee?  {
    return try!  FfiConverterOptionTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_get_fee_rate_with(
            self.uniffiCloneHandle(),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func medium() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_medium(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func removeCustomFee() -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_remove_custom_fee(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func slow() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_slow(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func transactionSize() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_transaction_size(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptionsWithTotalFee: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FeeRateOptionsWithTotalFee

    public static func lift(_ handle: UInt64) throws -> FeeRateOptionsWithTotalFee {
        return FeeRateOptionsWithTotalFee(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FeeRateOptionsWithTotalFee) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptionsWithTotalFee {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FeeRateOptionsWithTotalFee, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionsWithTotalFee_lift(_ handle: UInt64) throws -> FeeRateOptionsWithTotalFee {
    return try FfiConverterTypeFeeRateOptionsWithTotalFee.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionsWithTotalFee_lower(_ value: FeeRateOptionsWithTotalFee) -> UInt64 {
    return FfiConverterTypeFeeRateOptionsWithTotalFee.lower(value)
}






public protocol InputOutputDetailsProtocol: AnyObject, Sendable {
    
}
open class InputOutputDetails: InputOutputDetailsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_inputoutputdetails(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_inputoutputdetails(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInputOutputDetails: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = InputOutputDetails

    public static func lift(_ handle: UInt64) throws -> InputOutputDetails {
        return InputOutputDetails(unsafeFromHandle: handle)
    }

    public static func lower(_ value: InputOutputDetails) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputOutputDetails {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: InputOutputDetails, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputOutputDetails_lift(_ handle: UInt64) throws -> InputOutputDetails {
    return try FfiConverterTypeInputOutputDetails.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputOutputDetails_lower(_ value: InputOutputDetails) -> UInt64 {
    return FfiConverterTypeInputOutputDetails.lower(value)
}






public protocol OutPointProtocol: AnyObject, Sendable {
    
    func eq(rhs: OutPoint)  -> Bool
    
    func hashToUint()  -> UInt64
    
    func txid()  -> TxId
    
    func txidStr()  -> String
    
    func txnLink()  -> String
    
}
open class OutPoint: OutPointProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_outpoint(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_outpoint(handle, $0) }
    }

    
public static func previewNew() -> OutPoint  {
    return try!  FfiConverterTypeOutPoint_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_outpoint_previewnew($0
    )
})
}
    
public static func withVout(vout: UInt32) -> OutPoint  {
    return try!  FfiConverterTypeOutPoint_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_outpoint_withvout(
        FfiConverterUInt32.lower(vout),$0
    )
})
}
    

    
open func eq(rhs: OutPoint) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_outpoint_eq(
            self.uniffiCloneHandle(),
        FfiConverterTypeOutPoint_lower(rhs),$0
    )
})
}
    
open func hashToUint() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_outpoint_hashtouint(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txid() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_types_fn_method_outpoint_txid(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txidStr() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_outpoint_txid_str(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txnLink() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_outpoint_txn_link(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutPoint: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = OutPoint

    public static func lift(_ handle: UInt64) throws -> OutPoint {
        return OutPoint(unsafeFromHandle: handle)
    }

    public static func lower(_ value: OutPoint) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lift(_ handle: UInt64) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> UInt64 {
    return FfiConverterTypeOutPoint.lower(value)
}






public protocol PsbtProtocol: AnyObject, Sendable {
    
    /**
     * Total fee in sats.
     */
    func fee() throws  -> Amount
    
    /**
     * Get total sending amount of all outputs
     */
    func outputTotalAmount()  -> Amount
    
    /**
     * Get the transaction id of the unsigned transaction
     */
    func txId()  -> TxId
    
    /**
     * The virtual size of the transaction.
     */
    func weight()  -> UInt64
    
}
open class Psbt: PsbtProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_psbt(self.handle, $0) }
    }
public convenience init(data: Data)throws  {
    let handle =
        try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_cove_types_fn_constructor_psbt_new(
        FfiConverterData.lower(data),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_psbt(handle, $0) }
    }

    

    
    /**
     * Total fee in sats.
     */
open func fee()throws  -> Amount  {
    return try  FfiConverterTypeAmount_lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_cove_types_fn_method_psbt_fee(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get total sending amount of all outputs
     */
open func outputTotalAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_psbt_output_total_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the transaction id of the unsigned transaction
     */
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_types_fn_method_psbt_tx_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * The virtual size of the transaction.
     */
open func weight() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_psbt_weight(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbt: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Psbt

    public static func lift(_ handle: UInt64) throws -> Psbt {
        return Psbt(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Psbt) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Psbt {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Psbt, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lift(_ handle: UInt64) throws -> Psbt {
    return try FfiConverterTypePsbt.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lower(_ value: Psbt) -> UInt64 {
    return FfiConverterTypePsbt.lower(value)
}






public protocol SentAndReceivedProtocol: AnyObject, Sendable {
    
    func amount()  -> Amount
    
    func amountFmt(unit: BitcoinUnit)  -> String
    
    func direction()  -> TransactionDirection
    
    func externalSent()  -> Amount
    
    func label()  -> String
    
    func received()  -> Amount
    
    func sent()  -> Amount
    
}
open class SentAndReceived: SentAndReceivedProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_sentandreceived(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_sentandreceived(handle, $0) }
    }

    

    
open func amount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amountFmt(unit: BitcoinUnit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_amount_fmt(
            self.uniffiCloneHandle(),
        FfiConverterTypeBitcoinUnit_lower(unit),$0
    )
})
}
    
open func direction() -> TransactionDirection  {
    return try!  FfiConverterTypeTransactionDirection_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_direction(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func externalSent() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_external_sent(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_label(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func received() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_received(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sent() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_sent(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSentAndReceived: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SentAndReceived

    public static func lift(_ handle: UInt64) throws -> SentAndReceived {
        return SentAndReceived(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SentAndReceived) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SentAndReceived {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SentAndReceived, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceived_lift(_ handle: UInt64) throws -> SentAndReceived {
    return try FfiConverterTypeSentAndReceived.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceived_lower(_ value: SentAndReceived) -> UInt64 {
    return FfiConverterTypeSentAndReceived.lower(value)
}






public protocol TxIdProtocol: AnyObject, Sendable {
    
    func asHashString()  -> String
    
}
open class TxId: TxIdProtocol, @unchecked Sendable, Equatable, Hashable, Comparable, CustomStringConvertible {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_txid(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_txid(handle, $0) }
    }

    

    
open func asHashString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_txid_as_hash_string(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_txid_uniffi_trait_display(
            self.uniffiCloneHandle(),$0
    )
}
    )
}
// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: TxId, other: TxId) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_txid_uniffi_trait_eq_eq(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(other),$0
    )
}
    )
}
// The local Rust `Hash` implementation
public func hash(into hasher: inout Hasher) {
    let val = try!  FfiConverterUInt64.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_txid_uniffi_trait_hash(
            self.uniffiCloneHandle(),$0
    )
}
    )
    hasher.combine(val)
}
// The local Rust `Ord` implementation
public static func < (self: TxId, other: TxId) -> Bool {
    return try!  FfiConverterInt8.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_txid_uniffi_trait_ord_cmp(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(other),$0
    )
}
    ) < 0
}
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxId: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TxId

    public static func lift(_ handle: UInt64) throws -> TxId {
        return TxId(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TxId) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxId {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TxId, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxId_lift(_ handle: UInt64) throws -> TxId {
    return try FfiConverterTypeTxId.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxId_lower(_ value: TxId) -> UInt64 {
    return FfiConverterTypeTxId.lower(value)
}






public protocol TxInProtocol: AnyObject, Sendable {
    
}
open class TxIn: TxInProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_txin(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_txin(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxIn: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TxIn

    public static func lift(_ handle: UInt64) throws -> TxIn {
        return TxIn(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TxIn) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lift(_ handle: UInt64) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> UInt64 {
    return FfiConverterTypeTxIn.lower(value)
}






public protocol TxOutProtocol: AnyObject, Sendable {
    
}
open class TxOut: TxOutProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_txout(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_txout(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxOut: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TxOut

    public static func lift(_ handle: UInt64) throws -> TxOut {
        return TxOut(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TxOut) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lift(_ handle: UInt64) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> UInt64 {
    return FfiConverterTypeTxOut.lower(value)
}






public protocol UtxoListProtocol: AnyObject, Sendable {
    
}
open class UtxoList: UtxoListProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_types_fn_clone_utxolist(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_utxolist(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxoList: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UtxoList

    public static func lift(_ handle: UInt64) throws -> UtxoList {
        return UtxoList(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UtxoList) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UtxoList {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UtxoList, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxoList_lift(_ handle: UInt64) throws -> UtxoList {
    return try FfiConverterTypeUtxoList.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxoList_lower(_ value: UtxoList) -> UInt64 {
    return FfiConverterTypeUtxoList.lower(value)
}




public struct AddressAndAmount {
    public var label: String?
    public var utxoType: UtxoType?
    public var address: Address
    public var amount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(label: String?, utxoType: UtxoType?, address: Address, amount: Amount) {
        self.label = label
        self.utxoType = utxoType
        self.address = address
        self.amount = amount
    }

    

    
}

#if compiler(>=6)
extension AddressAndAmount: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressAndAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressAndAmount {
        return
            try AddressAndAmount(
                label: FfiConverterOptionString.read(from: &buf), 
                utxoType: FfiConverterOptionTypeUtxoType.read(from: &buf), 
                address: FfiConverterTypeAddress.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: AddressAndAmount, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionTypeUtxoType.write(value.utxoType, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressAndAmount_lift(_ buf: RustBuffer) throws -> AddressAndAmount {
    return try FfiConverterTypeAddressAndAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressAndAmount_lower(_ value: AddressAndAmount) -> RustBuffer {
    return FfiConverterTypeAddressAndAmount.lower(value)
}


public struct AddressIndex: Equatable, Hashable {
    public var lastSeenIndex: UInt8
    public var addressListHash: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeenIndex: UInt8, addressListHash: UInt64) {
        self.lastSeenIndex = lastSeenIndex
        self.addressListHash = addressListHash
    }

    

    
}

#if compiler(>=6)
extension AddressIndex: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressIndex {
        return
            try AddressIndex(
                lastSeenIndex: FfiConverterUInt8.read(from: &buf), 
                addressListHash: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AddressIndex, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.lastSeenIndex, into: &buf)
        FfiConverterUInt64.write(value.addressListHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressIndex_lift(_ buf: RustBuffer) throws -> AddressIndex {
    return try FfiConverterTypeAddressIndex.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressIndex_lower(_ value: AddressIndex) -> RustBuffer {
    return FfiConverterTypeAddressIndex.lower(value)
}


public struct BlockSizeLast: Equatable, Hashable {
    public var blockHeight: UInt64
    public var lastSeen: TimeInterval

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockHeight: UInt64, lastSeen: TimeInterval) {
        self.blockHeight = blockHeight
        self.lastSeen = lastSeen
    }

    

    
}

#if compiler(>=6)
extension BlockSizeLast: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockSizeLast: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockSizeLast {
        return
            try BlockSizeLast(
                blockHeight: FfiConverterUInt64.read(from: &buf), 
                lastSeen: FfiConverterDuration.read(from: &buf)
        )
    }

    public static func write(_ value: BlockSizeLast, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.blockHeight, into: &buf)
        FfiConverterDuration.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockSizeLast_lift(_ buf: RustBuffer) throws -> BlockSizeLast {
    return try FfiConverterTypeBlockSizeLast.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockSizeLast_lower(_ value: BlockSizeLast) -> RustBuffer {
    return FfiConverterTypeBlockSizeLast.lower(value)
}


public struct Rgb: Equatable, Hashable {
    public var r: UInt8
    public var g: UInt8
    public var b: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: UInt8, g: UInt8, b: UInt8) {
        self.r = r
        self.g = g
        self.b = b
    }

    

    
}

#if compiler(>=6)
extension Rgb: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRgb: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rgb {
        return
            try Rgb(
                r: FfiConverterUInt8.read(from: &buf), 
                g: FfiConverterUInt8.read(from: &buf), 
                b: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Rgb, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.r, into: &buf)
        FfiConverterUInt8.write(value.g, into: &buf)
        FfiConverterUInt8.write(value.b, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRgb_lift(_ buf: RustBuffer) throws -> Rgb {
    return try FfiConverterTypeRgb.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRgb_lower(_ value: Rgb) -> RustBuffer {
    return FfiConverterTypeRgb.lower(value)
}


public struct SplitOutput {
    public var external: [AddressAndAmount]
    public var `internal`: [AddressAndAmount]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(external: [AddressAndAmount], `internal`: [AddressAndAmount]) {
        self.external = external
        self.`internal` = `internal`
    }

    

    
}

#if compiler(>=6)
extension SplitOutput: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSplitOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SplitOutput {
        return
            try SplitOutput(
                external: FfiConverterSequenceTypeAddressAndAmount.read(from: &buf), 
                internal: FfiConverterSequenceTypeAddressAndAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SplitOutput, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAddressAndAmount.write(value.external, into: &buf)
        FfiConverterSequenceTypeAddressAndAmount.write(value.`internal`, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitOutput_lift(_ buf: RustBuffer) throws -> SplitOutput {
    return try FfiConverterTypeSplitOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitOutput_lower(_ value: SplitOutput) -> RustBuffer {
    return FfiConverterTypeSplitOutput.lower(value)
}


public struct Utxo: Equatable, Hashable {
    public var outpoint: OutPoint
    public var label: String?
    public var datetime: UInt64
    public var amount: Amount
    public var address: Address
    public var derivationIndex: UInt32
    public var blockHeight: UInt32
    public var type: UtxoType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outpoint: OutPoint, label: String?, datetime: UInt64, amount: Amount, address: Address, derivationIndex: UInt32, blockHeight: UInt32, type: UtxoType) {
        self.outpoint = outpoint
        self.label = label
        self.datetime = datetime
        self.amount = amount
        self.address = address
        self.derivationIndex = derivationIndex
        self.blockHeight = blockHeight
        self.type = type
    }

    

    
// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: Utxo, other: Utxo) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_utxo_uniffi_trait_eq_eq(
            FfiConverterTypeUtxo_lower(self),
        FfiConverterTypeUtxo_lower(other),$0
    )
}
    )
}
// The local Rust `Hash` implementation
public func hash(into hasher: inout Hasher) {
    let val = try!  FfiConverterUInt64.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_utxo_uniffi_trait_hash(
            FfiConverterTypeUtxo_lower(self),$0
    )
}
    )
    hasher.combine(val)
}
}

#if compiler(>=6)
extension Utxo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return
            try Utxo(
                outpoint: FfiConverterTypeOutPoint.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                datetime: FfiConverterUInt64.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf), 
                address: FfiConverterTypeAddress.read(from: &buf), 
                derivationIndex: FfiConverterUInt32.read(from: &buf), 
                blockHeight: FfiConverterUInt32.read(from: &buf), 
                type: FfiConverterTypeUtxoType.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.outpoint, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterUInt64.write(value.datetime, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterUInt32.write(value.derivationIndex, into: &buf)
        FfiConverterUInt32.write(value.blockHeight, into: &buf)
        FfiConverterTypeUtxoType.write(value.type, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}


public enum AddressError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case NoOutputs
    case ScriptError(String
    )
    case InvalidAddress
    case UnsupportedNetwork
    case WrongNetwork(current: Network, validFor: Network
    )
    case EmptyAddress

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension AddressError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressError: FfiConverterRustBuffer {
    typealias SwiftType = AddressError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NoOutputs
        case 2: return .ScriptError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidAddress
        case 4: return .UnsupportedNetwork
        case 5: return .WrongNetwork(
            current: try FfiConverterTypeNetwork.read(from: &buf), 
            validFor: try FfiConverterTypeNetwork.read(from: &buf)
            )
        case 6: return .EmptyAddress

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NoOutputs:
            writeInt(&buf, Int32(1))
        
        
        case let .ScriptError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidAddress:
            writeInt(&buf, Int32(3))
        
        
        case .UnsupportedNetwork:
            writeInt(&buf, Int32(4))
        
        
        case let .WrongNetwork(current,validFor):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNetwork.write(current, into: &buf)
            FfiConverterTypeNetwork.write(validFor, into: &buf)
            
        
        case .EmptyAddress:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressError_lift(_ buf: RustBuffer) throws -> AddressError {
    return try FfiConverterTypeAddressError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressError_lower(_ value: AddressError) -> RustBuffer {
    return FfiConverterTypeAddressError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BitcoinUnit: Equatable, Hashable, CustomStringConvertible {
    
    case btc
    case sat





// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_bitcoinunit_uniffi_trait_display(
            FfiConverterTypeBitcoinUnit_lower(self),$0
    )
}
    )
}
}

#if compiler(>=6)
extension BitcoinUnit: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinUnit: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinUnit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinUnit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .btc
        
        case 2: return .sat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinUnit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .btc:
            writeInt(&buf, Int32(1))
        
        
        case .sat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinUnit_lift(_ buf: RustBuffer) throws -> BitcoinUnit {
    return try FfiConverterTypeBitcoinUnit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinUnit_lower(_ value: BitcoinUnit) -> RustBuffer {
    return FfiConverterTypeBitcoinUnit.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColorSchemeSelection: Equatable, Hashable {
    
    case light
    case dark
    case system





}

#if compiler(>=6)
extension ColorSchemeSelection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = ColorSchemeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColorSchemeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        case 3: return .system
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColorSchemeSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        
        case .system:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorSchemeSelection_lift(_ buf: RustBuffer) throws -> ColorSchemeSelection {
    return try FfiConverterTypeColorSchemeSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorSchemeSelection_lower(_ value: ColorSchemeSelection) -> RustBuffer {
    return FfiConverterTypeColorSchemeSelection.lower(value)
}



public enum ConfirmDetailsError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case QrCodeCreation(String
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ConfirmDetailsError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmDetailsError: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmDetailsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmDetailsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .QrCodeCreation(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConfirmDetailsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .QrCodeCreation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetailsError_lift(_ buf: RustBuffer) throws -> ConfirmDetailsError {
    return try FfiConverterTypeConfirmDetailsError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetailsError_lower(_ value: ConfirmDetailsError) -> RustBuffer {
    return FfiConverterTypeConfirmDetailsError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FeeSpeed: Equatable, Hashable, CustomStringConvertible {
    
    case fast
    case medium
    case slow
    case custom(durationMins: UInt32
    )





// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_feespeed_uniffi_trait_display(
            FfiConverterTypeFeeSpeed_lower(self),$0
    )
}
    )
}
}

#if compiler(>=6)
extension FeeSpeed: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeSpeed: FfiConverterRustBuffer {
    typealias SwiftType = FeeSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        case 4: return .custom(durationMins: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(durationMins):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(durationMins, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSpeed_lift(_ buf: RustBuffer) throws -> FeeSpeed {
    return try FfiConverterTypeFeeSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSpeed_lower(_ value: FeeSpeed) -> RustBuffer {
    return FfiConverterTypeFeeSpeed.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColor: Equatable, Hashable {
    
    case red(FfiOpacity
    )
    case blue(FfiOpacity
    )
    case green(FfiOpacity
    )
    case yellow(FfiOpacity
    )
    case orange(FfiOpacity
    )
    case purple(FfiOpacity
    )
    case pink(FfiOpacity
    )
    case white(FfiOpacity
    )
    case black(FfiOpacity
    )
    case gray(FfiOpacity
    )
    case coolGray(FfiOpacity
    )
    case custom(Rgb,FfiOpacity
    )





}

#if compiler(>=6)
extension FfiColor: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiColor: FfiConverterRustBuffer {
    typealias SwiftType = FfiColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 2: return .blue(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 3: return .green(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 4: return .yellow(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 5: return .orange(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 6: return .purple(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 7: return .pink(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 8: return .white(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 9: return .black(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 10: return .gray(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 11: return .coolGray(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 12: return .custom(try FfiConverterTypeRgb.read(from: &buf), try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .red(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .blue(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .green(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .yellow(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .orange(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .purple(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .pink(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .white(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .black(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .gray(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .coolGray(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .custom(v1,v2):
            writeInt(&buf, Int32(12))
            FfiConverterTypeRgb.write(v1, into: &buf)
            FfiConverterTypeFfiOpacity.write(v2, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColor_lift(_ buf: RustBuffer) throws -> FfiColor {
    return try FfiConverterTypeFfiColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColor_lower(_ value: FfiColor) -> RustBuffer {
    return FfiConverterTypeFfiColor.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColorScheme: Equatable, Hashable {
    
    case light
    case dark





}

#if compiler(>=6)
extension FfiColorScheme: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiColorScheme: FfiConverterRustBuffer {
    typealias SwiftType = FfiColorScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColorScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColorScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColorScheme_lift(_ buf: RustBuffer) throws -> FfiColorScheme {
    return try FfiConverterTypeFfiColorScheme.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColorScheme_lower(_ value: FfiColorScheme) -> RustBuffer {
    return FfiConverterTypeFfiColorScheme.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network: Equatable, Hashable, CustomStringConvertible {
    
    case bitcoin
    case testnet
    case testnet4
    case signet





// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_types_fn_method_network_uniffi_trait_display(
            FfiConverterTypeNetwork_lower(self),$0
    )
}
    )
}
}

#if compiler(>=6)
extension Network: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .testnet4
        
        case 4: return .signet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .testnet4:
            writeInt(&buf, Int32(3))
        
        
        case .signet:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



public enum PsbtError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case MissingUtxo
    case NegativeFee
    case FeeOverflow
    case Other(String
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension PsbtError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingUtxo
        case 2: return .NegativeFee
        case 3: return .FeeOverflow
        case 4: return .Other(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingUtxo:
            writeInt(&buf, Int32(1))
        
        
        case .NegativeFee:
            writeInt(&buf, Int32(2))
        
        
        case .FeeOverflow:
            writeInt(&buf, Int32(3))
        
        
        case let .Other(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lift(_ buf: RustBuffer) throws -> PsbtError {
    return try FfiConverterTypePsbtError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lower(_ value: PsbtError) -> RustBuffer {
    return FfiConverterTypePsbtError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionDirection: Equatable, Hashable {
    
    case incoming
    case outgoing





}

#if compiler(>=6)
extension TransactionDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDirection: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .incoming
        
        case 2: return .outgoing
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .incoming:
            writeInt(&buf, Int32(1))
        
        
        case .outgoing:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDirection_lift(_ buf: RustBuffer) throws -> TransactionDirection {
    return try FfiConverterTypeTransactionDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDirection_lower(_ value: TransactionDirection) -> RustBuffer {
    return FfiConverterTypeTransactionDirection.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UtxoType: Equatable, Hashable {
    
    case output
    case change





}

#if compiler(>=6)
extension UtxoType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUtxoType: FfiConverterRustBuffer {
    typealias SwiftType = UtxoType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UtxoType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .output
        
        case 2: return .change
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UtxoType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .output:
            writeInt(&buf, Int32(1))
        
        
        case .change:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxoType_lift(_ buf: RustBuffer) throws -> UtxoType {
    return try FfiConverterTypeUtxoType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUtxoType_lower(_ value: UtxoType) -> RustBuffer {
    return FfiConverterTypeUtxoType.lower(value)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeeRateOptionWithTotalFee: FfiConverterRustBuffer {
    typealias SwiftType = FeeRateOptionWithTotalFee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeRateOptionWithTotalFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRateOptionWithTotalFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUtxoType: FfiConverterRustBuffer {
    typealias SwiftType = UtxoType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUtxoType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUtxoType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddressAndAmount: FfiConverterRustBuffer {
    typealias SwiftType = [AddressAndAmount]

    public static func write(_ value: [AddressAndAmount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressAndAmount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressAndAmount] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressAndAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddressAndAmount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBitcoinUnit: FfiConverterRustBuffer {
    typealias SwiftType = [BitcoinUnit]

    public static func write(_ value: [BitcoinUnit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBitcoinUnit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BitcoinUnit] {
        let len: Int32 = try readInt(&buf)
        var seq = [BitcoinUnit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBitcoinUnit.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [ColorSchemeSelection]

    public static func write(_ value: [ColorSchemeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeColorSchemeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ColorSchemeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [ColorSchemeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeColorSchemeSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [Network]

    public static func write(_ value: [Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNetwork.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias FfiOpacity = UInt8

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiOpacity: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiOpacity {
        return try FfiConverterUInt8.read(from: &buf)
    }

    public static func write(_ value: FfiOpacity, into buf: inout [UInt8]) {
        return FfiConverterUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: UInt8) throws -> FfiOpacity {
        return try FfiConverterUInt8.lift(value)
    }

    public static func lower(_ value: FfiOpacity) -> UInt8 {
        return FfiConverterUInt8.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiOpacity_lift(_ value: UInt8) throws -> FfiOpacity {
    return try FfiConverterTypeFfiOpacity.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiOpacity_lower(_ value: FfiOpacity) -> UInt8 {
    return FfiConverterTypeFfiOpacity.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletId_lift(_ value: RustBuffer) throws -> WalletId {
    return try FfiConverterTypeWalletId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletId_lower(_ value: WalletId) -> RustBuffer {
    return FfiConverterTypeWalletId.lower(value)
}

public func addressIsValid(address: String, network: Network)throws   {try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_func_address_is_valid(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
}
public func addressIsValidForNetwork(address: String, network: Network)throws   {try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_func_address_is_valid_for_network(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
}
public func addressStringSpacedOut(address: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_address_string_spaced_out(
        FfiConverterString.lower(address),$0
    )
})
}
public func allColorSchemes() -> [ColorSchemeSelection]  {
    return try!  FfiConverterSequenceTypeColorSchemeSelection.lift(try! rustCall() {
    uniffi_cove_types_fn_func_all_color_schemes($0
    )
})
}
public func colorSchemeSelectionCapitalizedString(colorScheme: ColorSchemeSelection) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_color_scheme_selection_capitalized_string(
        FfiConverterTypeColorSchemeSelection_lower(colorScheme),$0
    )
})
}
public func feeRateOptionsWithTotalFeeIsEqual(lhs: FeeRateOptionsWithTotalFee, rhs: FeeRateOptionsWithTotalFee) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_rate_options_with_total_fee_is_equal(
        FfiConverterTypeFeeRateOptionsWithTotalFee_lower(lhs),
        FfiConverterTypeFeeRateOptionsWithTotalFee_lower(rhs),$0
    )
})
}
public func feeSpeedDuration(feeSpeed: FeeSpeed) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_duration(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func feeSpeedIsCustom(feeSpeed: FeeSpeed) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_is_custom(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func feeSpeedToCircleColor(feeSpeed: FeeSpeed) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor_lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_to_circle_color(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func allNetworks() -> [Network]  {
    return try!  FfiConverterSequenceTypeNetwork.lift(try! rustCall() {
    uniffi_cove_types_fn_func_all_networks($0
    )
})
}
public func networkToString(network: Network) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_network_to_string(
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
public func allUnits() -> [BitcoinUnit]  {
    return try!  FfiConverterSequenceTypeBitcoinUnit.lift(try! rustCall() {
    uniffi_cove_types_fn_func_all_units($0
    )
})
}
public func previewNewUtxoList(outputCount: UInt8, changeCount: UInt8) -> [Utxo]  {
    return try!  FfiConverterSequenceTypeUtxo.lift(try! rustCall() {
    uniffi_cove_types_fn_func_previewnewutxolist(
        FfiConverterUInt8.lower(outputCount),
        FfiConverterUInt8.lower(changeCount),$0
    )
})
}
public func utxoDate(utxo: Utxo) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_utxo_date(
        FfiConverterTypeUtxo_lower(utxo),$0
    )
})
}
public func utxoHashToUint(utxo: Utxo) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_func_utxo_hash_to_uint(
        FfiConverterTypeUtxo_lower(utxo),$0
    )
})
}
public func utxoIsEqual(lhs: Utxo, rhs: Utxo) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_func_utxo_is_equal(
        FfiConverterTypeUtxo_lower(lhs),
        FfiConverterTypeUtxo_lower(rhs),$0
    )
})
}
public func utxoName(utxo: Utxo) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_utxo_name(
        FfiConverterTypeUtxo_lower(utxo),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cove_types_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_cove_types_checksum_func_address_is_valid() != 40004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_address_is_valid_for_network() != 34573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_address_string_spaced_out() != 27769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_all_color_schemes() != 49693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_color_scheme_selection_capitalized_string() != 30731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_rate_options_with_total_fee_is_equal() != 17627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_duration() != 51667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_is_custom() != 38261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_to_circle_color() != 20193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_all_networks() != 5848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_network_to_string() != 16428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_all_units() != 35208) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_previewnewutxolist() != 31621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_utxo_date() != 26239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_utxo_hash_to_uint() != 33471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_utxo_is_equal() != 34078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_utxo_name() != 48729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_hashtouint() != 25307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_spaced_out() != 7307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_string() != 24375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_unformatted() != 36743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfo_address() != 18333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfo_address_unformatted() != 30474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfo_index() != 1190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfowithderivation_address() != 22537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfowithderivation_address_spaced_out() != 2711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfowithderivation_address_unformatted() != 38193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfowithderivation_derivation_path() != 62550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfowithderivation_index() != 40232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_address() != 33829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_amount() != 15414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_isvalidfornetwork() != 42219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_network() != 25441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_as_btc() != 12153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_as_sats() != 8712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_btc_string() != 40813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_btc_string_with_unit() != 4146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_fmt_string() != 3973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_fmt_string_with_unit() != 64791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_sats_string() != 46414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_sats_string_with_unit() != 53544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_fee_percentage() != 7228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_fee_rate() != 11989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_fee_total() != 14255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_id() != 1448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_id_hash() != 43019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_inputs() != 61203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_normalized_id() != 43735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_outputs() != 11686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt() != 47244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_bytes() != 64298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr() != 44475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_to_hex() != 28844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_to_ur() != 51534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_to_ur_single() != 27748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_sending_amount() != 32253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_sending_to() != 38424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_spending_amount() != 58334) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerate_sat_per_vb() != 25940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_duration() != 37929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_fee_rate() != 45273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_fee_speed() != 40949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_is_equal() != 33304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_sat_per_vb() != 38044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_duration() != 34003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate() != 46441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate_options() != 5569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_speed() != 51786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_custom() != 33675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_equal() != 12772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_sat_per_vb() != 61796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_total_fee() != 47307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptions_fast() != 36416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptions_medium() != 6247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptions_slow() != 30350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_add_custom_fee_rate() != 4884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_calculate_custom_fee_speed() != 37692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_custom() != 13008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fast() != 50276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fee_rate_options() != 44824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_get_fee_rate_with() != 34987) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_medium() != 37448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_remove_custom_fee() != 54242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_slow() != 50247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_transaction_size() != 16234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_fee() != 23286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_output_total_amount() != 21225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_tx_id() != 3954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_weight() != 28925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_outpoint_eq() != 14112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_outpoint_hashtouint() != 51667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_outpoint_txid() != 38543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_outpoint_txid_str() != 43489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_outpoint_txn_link() != 14032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_amount() != 64130) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_amount_fmt() != 34174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_direction() != 54585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_external_sent() != 46394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_label() != 13733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_received() != 51331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_sent() != 46998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_txid_as_hash_string() != 7916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_address_from_string() != 58026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_address_preview_new() != 38108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_address_random() != 40923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_addresswithnetwork_new() != 11084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_amount_from_sat() != 32795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_amount_one_btc() != 13254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_amount_one_sat() != 27159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_confirmdetails_previewnew() != 27324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerate_from_sat_per_vb() != 23120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoption_new() != 46851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoptionwithtotalfee_new() != 48098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoptions_previewnew() != 40621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoptionswithtotalfee_previewnew() != 31010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_psbt_new() != 33253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_outpoint_previewnew() != 32440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_outpoint_withvout() != 16885) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureCoveTypesInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all