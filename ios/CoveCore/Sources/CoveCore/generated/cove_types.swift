// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(cove_typesFFI)
import cove_typesFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cove_types_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cove_types_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureCoveTypesInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AddressProtocol: AnyObject, Sendable {
    
    func spacedOut()  -> String
    
    func string()  -> String
    
    func toString()  -> String
    
    func unformatted()  -> String
    
}
open class Address: AddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_address(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_address(pointer, $0) }
    }

    
public static func fromString(address: String, network: Network)throws  -> Address  {
    return try  FfiConverterTypeAddress_lift(try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_constructor_address_from_string(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
    
public static func previewNew() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_address_preview_new($0
    )
})
}
    

    
open func spacedOut() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_spaced_out(self.uniffiClonePointer(),$0
    )
})
}
    
open func string() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func toString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_tostring(self.uniffiClonePointer(),$0
    )
})
}
    
open func unformatted() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_address_unformatted(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
    return try FfiConverterTypeAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddress.lower(value)
}






public protocol AddressInfoProtocol: AnyObject, Sendable {
    
    func address()  -> Address
    
    func addressUnformatted()  -> String
    
    func index()  -> UInt32
    
}
open class AddressInfo: AddressInfoProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_addressinfo(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_addressinfo(pointer, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfo_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func addressUnformatted() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfo_address_unformatted(self.uniffiClonePointer(),$0
    )
})
}
    
open func index() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addressinfo_index(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressInfo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AddressInfo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressInfo {
        return AddressInfo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AddressInfo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressInfo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AddressInfo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressInfo {
    return try FfiConverterTypeAddressInfo.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressInfo_lower(_ value: AddressInfo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddressInfo.lower(value)
}






public protocol AddressWithNetworkProtocol: AnyObject, Sendable {
    
    func address()  -> Address
    
    func amount()  -> Amount?
    
    func network()  -> Network
    
}
open class AddressWithNetwork: AddressWithNetworkProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_addresswithnetwork(self.pointer, $0) }
    }
public convenience init(address: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_constructor_addresswithnetwork_new(
        FfiConverterString.lower(address),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_addresswithnetwork(pointer, $0) }
    }

    

    
open func address() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func amount() -> Amount?  {
    return try!  FfiConverterOptionTypeAmount.lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork_lift(try! rustCall() {
    uniffi_cove_types_fn_method_addresswithnetwork_network(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressWithNetwork: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AddressWithNetwork

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressWithNetwork {
        return AddressWithNetwork(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AddressWithNetwork) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressWithNetwork {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AddressWithNetwork, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressWithNetwork_lift(_ pointer: UnsafeMutableRawPointer) throws -> AddressWithNetwork {
    return try FfiConverterTypeAddressWithNetwork.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressWithNetwork_lower(_ value: AddressWithNetwork) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAddressWithNetwork.lower(value)
}






public protocol AmountProtocol: AnyObject, Sendable {
    
    func asBtc()  -> Double
    
    func asSats()  -> UInt64
    
    func btcString()  -> String
    
    func btcStringWithUnit()  -> String
    
    func fmtStringWithUnit(unit: Unit)  -> String
    
    func satsString()  -> String
    
    func satsStringWithUnit()  -> String
    
}
open class Amount: AmountProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_amount(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_amount(pointer, $0) }
    }

    
public static func fromSat(sats: UInt64) -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_amount_from_sat(
        FfiConverterUInt64.lower(sats),$0
    )
})
}
    
public static func oneBtc() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_amount_one_btc($0
    )
})
}
    
public static func oneSat() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_amount_one_sat($0
    )
})
}
    

    
open func asBtc() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_as_btc(self.uniffiClonePointer(),$0
    )
})
}
    
open func asSats() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_as_sats(self.uniffiClonePointer(),$0
    )
})
}
    
open func btcString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_btc_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func btcStringWithUnit() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_btc_string_with_unit(self.uniffiClonePointer(),$0
    )
})
}
    
open func fmtStringWithUnit(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_fmt_string_with_unit(self.uniffiClonePointer(),
        FfiConverterTypeUnit_lower(unit),$0
    )
})
}
    
open func satsString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_sats_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func satsStringWithUnit() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_amount_sats_string_with_unit(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Amount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
        return Amount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Amount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Amount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Amount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lift(_ pointer: UnsafeMutableRawPointer) throws -> Amount {
    return try FfiConverterTypeAmount.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmount_lower(_ value: Amount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAmount.lower(value)
}






public protocol ChainPositionProtocol: AnyObject, Sendable {
    
}
open class ChainPosition: ChainPositionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_chainposition(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_chainposition(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChainPosition: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ChainPosition

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ChainPosition {
        return ChainPosition(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ChainPosition) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChainPosition {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ChainPosition, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lift(_ pointer: UnsafeMutableRawPointer) throws -> ChainPosition {
    return try FfiConverterTypeChainPosition.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChainPosition_lower(_ value: ChainPosition) -> UnsafeMutableRawPointer {
    return FfiConverterTypeChainPosition.lower(value)
}






public protocol ConfirmDetailsProtocol: AnyObject, Sendable {
    
    func feeRate()  -> FeeRate
    
    func feeTotal()  -> Amount
    
    func id()  -> TxId
    
    func idHash()  -> String
    
    func inputs()  -> [AddressAndAmount]
    
    func normalizedId()  -> String
    
    func outputs()  -> [AddressAndAmount]
    
    func psbt()  -> Psbt
    
    func psbtBytes()  -> Data
    
    func psbtToBbqr() throws  -> [String]
    
    func psbtToHex()  -> String
    
    func sendingAmount()  -> Amount
    
    func sendingTo()  -> Address
    
    func spendingAmount()  -> Amount
    
}
open class ConfirmDetails: ConfirmDetailsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_confirmdetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_confirmdetails(pointer, $0) }
    }

    
public static func previewNew(amount: UInt64 = UInt64(20448)) -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_confirmdetails_preview_new(
        FfiConverterUInt64.lower(amount),$0
    )
})
}
    

    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeTotal() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_fee_total(self.uniffiClonePointer(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func idHash() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_id_hash(self.uniffiClonePointer(),$0
    )
})
}
    
open func inputs() -> [AddressAndAmount]  {
    return try!  FfiConverterSequenceTypeAddressAndAmount.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_inputs(self.uniffiClonePointer(),$0
    )
})
}
    
open func normalizedId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_normalized_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func outputs() -> [AddressAndAmount]  {
    return try!  FfiConverterSequenceTypeAddressAndAmount.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_outputs(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbt() -> Psbt  {
    return try!  FfiConverterTypePsbt_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_psbt(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbtBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_psbt_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbtToBbqr()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeConfirmDetailsError_lift) {
    uniffi_cove_types_fn_method_confirmdetails_psbt_to_bbqr(self.uniffiClonePointer(),$0
    )
})
}
    
open func psbtToHex() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_psbt_to_hex(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_sending_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendingTo() -> Address  {
    return try!  FfiConverterTypeAddress_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_sending_to(self.uniffiClonePointer(),$0
    )
})
}
    
open func spendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_confirmdetails_spending_amount(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ConfirmDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmDetails {
        return ConfirmDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ConfirmDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ConfirmDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> ConfirmDetails {
    return try FfiConverterTypeConfirmDetails.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetails_lower(_ value: ConfirmDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConfirmDetails.lower(value)
}






public protocol FeeRateProtocol: AnyObject, Sendable {
    
    func satPerVb()  -> Float
    
}
open class FeeRate: FeeRateProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_feerate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerate(pointer, $0) }
    }

    
public static func fromSatPerVb(satPerVb: Float) -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_feerate_from_sat_per_vb(
        FfiConverterFloat.lower(satPerVb),$0
    )
})
}
    

    
open func satPerVb() -> Float  {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerate_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}






public protocol FeeRateOptionProtocol: AnyObject, Sendable {
    
    func duration()  -> String
    
    func feeRate()  -> FeeRate
    
    func feeSpeed()  -> FeeSpeed
    
    func isEqual(rhs: FeeRateOption)  -> Bool
    
    func satPerVb()  -> Float
    
}
open class FeeRateOption: FeeRateOptionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoption(self.pointer, $0) }
    }
public convenience init(feeSpeed: FeeSpeed, feeRate: Float) {
    let pointer =
        try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoption_new(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),
        FfiConverterFloat.lower(feeRate),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoption(pointer, $0) }
    }

    

    
open func duration() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_duration(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeSpeed() -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_fee_speed(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(rhs: FeeRateOption) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeFeeRateOption_lower(rhs),$0
    )
})
}
    
open func satPerVb() -> Float  {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoption_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOption: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOption

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOption {
        return FeeRateOption(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOption) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOption {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOption, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOption_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOption {
    return try FfiConverterTypeFeeRateOption.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOption_lower(_ value: FeeRateOption) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOption.lower(value)
}






public protocol FeeRateOptionWithTotalFeeProtocol: AnyObject, Sendable {
    
    func duration()  -> String
    
    func feeRate()  -> FeeRate
    
    func feeRateOptions()  -> FeeRateOption
    
    func feeSpeed()  -> FeeSpeed
    
    func isCustom()  -> Bool
    
    func isEqual(rhs: FeeRateOptionWithTotalFee)  -> Bool
    
    func satPerVb()  -> Float
    
    func totalFee()  -> Amount
    
}
open class FeeRateOptionWithTotalFee: FeeRateOptionWithTotalFeeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoptionwithtotalfee(self.pointer, $0) }
    }
public convenience init(feeSpeed: FeeSpeed, feeRate: FeeRate, totalFee: Amount) {
    let pointer =
        try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoptionwithtotalfee_new(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),
        FfiConverterTypeFeeRate_lower(feeRate),
        FfiConverterTypeAmount_lower(totalFee),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoptionwithtotalfee(pointer, $0) }
    }

    

    
open func duration() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_duration(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRate() -> FeeRate  {
    return try!  FfiConverterTypeFeeRate_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRateOptions() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_rate_options(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeSpeed() -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_fee_speed(self.uniffiClonePointer(),$0
    )
})
}
    
open func isCustom() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_custom(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(rhs: FeeRateOptionWithTotalFee) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeFeeRateOptionWithTotalFee_lower(rhs),$0
    )
})
}
    
open func satPerVb() -> Float  {
    return try!  FfiConverterFloat.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_sat_per_vb(self.uniffiClonePointer(),$0
    )
})
}
    
open func totalFee() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionwithtotalfee_total_fee(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptionWithTotalFee: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOptionWithTotalFee

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionWithTotalFee {
        return FeeRateOptionWithTotalFee(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOptionWithTotalFee) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptionWithTotalFee {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOptionWithTotalFee, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionWithTotalFee_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionWithTotalFee {
    return try FfiConverterTypeFeeRateOptionWithTotalFee.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionWithTotalFee_lower(_ value: FeeRateOptionWithTotalFee) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOptionWithTotalFee.lower(value)
}






public protocol FeeRateOptionsProtocol: AnyObject, Sendable {
    
    func fast()  -> FeeRateOption
    
    func medium()  -> FeeRateOption
    
    func slow()  -> FeeRateOption
    
}
open class FeeRateOptions: FeeRateOptionsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoptions(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoptions(pointer, $0) }
    }

    
public static func previewNew() -> FeeRateOptions  {
    return try!  FfiConverterTypeFeeRateOptions_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoptions_preview_new($0
    )
})
}
    

    
open func fast() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptions_fast(self.uniffiClonePointer(),$0
    )
})
}
    
open func medium() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptions_medium(self.uniffiClonePointer(),$0
    )
})
}
    
open func slow() -> FeeRateOption  {
    return try!  FfiConverterTypeFeeRateOption_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptions_slow(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOptions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptions {
        return FeeRateOptions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOptions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOptions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptions_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptions {
    return try FfiConverterTypeFeeRateOptions.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptions_lower(_ value: FeeRateOptions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOptions.lower(value)
}






public protocol FeeRateOptionsWithTotalFeeProtocol: AnyObject, Sendable {
    
    func addCustomFee(feeRate: Float)  -> FeeRateOptionsWithTotalFee
    
    func addCustomFeeRate(feeRate: FeeRateOptionWithTotalFee)  -> FeeRateOptionsWithTotalFee
    
    func calculateCustomFeeSpeed(feeRate: Float)  -> FeeSpeed
    
    func custom()  -> FeeRateOptionWithTotalFee?
    
    func fast()  -> FeeRateOptionWithTotalFee
    
    func feeRateOptions()  -> FeeRateOptions
    
    func getFeeRateWith(feeRate: Float)  -> FeeRateOptionWithTotalFee?
    
    func medium()  -> FeeRateOptionWithTotalFee
    
    func removeCustomFee()  -> FeeRateOptionsWithTotalFee
    
    func slow()  -> FeeRateOptionWithTotalFee
    
    func transactionSize()  -> UInt64
    
}
open class FeeRateOptionsWithTotalFee: FeeRateOptionsWithTotalFeeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_feerateoptionswithtotalfee(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_feerateoptionswithtotalfee(pointer, $0) }
    }

    
public static func previewNew() -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_constructor_feerateoptionswithtotalfee_preview_new($0
    )
})
}
    

    
open func addCustomFee(feeRate: Float) -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_add_custom_fee(self.uniffiClonePointer(),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func addCustomFeeRate(feeRate: FeeRateOptionWithTotalFee) -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_add_custom_fee_rate(self.uniffiClonePointer(),
        FfiConverterTypeFeeRateOptionWithTotalFee_lower(feeRate),$0
    )
})
}
    
open func calculateCustomFeeSpeed(feeRate: Float) -> FeeSpeed  {
    return try!  FfiConverterTypeFeeSpeed_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_calculate_custom_fee_speed(self.uniffiClonePointer(),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func custom() -> FeeRateOptionWithTotalFee?  {
    return try!  FfiConverterOptionTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_custom(self.uniffiClonePointer(),$0
    )
})
}
    
open func fast() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fast(self.uniffiClonePointer(),$0
    )
})
}
    
open func feeRateOptions() -> FeeRateOptions  {
    return try!  FfiConverterTypeFeeRateOptions_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_fee_rate_options(self.uniffiClonePointer(),$0
    )
})
}
    
open func getFeeRateWith(feeRate: Float) -> FeeRateOptionWithTotalFee?  {
    return try!  FfiConverterOptionTypeFeeRateOptionWithTotalFee.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_get_fee_rate_with(self.uniffiClonePointer(),
        FfiConverterFloat.lower(feeRate),$0
    )
})
}
    
open func medium() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_medium(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeCustomFee() -> FeeRateOptionsWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionsWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_remove_custom_fee(self.uniffiClonePointer(),$0
    )
})
}
    
open func slow() -> FeeRateOptionWithTotalFee  {
    return try!  FfiConverterTypeFeeRateOptionWithTotalFee_lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_slow(self.uniffiClonePointer(),$0
    )
})
}
    
open func transactionSize() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_feerateoptionswithtotalfee_transaction_size(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRateOptionsWithTotalFee: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRateOptionsWithTotalFee

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionsWithTotalFee {
        return FeeRateOptionsWithTotalFee(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRateOptionsWithTotalFee) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRateOptionsWithTotalFee {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRateOptionsWithTotalFee, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionsWithTotalFee_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRateOptionsWithTotalFee {
    return try FfiConverterTypeFeeRateOptionsWithTotalFee.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRateOptionsWithTotalFee_lower(_ value: FeeRateOptionsWithTotalFee) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRateOptionsWithTotalFee.lower(value)
}






public protocol InputOutputDetailsProtocol: AnyObject, Sendable {
    
}
open class InputOutputDetails: InputOutputDetailsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_inputoutputdetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_inputoutputdetails(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInputOutputDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InputOutputDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InputOutputDetails {
        return InputOutputDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InputOutputDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputOutputDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InputOutputDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputOutputDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> InputOutputDetails {
    return try FfiConverterTypeInputOutputDetails.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInputOutputDetails_lower(_ value: InputOutputDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInputOutputDetails.lower(value)
}






public protocol OutPointProtocol: AnyObject, Sendable {
    
}
open class OutPoint: OutPointProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_outpoint(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_outpoint(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutPoint: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OutPoint

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
        return OutPoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOutPoint.lower(value)
}






public protocol PsbtProtocol: AnyObject, Sendable {
    
    /**
     * Total fee in sats.
     */
    func fee() throws  -> Amount
    
    /**
     * Get total sending amount of all outputs
     */
    func outputTotalAmount()  -> Amount
    
    /**
     * Get the transaction id of the unsigned transaction
     */
    func txId()  -> TxId
    
    /**
     * The virtual size of the transaction.
     */
    func weight()  -> UInt64
    
}
open class Psbt: PsbtProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_psbt(self.pointer, $0) }
    }
public convenience init(data: Data)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_cove_types_fn_constructor_psbt_new(
        FfiConverterData.lower(data),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_psbt(pointer, $0) }
    }

    

    
    /**
     * Total fee in sats.
     */
open func fee()throws  -> Amount  {
    return try  FfiConverterTypeAmount_lift(try rustCallWithError(FfiConverterTypePsbtError_lift) {
    uniffi_cove_types_fn_method_psbt_fee(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get total sending amount of all outputs
     */
open func outputTotalAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_psbt_output_total_amount(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the transaction id of the unsigned transaction
     */
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_types_fn_method_psbt_tx_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The virtual size of the transaction.
     */
open func weight() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_types_fn_method_psbt_weight(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Psbt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
        return Psbt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Psbt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Psbt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Psbt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Psbt {
    return try FfiConverterTypePsbt.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbt_lower(_ value: Psbt) -> UnsafeMutableRawPointer {
    return FfiConverterTypePsbt.lower(value)
}






public protocol SentAndReceivedProtocol: AnyObject, Sendable {
    
    func amount()  -> Amount
    
    func amountFmt(unit: Unit)  -> String
    
    func direction()  -> TransactionDirection
    
    func externalSent()  -> Amount
    
    func label()  -> String
    
    func received()  -> Amount
    
    func sent()  -> Amount
    
}
open class SentAndReceived: SentAndReceivedProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_sentandreceived(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_sentandreceived(pointer, $0) }
    }

    

    
open func amount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_amount(self.uniffiClonePointer(),$0
    )
})
}
    
open func amountFmt(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_amount_fmt(self.uniffiClonePointer(),
        FfiConverterTypeUnit_lower(unit),$0
    )
})
}
    
open func direction() -> TransactionDirection  {
    return try!  FfiConverterTypeTransactionDirection_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_direction(self.uniffiClonePointer(),$0
    )
})
}
    
open func externalSent() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_external_sent(self.uniffiClonePointer(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_label(self.uniffiClonePointer(),$0
    )
})
}
    
open func received() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_received(self.uniffiClonePointer(),$0
    )
})
}
    
open func sent() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_types_fn_method_sentandreceived_sent(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSentAndReceived: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SentAndReceived

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SentAndReceived {
        return SentAndReceived(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SentAndReceived) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SentAndReceived {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SentAndReceived, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceived_lift(_ pointer: UnsafeMutableRawPointer) throws -> SentAndReceived {
    return try FfiConverterTypeSentAndReceived.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSentAndReceived_lower(_ value: SentAndReceived) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSentAndReceived.lower(value)
}






public protocol TxIdProtocol: AnyObject, Sendable {
    
    func asHashString()  -> String
    
    func isEqual(other: TxId)  -> Bool
    
}
open class TxId: TxIdProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_txid(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_txid(pointer, $0) }
    }

    

    
open func asHashString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_method_txid_as_hash_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func isEqual(other: TxId) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_method_txid_is_equal(self.uniffiClonePointer(),
        FfiConverterTypeTxId_lower(other),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxId: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxId {
        return TxId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxId_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxId {
    return try FfiConverterTypeTxId.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxId_lower(_ value: TxId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxId.lower(value)
}






public protocol TxInProtocol: AnyObject, Sendable {
    
}
open class TxIn: TxInProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_txin(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_txin(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxIn: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxIn

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
        return TxIn(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxIn) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxIn {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxIn, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxIn {
    return try FfiConverterTypeTxIn.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxIn_lower(_ value: TxIn) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxIn.lower(value)
}






public protocol TxOutProtocol: AnyObject, Sendable {
    
}
open class TxOut: TxOutProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_cove_types_fn_clone_txout(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_cove_types_fn_free_txout(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxOut: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxOut

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
        return TxOut(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TxOut) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOut {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TxOut, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lift(_ pointer: UnsafeMutableRawPointer) throws -> TxOut {
    return try FfiConverterTypeTxOut.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOut_lower(_ value: TxOut) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTxOut.lower(value)
}




public struct AddressAndAmount {
    public var address: Address
    public var amount: Amount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: Address, amount: Amount) {
        self.address = address
        self.amount = amount
    }
}

#if compiler(>=6)
extension AddressAndAmount: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressAndAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressAndAmount {
        return
            try AddressAndAmount(
                address: FfiConverterTypeAddress.read(from: &buf), 
                amount: FfiConverterTypeAmount.read(from: &buf)
        )
    }

    public static func write(_ value: AddressAndAmount, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterTypeAmount.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressAndAmount_lift(_ buf: RustBuffer) throws -> AddressAndAmount {
    return try FfiConverterTypeAddressAndAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressAndAmount_lower(_ value: AddressAndAmount) -> RustBuffer {
    return FfiConverterTypeAddressAndAmount.lower(value)
}


public struct AddressIndex {
    public var lastSeenIndex: UInt8
    public var addressListHash: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeenIndex: UInt8, addressListHash: UInt64) {
        self.lastSeenIndex = lastSeenIndex
        self.addressListHash = addressListHash
    }
}

#if compiler(>=6)
extension AddressIndex: Sendable {}
#endif


extension AddressIndex: Equatable, Hashable {
    public static func ==(lhs: AddressIndex, rhs: AddressIndex) -> Bool {
        if lhs.lastSeenIndex != rhs.lastSeenIndex {
            return false
        }
        if lhs.addressListHash != rhs.addressListHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastSeenIndex)
        hasher.combine(addressListHash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressIndex {
        return
            try AddressIndex(
                lastSeenIndex: FfiConverterUInt8.read(from: &buf), 
                addressListHash: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AddressIndex, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.lastSeenIndex, into: &buf)
        FfiConverterUInt64.write(value.addressListHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressIndex_lift(_ buf: RustBuffer) throws -> AddressIndex {
    return try FfiConverterTypeAddressIndex.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressIndex_lower(_ value: AddressIndex) -> RustBuffer {
    return FfiConverterTypeAddressIndex.lower(value)
}


public struct BlockSizeLast {
    public var blockHeight: UInt64
    public var lastSeen: TimeInterval

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockHeight: UInt64, lastSeen: TimeInterval) {
        self.blockHeight = blockHeight
        self.lastSeen = lastSeen
    }
}

#if compiler(>=6)
extension BlockSizeLast: Sendable {}
#endif


extension BlockSizeLast: Equatable, Hashable {
    public static func ==(lhs: BlockSizeLast, rhs: BlockSizeLast) -> Bool {
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.lastSeen != rhs.lastSeen {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockHeight)
        hasher.combine(lastSeen)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockSizeLast: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockSizeLast {
        return
            try BlockSizeLast(
                blockHeight: FfiConverterUInt64.read(from: &buf), 
                lastSeen: FfiConverterDuration.read(from: &buf)
        )
    }

    public static func write(_ value: BlockSizeLast, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.blockHeight, into: &buf)
        FfiConverterDuration.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockSizeLast_lift(_ buf: RustBuffer) throws -> BlockSizeLast {
    return try FfiConverterTypeBlockSizeLast.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockSizeLast_lower(_ value: BlockSizeLast) -> RustBuffer {
    return FfiConverterTypeBlockSizeLast.lower(value)
}


public struct Rgb {
    public var r: UInt8
    public var g: UInt8
    public var b: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(r: UInt8, g: UInt8, b: UInt8) {
        self.r = r
        self.g = g
        self.b = b
    }
}

#if compiler(>=6)
extension Rgb: Sendable {}
#endif


extension Rgb: Equatable, Hashable {
    public static func ==(lhs: Rgb, rhs: Rgb) -> Bool {
        if lhs.r != rhs.r {
            return false
        }
        if lhs.g != rhs.g {
            return false
        }
        if lhs.b != rhs.b {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(r)
        hasher.combine(g)
        hasher.combine(b)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRgb: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rgb {
        return
            try Rgb(
                r: FfiConverterUInt8.read(from: &buf), 
                g: FfiConverterUInt8.read(from: &buf), 
                b: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: Rgb, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.r, into: &buf)
        FfiConverterUInt8.write(value.g, into: &buf)
        FfiConverterUInt8.write(value.b, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRgb_lift(_ buf: RustBuffer) throws -> Rgb {
    return try FfiConverterTypeRgb.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRgb_lower(_ value: Rgb) -> RustBuffer {
    return FfiConverterTypeRgb.lower(value)
}


public struct SplitOutput {
    public var external: [AddressAndAmount]
    public var `internal`: [AddressAndAmount]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(external: [AddressAndAmount], `internal`: [AddressAndAmount]) {
        self.external = external
        self.`internal` = `internal`
    }
}

#if compiler(>=6)
extension SplitOutput: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSplitOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SplitOutput {
        return
            try SplitOutput(
                external: FfiConverterSequenceTypeAddressAndAmount.read(from: &buf), 
                internal: FfiConverterSequenceTypeAddressAndAmount.read(from: &buf)
        )
    }

    public static func write(_ value: SplitOutput, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAddressAndAmount.write(value.external, into: &buf)
        FfiConverterSequenceTypeAddressAndAmount.write(value.`internal`, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitOutput_lift(_ buf: RustBuffer) throws -> SplitOutput {
    return try FfiConverterTypeSplitOutput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSplitOutput_lower(_ value: SplitOutput) -> RustBuffer {
    return FfiConverterTypeSplitOutput.lower(value)
}


public enum AddressError: Swift.Error {

    
    
    case NoOutputs
    case ScriptError(String
    )
    case InvalidAddress
    case UnsupportedNetwork
    case WrongNetwork(current: Network
    )
    case EmptyAddress
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressError: FfiConverterRustBuffer {
    typealias SwiftType = AddressError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NoOutputs
        case 2: return .ScriptError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidAddress
        case 4: return .UnsupportedNetwork
        case 5: return .WrongNetwork(
            current: try FfiConverterTypeNetwork.read(from: &buf)
            )
        case 6: return .EmptyAddress

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NoOutputs:
            writeInt(&buf, Int32(1))
        
        
        case let .ScriptError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidAddress:
            writeInt(&buf, Int32(3))
        
        
        case .UnsupportedNetwork:
            writeInt(&buf, Int32(4))
        
        
        case let .WrongNetwork(current):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNetwork.write(current, into: &buf)
            
        
        case .EmptyAddress:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressError_lift(_ buf: RustBuffer) throws -> AddressError {
    return try FfiConverterTypeAddressError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressError_lower(_ value: AddressError) -> RustBuffer {
    return FfiConverterTypeAddressError.lower(value)
}


extension AddressError: Equatable, Hashable {}




extension AddressError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColorSchemeSelection {
    
    case light
    case dark
    case system
}


#if compiler(>=6)
extension ColorSchemeSelection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = ColorSchemeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColorSchemeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        case 3: return .system
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColorSchemeSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        
        case .system:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorSchemeSelection_lift(_ buf: RustBuffer) throws -> ColorSchemeSelection {
    return try FfiConverterTypeColorSchemeSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColorSchemeSelection_lower(_ value: ColorSchemeSelection) -> RustBuffer {
    return FfiConverterTypeColorSchemeSelection.lower(value)
}


extension ColorSchemeSelection: Equatable, Hashable {}







public enum ConfirmDetailsError: Swift.Error {

    
    
    case QrCodeCreation(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmDetailsError: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmDetailsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmDetailsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .QrCodeCreation(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConfirmDetailsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .QrCodeCreation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetailsError_lift(_ buf: RustBuffer) throws -> ConfirmDetailsError {
    return try FfiConverterTypeConfirmDetailsError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmDetailsError_lower(_ value: ConfirmDetailsError) -> RustBuffer {
    return FfiConverterTypeConfirmDetailsError.lower(value)
}


extension ConfirmDetailsError: Equatable, Hashable {}




extension ConfirmDetailsError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FeeSpeed {
    
    case fast
    case medium
    case slow
    case custom(durationMins: UInt32
    )
}


#if compiler(>=6)
extension FeeSpeed: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeSpeed: FfiConverterRustBuffer {
    typealias SwiftType = FeeSpeed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSpeed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fast
        
        case 2: return .medium
        
        case 3: return .slow
        
        case 4: return .custom(durationMins: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeSpeed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fast:
            writeInt(&buf, Int32(1))
        
        
        case .medium:
            writeInt(&buf, Int32(2))
        
        
        case .slow:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(durationMins):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(durationMins, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSpeed_lift(_ buf: RustBuffer) throws -> FeeSpeed {
    return try FfiConverterTypeFeeSpeed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSpeed_lower(_ value: FeeSpeed) -> RustBuffer {
    return FfiConverterTypeFeeSpeed.lower(value)
}


extension FeeSpeed: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColor {
    
    case red(FfiOpacity
    )
    case blue(FfiOpacity
    )
    case green(FfiOpacity
    )
    case yellow(FfiOpacity
    )
    case orange(FfiOpacity
    )
    case purple(FfiOpacity
    )
    case pink(FfiOpacity
    )
    case white(FfiOpacity
    )
    case black(FfiOpacity
    )
    case gray(FfiOpacity
    )
    case coolGray(FfiOpacity
    )
    case custom(Rgb,FfiOpacity
    )
}


#if compiler(>=6)
extension FfiColor: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiColor: FfiConverterRustBuffer {
    typealias SwiftType = FfiColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 2: return .blue(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 3: return .green(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 4: return .yellow(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 5: return .orange(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 6: return .purple(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 7: return .pink(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 8: return .white(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 9: return .black(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 10: return .gray(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 11: return .coolGray(try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        case 12: return .custom(try FfiConverterTypeRgb.read(from: &buf), try FfiConverterTypeFfiOpacity.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .red(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .blue(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .green(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .yellow(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .orange(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .purple(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .pink(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .white(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .black(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .gray(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .coolGray(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeFfiOpacity.write(v1, into: &buf)
            
        
        case let .custom(v1,v2):
            writeInt(&buf, Int32(12))
            FfiConverterTypeRgb.write(v1, into: &buf)
            FfiConverterTypeFfiOpacity.write(v2, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColor_lift(_ buf: RustBuffer) throws -> FfiColor {
    return try FfiConverterTypeFfiColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColor_lower(_ value: FfiColor) -> RustBuffer {
    return FfiConverterTypeFfiColor.lower(value)
}


extension FfiColor: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiColorScheme {
    
    case light
    case dark
}


#if compiler(>=6)
extension FfiColorScheme: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiColorScheme: FfiConverterRustBuffer {
    typealias SwiftType = FfiColorScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiColorScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .light
        
        case 2: return .dark
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiColorScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case .light:
            writeInt(&buf, Int32(1))
        
        
        case .dark:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColorScheme_lift(_ buf: RustBuffer) throws -> FfiColorScheme {
    return try FfiConverterTypeFfiColorScheme.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiColorScheme_lower(_ value: FfiColorScheme) -> RustBuffer {
    return FfiConverterTypeFfiColorScheme.lower(value)
}


extension FfiColorScheme: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case bitcoin
    case testnet
    case signet
}


#if compiler(>=6)
extension Network: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}







public enum PsbtError: Swift.Error {

    
    
    case MissingUtxo
    case NegativeFee
    case FeeOverflow
    case Other(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePsbtError: FfiConverterRustBuffer {
    typealias SwiftType = PsbtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PsbtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingUtxo
        case 2: return .NegativeFee
        case 3: return .FeeOverflow
        case 4: return .Other(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PsbtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingUtxo:
            writeInt(&buf, Int32(1))
        
        
        case .NegativeFee:
            writeInt(&buf, Int32(2))
        
        
        case .FeeOverflow:
            writeInt(&buf, Int32(3))
        
        
        case let .Other(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lift(_ buf: RustBuffer) throws -> PsbtError {
    return try FfiConverterTypePsbtError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePsbtError_lower(_ value: PsbtError) -> RustBuffer {
    return FfiConverterTypePsbtError.lower(value)
}


extension PsbtError: Equatable, Hashable {}




extension PsbtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionDirection {
    
    case incoming
    case outgoing
}


#if compiler(>=6)
extension TransactionDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDirection: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .incoming
        
        case 2: return .outgoing
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .incoming:
            writeInt(&buf, Int32(1))
        
        
        case .outgoing:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDirection_lift(_ buf: RustBuffer) throws -> TransactionDirection {
    return try FfiConverterTypeTransactionDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDirection_lower(_ value: TransactionDirection) -> RustBuffer {
    return FfiConverterTypeTransactionDirection.lower(value)
}


extension TransactionDirection: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Unit {
    
    case btc
    case sat
}


#if compiler(>=6)
extension Unit: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnit: FfiConverterRustBuffer {
    typealias SwiftType = Unit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .btc
        
        case 2: return .sat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Unit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .btc:
            writeInt(&buf, Int32(1))
        
        
        case .sat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnit_lift(_ buf: RustBuffer) throws -> Unit {
    return try FfiConverterTypeUnit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnit_lower(_ value: Unit) -> RustBuffer {
    return FfiConverterTypeUnit.lower(value)
}


extension Unit: Equatable, Hashable {}






#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeeRateOptionWithTotalFee: FfiConverterRustBuffer {
    typealias SwiftType = FeeRateOptionWithTotalFee?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeRateOptionWithTotalFee.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRateOptionWithTotalFee.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddressAndAmount: FfiConverterRustBuffer {
    typealias SwiftType = [AddressAndAmount]

    public static func write(_ value: [AddressAndAmount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressAndAmount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressAndAmount] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressAndAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddressAndAmount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeColorSchemeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [ColorSchemeSelection]

    public static func write(_ value: [ColorSchemeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeColorSchemeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ColorSchemeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [ColorSchemeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeColorSchemeSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [Network]

    public static func write(_ value: [Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNetwork.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnit: FfiConverterRustBuffer {
    typealias SwiftType = [Unit]

    public static func write(_ value: [Unit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Unit] {
        let len: Int32 = try readInt(&buf)
        var seq = [Unit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnit.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias FfiOpacity = UInt8

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiOpacity: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiOpacity {
        return try FfiConverterUInt8.read(from: &buf)
    }

    public static func write(_ value: FfiOpacity, into buf: inout [UInt8]) {
        return FfiConverterUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: UInt8) throws -> FfiOpacity {
        return try FfiConverterUInt8.lift(value)
    }

    public static func lower(_ value: FfiOpacity) -> UInt8 {
        return FfiConverterUInt8.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiOpacity_lift(_ value: UInt8) throws -> FfiOpacity {
    return try FfiConverterTypeFfiOpacity.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiOpacity_lower(_ value: FfiOpacity) -> UInt8 {
    return FfiConverterTypeFfiOpacity.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletId_lift(_ value: RustBuffer) throws -> WalletId {
    return try FfiConverterTypeWalletId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletId_lower(_ value: WalletId) -> RustBuffer {
    return FfiConverterTypeWalletId.lower(value)
}

public func addressIsEqual(lhs: Address, rhs: Address) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_func_address_is_equal(
        FfiConverterTypeAddress_lower(lhs),
        FfiConverterTypeAddress_lower(rhs),$0
    )
})
}
public func addressIsValid(address: String, network: Network)throws   {try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_func_address_is_valid(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
}
public func addressIsValidForNetwork(address: String, network: Network)throws   {try rustCallWithError(FfiConverterTypeAddressError_lift) {
    uniffi_cove_types_fn_func_address_is_valid_for_network(
        FfiConverterString.lower(address),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
}
public func addressStringSpacedOut(address: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_address_string_spaced_out(
        FfiConverterString.lower(address),$0
    )
})
}
public func allColorSchemes() -> [ColorSchemeSelection]  {
    return try!  FfiConverterSequenceTypeColorSchemeSelection.lift(try! rustCall() {
    uniffi_cove_types_fn_func_all_color_schemes($0
    )
})
}
public func allNetworks() -> [Network]  {
    return try!  FfiConverterSequenceTypeNetwork.lift(try! rustCall() {
    uniffi_cove_types_fn_func_all_networks($0
    )
})
}
public func allUnits() -> [Unit]  {
    return try!  FfiConverterSequenceTypeUnit.lift(try! rustCall() {
    uniffi_cove_types_fn_func_all_units($0
    )
})
}
public func colorSchemeSelectionCapitalizedString(colorScheme: ColorSchemeSelection) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_color_scheme_selection_capitalized_string(
        FfiConverterTypeColorSchemeSelection_lower(colorScheme),$0
    )
})
}
public func feeRateOptionsWithTotalFeeIsEqual(lhs: FeeRateOptionsWithTotalFee, rhs: FeeRateOptionsWithTotalFee) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_rate_options_with_total_fee_is_equal(
        FfiConverterTypeFeeRateOptionsWithTotalFee_lower(lhs),
        FfiConverterTypeFeeRateOptionsWithTotalFee_lower(rhs),$0
    )
})
}
public func feeSpeedDuration(feeSpeed: FeeSpeed) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_duration(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func feeSpeedIsCustom(feeSpeed: FeeSpeed) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_is_custom(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func feeSpeedToCircleColor(feeSpeed: FeeSpeed) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor_lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_to_circle_color(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func feeSpeedToString(feeSpeed: FeeSpeed) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_fee_speed_to_string(
        FfiConverterTypeFeeSpeed_lower(feeSpeed),$0
    )
})
}
public func networkToString(network: Network) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_network_to_string(
        FfiConverterTypeNetwork_lower(network),$0
    )
})
}
public func unitToString(unit: Unit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_types_fn_func_unit_to_string(
        FfiConverterTypeUnit_lower(unit),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cove_types_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_cove_types_checksum_func_address_is_equal() != 52493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_address_is_valid() != 14595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_address_is_valid_for_network() != 40110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_address_string_spaced_out() != 3722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_all_color_schemes() != 41794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_all_networks() != 39283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_all_units() != 10986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_color_scheme_selection_capitalized_string() != 21781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_rate_options_with_total_fee_is_equal() != 28103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_duration() != 9128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_is_custom() != 15411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_to_circle_color() != 51678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_fee_speed_to_string() != 14557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_network_to_string() != 39809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_func_unit_to_string() != 52878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_spaced_out() != 48577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_string() != 18040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_tostring() != 596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_address_unformatted() != 42481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfo_address() != 25247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfo_address_unformatted() != 11638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addressinfo_index() != 48719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_address() != 35941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_amount() != 13991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_addresswithnetwork_network() != 19521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_as_btc() != 19021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_as_sats() != 45064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_btc_string() != 51350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_btc_string_with_unit() != 14319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_fmt_string_with_unit() != 13588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_sats_string() != 10854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_amount_sats_string_with_unit() != 41252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_fee_rate() != 64136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_fee_total() != 46798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_id() != 25703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_id_hash() != 52978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_inputs() != 64636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_normalized_id() != 41475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_outputs() != 53367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt() != 42998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_bytes() != 40387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_to_bbqr() != 34024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_psbt_to_hex() != 37877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_sending_amount() != 7338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_sending_to() != 246) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_confirmdetails_spending_amount() != 57179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerate_sat_per_vb() != 37038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_duration() != 2580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_fee_rate() != 12209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_fee_speed() != 30616) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_is_equal() != 37427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoption_sat_per_vb() != 26807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_duration() != 20795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate() != 14488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_rate_options() != 28190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_fee_speed() != 10011) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_custom() != 2457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_is_equal() != 188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_sat_per_vb() != 10771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionwithtotalfee_total_fee() != 19319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptions_fast() != 58050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptions_medium() != 46514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptions_slow() != 25223) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_add_custom_fee() != 49234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_add_custom_fee_rate() != 8985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_calculate_custom_fee_speed() != 59236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_custom() != 1083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fast() != 4059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_fee_rate_options() != 49243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_get_fee_rate_with() != 9780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_medium() != 49175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_remove_custom_fee() != 7542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_slow() != 41223) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_feerateoptionswithtotalfee_transaction_size() != 38410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_fee() != 64967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_output_total_amount() != 35605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_tx_id() != 2819) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_psbt_weight() != 45133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_amount() != 29531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_amount_fmt() != 30361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_direction() != 45513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_external_sent() != 31349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_label() != 30415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_received() != 21592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_sentandreceived_sent() != 9820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_txid_as_hash_string() != 46331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_method_txid_is_equal() != 12412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_address_from_string() != 25852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_address_preview_new() != 59780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_addresswithnetwork_new() != 19636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_amount_from_sat() != 46692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_amount_one_btc() != 40476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_amount_one_sat() != 38530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_confirmdetails_preview_new() != 47317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerate_from_sat_per_vb() != 23381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoption_new() != 8797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoptionwithtotalfee_new() != 12642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoptions_preview_new() != 15683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_feerateoptionswithtotalfee_preview_new() != 34906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_types_checksum_constructor_psbt_new() != 54693) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureCoveTypesInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all