// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(coveFFI)
import coveFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_cove_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_cove_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureCoveInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AddressArgsProtocol: AnyObject, Sendable {
    
}
open class AddressArgs: AddressArgsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_addressargs(self.handle, $0) }
    }
public convenience init(address: Address?, changeAddress: Address?, direction: TransactionDirection) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_addressargs_new(
        FfiConverterOptionTypeAddress.lower(address),
        FfiConverterOptionTypeAddress.lower(changeAddress),
        FfiConverterTypeTransactionDirection_lower(direction),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_addressargs(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressArgs: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = AddressArgs

    public static func lift(_ handle: UInt64) throws -> AddressArgs {
        return AddressArgs(unsafeFromHandle: handle)
    }

    public static func lower(_ value: AddressArgs) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressArgs {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: AddressArgs, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressArgs_lift(_ handle: UInt64) throws -> AddressArgs {
    return try FfiConverterTypeAddressArgs.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressArgs_lower(_ value: AddressArgs) -> UInt64 {
    return FfiConverterTypeAddressArgs.lower(value)
}






public protocol AuthPinProtocol: AnyObject, Sendable {
    
    func check(pin: String)  -> Bool
    
}
open class AuthPin: AuthPinProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_authpin(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_authpin_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_authpin(handle, $0) }
    }

    

    
open func check(pin: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_authpin_check(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(pin),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthPin: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = AuthPin

    public static func lift(_ handle: UInt64) throws -> AuthPin {
        return AuthPin(unsafeFromHandle: handle)
    }

    public static func lower(_ value: AuthPin) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthPin {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: AuthPin, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthPin_lift(_ handle: UInt64) throws -> AuthPin {
    return try FfiConverterTypeAuthPin.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthPin_lower(_ value: AuthPin) -> UInt64 {
    return FfiConverterTypeAuthPin.lower(value)
}






public protocol AutoComplete: AnyObject, Sendable {
    
    func autocomplete(word: String)  -> [String]
    
    func isValidWord(word: String)  -> Bool
    
}
open class AutoCompleteImpl: AutoComplete, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_autocomplete(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_autocomplete(handle, $0) }
    }

    

    
open func autocomplete(word: String) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_autocomplete_autocomplete(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),$0
    )
})
}
    
open func isValidWord(word: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_autocomplete_is_valid_word(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),$0
    )
})
}
    

    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAutoComplete {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAutoComplete] = [UniffiVTableCallbackInterfaceAutoComplete(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterTypeAutoComplete.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface AutoComplete: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterTypeAutoComplete.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface AutoComplete: handle missing in uniffiClone")
            }
        },
        autocomplete: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [String] in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.autocomplete(
                     word: try FfiConverterString.lift(word)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        isValidWord: { (
            uniffiHandle: UInt64,
            word: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeAutoComplete.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.isValidWord(
                     word: try FfiConverterString.lift(word)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitAutoComplete() {
    uniffi_cove_fn_init_callback_vtable_autocomplete(UniffiCallbackInterfaceAutoComplete.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAutoComplete: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<AutoComplete>()

    typealias FfiType = UInt64
    typealias SwiftType = AutoComplete

    public static func lift(_ handle: UInt64) throws -> AutoComplete {
        if ((handle & 1) == 0) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return AutoCompleteImpl(unsafeFromHandle: handle)
        } else {
            // Swift-generated handle, get the object from the handle map
            return try handleMap.remove(handle: handle)
        }
    }

    public static func lower(_ value: AutoComplete) -> UInt64 {
         if let rustImpl = value as? AutoCompleteImpl {
             // Rust-implemented object.  Clone the handle and return it
            return rustImpl.uniffiCloneHandle()
         } else {
            // Swift object, generate a new vtable handle and return that.
            return handleMap.insert(obj: value)
         }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AutoComplete {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: AutoComplete, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAutoComplete_lift(_ handle: UInt64) throws -> AutoComplete {
    return try FfiConverterTypeAutoComplete.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAutoComplete_lower(_ value: AutoComplete) -> UInt64 {
    return FfiConverterTypeAutoComplete.lower(value)
}






public protocol BalanceProtocol: AnyObject, Sendable {
    
    func spendable()  -> Amount
    
}
open class Balance: BalanceProtocol, @unchecked Sendable, Equatable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_balance(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_balance(handle, $0) }
    }

    
public static func zero() -> Balance  {
    return try!  FfiConverterTypeBalance_lift(try! rustCall() {
    uniffi_cove_fn_constructor_balance_zero($0
    )
})
}
    

    
open func spendable() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_method_balance_spendable(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: Balance, other: Balance) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_fn_method_balance_uniffi_trait_eq_eq(
            self.uniffiCloneHandle(),
        FfiConverterTypeBalance_lower(other),$0
    )
}
    )
}
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalance: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Balance

    public static func lift(_ handle: UInt64) throws -> Balance {
        return Balance(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Balance) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lift(_ handle: UInt64) throws -> Balance {
    return try FfiConverterTypeBalance.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalance_lower(_ value: Balance) -> UInt64 {
    return FfiConverterTypeBalance.lower(value)
}






public protocol Bip329LabelsProtocol: AnyObject, Sendable {
    
}
open class Bip329Labels: Bip329LabelsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_bip329labels(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip329labels(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip329Labels: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Bip329Labels

    public static func lift(_ handle: UInt64) throws -> Bip329Labels {
        return Bip329Labels(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Bip329Labels) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip329Labels {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Bip329Labels, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip329Labels_lift(_ handle: UInt64) throws -> Bip329Labels {
    return try FfiConverterTypeBip329Labels.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip329Labels_lower(_ value: Bip329Labels) -> UInt64 {
    return FfiConverterTypeBip329Labels.lower(value)
}






public protocol Bip39AutoCompleteProtocol: AnyObject, Sendable {
    
    func autocomplete(word: String)  -> [String]
    
    func isValidWord(word: String)  -> Bool
    
    /**
     * Find the next invalid or empty field number
     */
    func nextFieldNumber(currentFieldNumber: UInt8, enteredWords: [String])  -> UInt8
    
}
open class Bip39AutoComplete: Bip39AutoCompleteProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_bip39autocomplete(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_bip39autocomplete_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39autocomplete(handle, $0) }
    }

    

    
open func autocomplete(word: String) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39autocomplete_autocomplete(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),$0
    )
})
}
    
open func isValidWord(word: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39autocomplete_is_valid_word(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),$0
    )
})
}
    
    /**
     * Find the next invalid or empty field number
     */
open func nextFieldNumber(currentFieldNumber: UInt8, enteredWords: [String]) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39autocomplete_next_field_number(
            self.uniffiCloneHandle(),
        FfiConverterUInt8.lower(currentFieldNumber),
        FfiConverterSequenceString.lower(enteredWords),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39AutoComplete: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Bip39AutoComplete

    public static func lift(_ handle: UInt64) throws -> Bip39AutoComplete {
        return Bip39AutoComplete(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Bip39AutoComplete) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39AutoComplete {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Bip39AutoComplete, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}
extension Bip39AutoComplete: AutoComplete {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39AutoComplete_lift(_ handle: UInt64) throws -> Bip39AutoComplete {
    return try FfiConverterTypeBip39AutoComplete.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39AutoComplete_lower(_ value: Bip39AutoComplete) -> UInt64 {
    return FfiConverterTypeBip39AutoComplete.lower(value)
}






public protocol Bip39WordSpecificAutocompleteProtocol: AnyObject, Sendable {
    
    func autocomplete(word: String, allWords: [[String]])  -> [String]
    
    func isBip39Word(word: String)  -> Bool
    
    func isValidWord(word: String, allWords: [[String]])  -> Bool
    
    func nextFieldNumber(currentFieldNumber: UInt8, enteredWords: [String])  -> UInt8
    
}
open class Bip39WordSpecificAutocomplete: Bip39WordSpecificAutocompleteProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_bip39wordspecificautocomplete(self.handle, $0) }
    }
public convenience init(wordNumber: UInt16, numberOfWords: NumberOfBip39Words) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_bip39wordspecificautocomplete_new(
        FfiConverterUInt16.lower(wordNumber),
        FfiConverterTypeNumberOfBip39Words_lower(numberOfWords),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_bip39wordspecificautocomplete(handle, $0) }
    }

    

    
open func autocomplete(word: String, allWords: [[String]]) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_autocomplete(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),
        FfiConverterSequenceSequenceString.lower(allWords),$0
    )
})
}
    
open func isBip39Word(word: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_is_bip39_word(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),$0
    )
})
}
    
open func isValidWord(word: String, allWords: [[String]]) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_is_valid_word(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),
        FfiConverterSequenceSequenceString.lower(allWords),$0
    )
})
}
    
open func nextFieldNumber(currentFieldNumber: UInt8, enteredWords: [String]) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_bip39wordspecificautocomplete_next_field_number(
            self.uniffiCloneHandle(),
        FfiConverterUInt8.lower(currentFieldNumber),
        FfiConverterSequenceString.lower(enteredWords),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39WordSpecificAutocomplete: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Bip39WordSpecificAutocomplete

    public static func lift(_ handle: UInt64) throws -> Bip39WordSpecificAutocomplete {
        return Bip39WordSpecificAutocomplete(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Bip39WordSpecificAutocomplete) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordSpecificAutocomplete {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Bip39WordSpecificAutocomplete, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39WordSpecificAutocomplete_lift(_ handle: UInt64) throws -> Bip39WordSpecificAutocomplete {
    return try FfiConverterTypeBip39WordSpecificAutocomplete.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39WordSpecificAutocomplete_lower(_ value: Bip39WordSpecificAutocomplete) -> UInt64 {
    return FfiConverterTypeBip39WordSpecificAutocomplete.lower(value)
}






public protocol BitcoinTransactionProtocol: AnyObject, Sendable {
    
    func normalizeTxId()  -> String
    
    func txId()  -> TxId
    
    func txIdHash()  -> String
    
}
open class BitcoinTransaction: BitcoinTransactionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_bitcointransaction(self.handle, $0) }
    }
public convenience init(txHex: String)throws  {
    let handle =
        try rustCallWithError(FfiConverterTypeBitcoinTransactionError_lift) {
    uniffi_cove_fn_constructor_bitcointransaction_new(
        FfiConverterString.lower(txHex),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_bitcointransaction(handle, $0) }
    }

    
public static func tryFromData(data: Data)throws  -> BitcoinTransaction  {
    return try  FfiConverterTypeBitcoinTransaction_lift(try rustCallWithError(FfiConverterTypeBitcoinTransactionError_lift) {
    uniffi_cove_fn_constructor_bitcointransaction_tryfromdata(
        FfiConverterData.lower(data),$0
    )
})
}
    
public static func tryFromNfcMessage(nfcMessage: NfcMessage)throws  -> BitcoinTransaction  {
    return try  FfiConverterTypeBitcoinTransaction_lift(try rustCallWithError(FfiConverterTypeBitcoinTransactionError_lift) {
    uniffi_cove_fn_constructor_bitcointransaction_tryfromnfcmessage(
        FfiConverterTypeNfcMessage_lower(nfcMessage),$0
    )
})
}
    
public static func tryFromStringOrData(stringOrData: StringOrData)throws  -> BitcoinTransaction  {
    return try  FfiConverterTypeBitcoinTransaction_lift(try rustCallWithError(FfiConverterTypeBitcoinTransactionError_lift) {
    uniffi_cove_fn_constructor_bitcointransaction_tryfromstringordata(
        FfiConverterTypeStringOrData_lower(stringOrData),$0
    )
})
}
    

    
open func normalizeTxId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_bitcointransaction_normalize_tx_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_bitcointransaction_tx_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txIdHash() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_bitcointransaction_tx_id_hash(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinTransaction: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = BitcoinTransaction

    public static func lift(_ handle: UInt64) throws -> BitcoinTransaction {
        return BitcoinTransaction(unsafeFromHandle: handle)
    }

    public static func lower(_ value: BitcoinTransaction) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinTransaction {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: BitcoinTransaction, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTransaction_lift(_ handle: UInt64) throws -> BitcoinTransaction {
    return try FfiConverterTypeBitcoinTransaction.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTransaction_lower(_ value: BitcoinTransaction) -> UInt64 {
    return FfiConverterTypeBitcoinTransaction.lower(value)
}






public protocol BoxedRouteProtocol: AnyObject, Sendable {
    
    func route()  -> Route
    
}
open class BoxedRoute: BoxedRouteProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_boxedroute(self.handle, $0) }
    }
public convenience init(route: Route) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_boxedroute_new(
        FfiConverterTypeRoute_lower(route),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_boxedroute(handle, $0) }
    }

    

    
open func route() -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_boxedroute_route(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBoxedRoute: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = BoxedRoute

    public static func lift(_ handle: UInt64) throws -> BoxedRoute {
        return BoxedRoute(unsafeFromHandle: handle)
    }

    public static func lower(_ value: BoxedRoute) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BoxedRoute {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: BoxedRoute, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBoxedRoute_lift(_ handle: UInt64) throws -> BoxedRoute {
    return try FfiConverterTypeBoxedRoute.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBoxedRoute_lower(_ value: BoxedRoute) -> UInt64 {
    return FfiConverterTypeBoxedRoute.lower(value)
}






public protocol CoinControlManagerStateProtocol: AnyObject, Sendable {
    
}
open class CoinControlManagerState: CoinControlManagerStateProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_coincontrolmanagerstate(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_coincontrolmanagerstate(handle, $0) }
    }

    
public static func previewNew(outputCount: UInt8 = UInt8(20), changeCount: UInt8 = UInt8(4)) -> CoinControlManagerState  {
    return try!  FfiConverterTypeCoinControlManagerState_lift(try! rustCall() {
    uniffi_cove_fn_constructor_coincontrolmanagerstate_preview_new(
        FfiConverterUInt8.lower(outputCount),
        FfiConverterUInt8.lower(changeCount),$0
    )
})
}
    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlManagerState: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = CoinControlManagerState

    public static func lift(_ handle: UInt64) throws -> CoinControlManagerState {
        return CoinControlManagerState(unsafeFromHandle: handle)
    }

    public static func lower(_ value: CoinControlManagerState) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlManagerState {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: CoinControlManagerState, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlManagerState_lift(_ handle: UInt64) throws -> CoinControlManagerState {
    return try FfiConverterTypeCoinControlManagerState.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlManagerState_lower(_ value: CoinControlManagerState) -> UInt64 {
    return FfiConverterTypeCoinControlManagerState.lower(value)
}






public protocol ConfirmedTransactionProtocol: AnyObject, Sendable {
    
    func blockHeight()  -> UInt32
    
    func blockHeightFmt()  -> String
    
    func confirmedAt()  -> UInt64
    
    func confirmedAtFmt()  -> String
    
    func confirmedAtFmtWithTime()  -> String
    
    func fiatAmount()  -> FiatAmount?
    
    func id()  -> TxId
    
    func label()  -> String
    
    func labelOpt()  -> String?
    
    func sentAndReceived()  -> SentAndReceived
    
}
open class ConfirmedTransaction: ConfirmedTransactionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_confirmedtransaction(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_confirmedtransaction(handle, $0) }
    }

    

    
open func blockHeight() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_block_height(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func blockHeightFmt() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_block_height_fmt(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func confirmedAt() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_confirmed_at(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func confirmedAtFmt() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func confirmedAtFmtWithTime() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_confirmed_at_fmt_with_time(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func fiatAmount() -> FiatAmount?  {
    return try!  FfiConverterOptionTypeFiatAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_fiat_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_label(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func labelOpt() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_label_opt(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sentAndReceived() -> SentAndReceived  {
    return try!  FfiConverterTypeSentAndReceived_lift(try! rustCall() {
    uniffi_cove_fn_method_confirmedtransaction_sent_and_received(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmedTransaction: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ConfirmedTransaction

    public static func lift(_ handle: UInt64) throws -> ConfirmedTransaction {
        return ConfirmedTransaction(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ConfirmedTransaction) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmedTransaction {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ConfirmedTransaction, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedTransaction_lift(_ handle: UInt64) throws -> ConfirmedTransaction {
    return try FfiConverterTypeConfirmedTransaction.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedTransaction_lower(_ value: ConfirmedTransaction) -> UInt64 {
    return FfiConverterTypeConfirmedTransaction.lower(value)
}






public protocol ConverterProtocol: AnyObject, Sendable {
    
    func parseFiatStr(fiatAmount: String) throws  -> Double
    
    func removeFiatSuffix(fiatAmount: String)  -> String
    
}
open class Converter: ConverterProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_converter(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_converter_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_converter(handle, $0) }
    }

    

    
open func parseFiatStr(fiatAmount: String)throws  -> Double  {
    return try  FfiConverterDouble.lift(try rustCallWithError(FfiConverterTypeConverterError_lift) {
    uniffi_cove_fn_method_converter_parse_fiat_str(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(fiatAmount),$0
    )
})
}
    
open func removeFiatSuffix(fiatAmount: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_converter_remove_fiat_suffix(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(fiatAmount),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConverter: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Converter

    public static func lift(_ handle: UInt64) throws -> Converter {
        return Converter(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Converter) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Converter {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Converter, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConverter_lift(_ handle: UInt64) throws -> Converter {
    return try FfiConverterTypeConverter.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConverter_lower(_ value: Converter) -> UInt64 {
    return FfiConverterTypeConverter.lower(value)
}






public protocol DatabaseProtocol: AnyObject, Sendable {
    
    func dangerousResetAllData() 
    
    func globalConfig()  -> GlobalConfigTable
    
    func globalFlag()  -> GlobalFlagTable
    
    func historicalPrices()  -> HistoricalPriceTable
    
    func unsignedTransactions()  -> UnsignedTransactionsTable
    
    func wallets()  -> WalletsTable
    
}
open class Database: DatabaseProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_database(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_database_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_database(handle, $0) }
    }

    

    
open func dangerousResetAllData()  {try! rustCall() {
    uniffi_cove_fn_method_database_dangerous_reset_all_data(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func globalConfig() -> GlobalConfigTable  {
    return try!  FfiConverterTypeGlobalConfigTable_lift(try! rustCall() {
    uniffi_cove_fn_method_database_global_config(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func globalFlag() -> GlobalFlagTable  {
    return try!  FfiConverterTypeGlobalFlagTable_lift(try! rustCall() {
    uniffi_cove_fn_method_database_global_flag(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func historicalPrices() -> HistoricalPriceTable  {
    return try!  FfiConverterTypeHistoricalPriceTable_lift(try! rustCall() {
    uniffi_cove_fn_method_database_historical_prices(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func unsignedTransactions() -> UnsignedTransactionsTable  {
    return try!  FfiConverterTypeUnsignedTransactionsTable_lift(try! rustCall() {
    uniffi_cove_fn_method_database_unsigned_transactions(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func wallets() -> WalletsTable  {
    return try!  FfiConverterTypeWalletsTable_lift(try! rustCall() {
    uniffi_cove_fn_method_database_wallets(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatabase: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Database

    public static func lift(_ handle: UInt64) throws -> Database {
        return Database(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Database) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Database {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Database, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabase_lift(_ handle: UInt64) throws -> Database {
    return try FfiConverterTypeDatabase.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabase_lower(_ value: Database) -> UInt64 {
    return FfiConverterTypeDatabase.lower(value)
}






/**
 * Representation of our app over FFI. Essenially a wrapper of [`App`].
 */
public protocol FfiAppProtocol: AnyObject, Sendable {
    
    /**
     * Get the auth type for the app
     */
    func authType()  -> AuthType
    
    /**
     * check if the router has any routes to go back to
     */
    func canGoBack()  -> Bool
    
    /**
     * DANGER: This will wipe all wallet data on this device
     */
    func dangerousWipeAllData() 
    
    func debugOrRelease()  -> String
    
    /**
     * Frontend calls this method to send events to the rust application logic
     */
    func dispatch(action: AppAction) 
    
    func emailMailto(ios: String)  -> String
    
    func fees() throws  -> FeeResponse
    
    /**
     * Find tapsigner wallet by card ident
     * Get the backup for the tap signer
     */
    func findTapSignerWallet(tapSigner: TapSigner)  -> WalletMetadata?
    
    /**
     * Get the backup for the tap signer
     */
    func getTapSignerBackup(tapSigner: TapSigner)  -> Data?
    
    func gitShortHash()  -> String
    
    /**
     * Get the selected wallet
     */
    func goToSelectedWallet()  -> WalletId?
    
    /**
     * Check if there's any wallets
     */
    func hasWallets()  -> Bool
    
    /**
     * run all initialization tasks here, only called once
     */
    func initOnStart() async 
    
    /**
     * check if the router is at the root route (no routes to go back to)
     */
    func isAtRoot()  -> Bool
    
    func listenForUpdates(updater: FfiReconcile) 
    
    /**
     * Load and reset the default route after default delay
     */
    func loadAndResetDefaultRoute(route: Route) 
    
    /**
     * Load and reset the default route
     * Shows a laoding screen, and then resets the default route
     */
    func loadAndResetDefaultRouteAfter(route: Route, afterMillis: UInt32) 
    
    func network()  -> Network
    
    /**
     * Number of wallets
     */
    func numWallets()  -> UInt16
    
    func prices() throws  -> PriceResponse
    
    /**
     * Reset to the default route with nested routes, only used by the `LoadingAndResetContainer`
     */
    func resetAfterLoading(to: [Route]) 
    
    /**
     * Change the default route, and reset the routes
     */
    func resetDefaultRouteTo(route: Route) 
    
    /**
     * Reset the default route, with a nested route
     */
    func resetNestedRoutesTo(defaultRoute: Route, nestedRoutes: [Route]) 
    
    /**
     * Save the backup for the tap signer in the keychain
     */
    func saveTapSignerBackup(tapSigner: TapSigner, backup: Data)  -> Bool
    
    /**
     * Select the latest (most recently used) wallet or navigate to new wallet flow
     * This selects the wallet with the most recent scan activity
     */
    func selectLatestOrNewWallet() 
    
    /**
     * Select a wallet
     */
    func selectWallet(id: WalletId, nextRoute: Route?) throws 
    
    func state()  -> AppState
    
    /**
     * Get wallets that have not been backed up and verified
     */
    func unverifiedWalletIds()  -> [WalletId]
    
    func version()  -> String
    
}
/**
 * Representation of our app over FFI. Essenially a wrapper of [`App`].
 */
open class FfiApp: FfiAppProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_ffiapp(self.handle, $0) }
    }
    /**
     * FFI constructor which wraps in an Arc
     */
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_ffiapp_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_ffiapp(handle, $0) }
    }

    

    
    /**
     * Get the auth type for the app
     */
open func authType() -> AuthType  {
    return try!  FfiConverterTypeAuthType_lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_auth_type(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * check if the router has any routes to go back to
     */
open func canGoBack() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_can_go_back(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * DANGER: This will wipe all wallet data on this device
     */
open func dangerousWipeAllData()  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_dangerous_wipe_all_data(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func debugOrRelease() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_debug_or_release(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Frontend calls this method to send events to the rust application logic
     */
open func dispatch(action: AppAction)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypeAppAction_lower(action),$0
    )
}
}
    
open func emailMailto(ios: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_email_mailto(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(ios),$0
    )
})
}
    
open func fees()throws  -> FeeResponse  {
    return try  FfiConverterTypeFeeResponse_lift(try rustCallWithError(FfiConverterTypeAppError_lift) {
    uniffi_cove_fn_method_ffiapp_fees(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Find tapsigner wallet by card ident
     * Get the backup for the tap signer
     */
open func findTapSignerWallet(tapSigner: TapSigner) -> WalletMetadata?  {
    return try!  FfiConverterOptionTypeWalletMetadata.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_find_tap_signer_wallet(
            self.uniffiCloneHandle(),
        FfiConverterTypeTapSigner_lower(tapSigner),$0
    )
})
}
    
    /**
     * Get the backup for the tap signer
     */
open func getTapSignerBackup(tapSigner: TapSigner) -> Data?  {
    return try!  FfiConverterOptionData.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_get_tap_signer_backup(
            self.uniffiCloneHandle(),
        FfiConverterTypeTapSigner_lower(tapSigner),$0
    )
})
}
    
open func gitShortHash() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_git_short_hash(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the selected wallet
     */
open func goToSelectedWallet() -> WalletId?  {
    return try!  FfiConverterOptionTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_go_to_selected_wallet(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Check if there's any wallets
     */
open func hasWallets() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_has_wallets(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * run all initialization tasks here, only called once
     */
open func initOnStart()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_ffiapp_init_on_start(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * check if the router is at the root route (no routes to go back to)
     */
open func isAtRoot() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_is_at_root(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func listenForUpdates(updater: FfiReconcile)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceFfiReconcile_lower(updater),$0
    )
}
}
    
    /**
     * Load and reset the default route after default delay
     */
open func loadAndResetDefaultRoute(route: Route)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_load_and_reset_default_route(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(route),$0
    )
}
}
    
    /**
     * Load and reset the default route
     * Shows a laoding screen, and then resets the default route
     */
open func loadAndResetDefaultRouteAfter(route: Route, afterMillis: UInt32)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_load_and_reset_default_route_after(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(route),
        FfiConverterUInt32.lower(afterMillis),$0
    )
}
}
    
open func network() -> Network  {
    return try!  FfiConverterTypeNetwork_lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_network(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Number of wallets
     */
open func numWallets() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_num_wallets(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func prices()throws  -> PriceResponse  {
    return try  FfiConverterTypePriceResponse_lift(try rustCallWithError(FfiConverterTypeAppError_lift) {
    uniffi_cove_fn_method_ffiapp_prices(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Reset to the default route with nested routes, only used by the `LoadingAndResetContainer`
     */
open func resetAfterLoading(to: [Route])  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_reset_after_loading(
            self.uniffiCloneHandle(),
        FfiConverterSequenceTypeRoute.lower(to),$0
    )
}
}
    
    /**
     * Change the default route, and reset the routes
     */
open func resetDefaultRouteTo(route: Route)  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_reset_default_route_to(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(route),$0
    )
}
}
    
    /**
     * Reset the default route, with a nested route
     */
open func resetNestedRoutesTo(defaultRoute: Route, nestedRoutes: [Route])  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_reset_nested_routes_to(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(defaultRoute),
        FfiConverterSequenceTypeRoute.lower(nestedRoutes),$0
    )
}
}
    
    /**
     * Save the backup for the tap signer in the keychain
     */
open func saveTapSignerBackup(tapSigner: TapSigner, backup: Data) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_save_tap_signer_backup(
            self.uniffiCloneHandle(),
        FfiConverterTypeTapSigner_lower(tapSigner),
        FfiConverterData.lower(backup),$0
    )
})
}
    
    /**
     * Select the latest (most recently used) wallet or navigate to new wallet flow
     * This selects the wallet with the most recent scan activity
     */
open func selectLatestOrNewWallet()  {try! rustCall() {
    uniffi_cove_fn_method_ffiapp_select_latest_or_new_wallet(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Select a wallet
     */
open func selectWallet(id: WalletId, nextRoute: Route? = nil)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_ffiapp_select_wallet(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),
        FfiConverterOptionTypeRoute.lower(nextRoute),$0
    )
}
}
    
open func state() -> AppState  {
    return try!  FfiConverterTypeAppState_lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get wallets that have not been backed up and verified
     */
open func unverifiedWalletIds() -> [WalletId]  {
    return try!  FfiConverterSequenceTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_unverified_wallet_ids(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func version() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_ffiapp_version(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiApp: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FfiApp

    public static func lift(_ handle: UInt64) throws -> FfiApp {
        return FfiApp(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FfiApp) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiApp {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FfiApp, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApp_lift(_ handle: UInt64) throws -> FfiApp {
    return try FfiConverterTypeFfiApp.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiApp_lower(_ value: FfiApp) -> UInt64 {
    return FfiConverterTypeFfiApp.lower(value)
}






public protocol FiatClientProtocol: AnyObject, Sendable {
    
}
open class FiatClient: FiatClientProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_fiatclient(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_fiatclient(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatClient: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FiatClient

    public static func lift(_ handle: UInt64) throws -> FiatClient {
        return FiatClient(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FiatClient) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatClient {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FiatClient, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatClient_lift(_ handle: UInt64) throws -> FiatClient {
    return try FfiConverterTypeFiatClient.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatClient_lower(_ value: FiatClient) -> UInt64 {
    return FfiConverterTypeFiatClient.lower(value)
}






public protocol FileHandlerProtocol: AnyObject, Sendable {
    
    func read() throws  -> MultiFormat
    
}
open class FileHandler: FileHandlerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_filehandler(self.handle, $0) }
    }
public convenience init(filePath: String) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_filehandler_new(
        FfiConverterString.lower(filePath),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_filehandler(handle, $0) }
    }

    

    
open func read()throws  -> MultiFormat  {
    return try  FfiConverterTypeMultiFormat_lift(try rustCallWithError(FfiConverterTypeFileHandlerError_lift) {
    uniffi_cove_fn_method_filehandler_read(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileHandler: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FileHandler

    public static func lift(_ handle: UInt64) throws -> FileHandler {
        return FileHandler(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FileHandler) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileHandler {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FileHandler, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileHandler_lift(_ handle: UInt64) throws -> FileHandler {
    return try FfiConverterTypeFileHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileHandler_lower(_ value: FileHandler) -> UInt64 {
    return FfiConverterTypeFileHandler.lower(value)
}






public protocol FilteredUtxosProtocol: AnyObject, Sendable {
    
}
open class FilteredUtxos: FilteredUtxosProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_filteredutxos(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_filteredutxos(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFilteredUtxos: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FilteredUtxos

    public static func lift(_ handle: UInt64) throws -> FilteredUtxos {
        return FilteredUtxos(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FilteredUtxos) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilteredUtxos {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FilteredUtxos, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilteredUtxos_lift(_ handle: UInt64) throws -> FilteredUtxos {
    return try FfiConverterTypeFilteredUtxos.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilteredUtxos_lower(_ value: FilteredUtxos) -> UInt64 {
    return FfiConverterTypeFilteredUtxos.lower(value)
}






public protocol FingerprintProtocol: AnyObject, Sendable {
    
    func asLowercase()  -> String
    
    func asUppercase()  -> String
    
}
open class Fingerprint: FingerprintProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_fingerprint(self.handle, $0) }
    }
public convenience init(id: WalletId)throws  {
    let handle =
        try rustCallWithError(FfiConverterTypeFingerprintError_lift) {
    uniffi_cove_fn_constructor_fingerprint_new(
        FfiConverterTypeWalletId_lower(id),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_fingerprint(handle, $0) }
    }

    

    
open func asLowercase() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_fingerprint_as_lowercase(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func asUppercase() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_fingerprint_as_uppercase(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFingerprint: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Fingerprint

    public static func lift(_ handle: UInt64) throws -> Fingerprint {
        return Fingerprint(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Fingerprint) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fingerprint {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Fingerprint, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFingerprint_lift(_ handle: UInt64) throws -> Fingerprint {
    return try FfiConverterTypeFingerprint.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFingerprint_lower(_ value: Fingerprint) -> UInt64 {
    return FfiConverterTypeFingerprint.lower(value)
}






public protocol FoundJsonProtocol: AnyObject, Sendable {
    
}
open class FoundJson: FoundJsonProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_foundjson(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_foundjson(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFoundJson: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = FoundJson

    public static func lift(_ handle: UInt64) throws -> FoundJson {
        return FoundJson(unsafeFromHandle: handle)
    }

    public static func lower(_ value: FoundJson) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FoundJson {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: FoundJson, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundJson_lift(_ handle: UInt64) throws -> FoundJson {
    return try FfiConverterTypeFoundJson.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundJson_lower(_ value: FoundJson) -> UInt64 {
    return FfiConverterTypeFoundJson.lower(value)
}






public protocol GlobalConfigTableProtocol: AnyObject, Sendable {
    
    func authType()  -> AuthType
    
    func clearSelectedWallet() throws 
    
    func colorScheme()  -> ColorSchemeSelection
    
    func delete(key: GlobalConfigKey) throws 
    
    func deleteHashedPinCode() throws 
    
    func get(key: GlobalConfigKey) throws  -> String?
    
    func hashedPinCode() throws  -> String
    
    func isInDecoyMode()  -> Bool
    
    func isInMainMode()  -> Bool
    
    func selectWallet(id: WalletId) throws 
    
    func selectedFiatCurrency()  -> FiatCurrency
    
    func selectedNetwork()  -> Network
    
    func selectedNode()  -> Node
    
    func selectedWallet()  -> WalletId?
    
    func set(key: GlobalConfigKey, value: String) throws 
    
    func setColorScheme(colorScheme: ColorSchemeSelection) throws 
    
    func setHashedPinCode(hashedPinCode: String) throws 
    
    func setSelectedNetwork(network: Network) throws 
    
    func setSelectedNode(node: Node) throws 
    
    func walletMode()  -> WalletMode
    
}
open class GlobalConfigTable: GlobalConfigTableProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_globalconfigtable(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_globalconfigtable(handle, $0) }
    }

    

    
open func authType() -> AuthType  {
    return try!  FfiConverterTypeAuthType_lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_authtype(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func clearSelectedWallet()throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_clear_selected_wallet(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func colorScheme() -> ColorSchemeSelection  {
    return try!  FfiConverterTypeColorSchemeSelection_lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_colorscheme(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func delete(key: GlobalConfigKey)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_delete(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalConfigKey_lower(key),$0
    )
}
}
    
open func deleteHashedPinCode()throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_delete_hashed_pin_code(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func get(key: GlobalConfigKey)throws  -> String?  {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_get(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalConfigKey_lower(key),$0
    )
})
}
    
open func hashedPinCode()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_hashed_pin_code(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isInDecoyMode() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_is_in_decoy_mode(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isInMainMode() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_is_in_main_mode(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func selectWallet(id: WalletId)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_select_wallet(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),$0
    )
}
}
    
open func selectedFiatCurrency() -> FiatCurrency  {
    return try!  FfiConverterTypeFiatCurrency_lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selectedfiatcurrency(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func selectedNetwork() -> Network  {
    return try!  FfiConverterTypeNetwork_lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selected_network(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func selectedNode() -> Node  {
    return try!  FfiConverterTypeNode_lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selected_node(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func selectedWallet() -> WalletId?  {
    return try!  FfiConverterOptionTypeWalletId.lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_selected_wallet(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func set(key: GlobalConfigKey, value: String)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_set(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalConfigKey_lower(key),
        FfiConverterString.lower(value),$0
    )
}
}
    
open func setColorScheme(colorScheme: ColorSchemeSelection)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_setcolorscheme(
            self.uniffiCloneHandle(),
        FfiConverterTypeColorSchemeSelection_lower(colorScheme),$0
    )
}
}
    
open func setHashedPinCode(hashedPinCode: String)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_set_hashed_pin_code(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(hashedPinCode),$0
    )
}
}
    
open func setSelectedNetwork(network: Network)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_set_selected_network(
            self.uniffiCloneHandle(),
        FfiConverterTypeNetwork_lower(network),$0
    )
}
}
    
open func setSelectedNode(node: Node)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalconfigtable_set_selected_node(
            self.uniffiCloneHandle(),
        FfiConverterTypeNode_lower(node),$0
    )
}
}
    
open func walletMode() -> WalletMode  {
    return try!  FfiConverterTypeWalletMode_lift(try! rustCall() {
    uniffi_cove_fn_method_globalconfigtable_wallet_mode(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfigTable: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = GlobalConfigTable

    public static func lift(_ handle: UInt64) throws -> GlobalConfigTable {
        return GlobalConfigTable(unsafeFromHandle: handle)
    }

    public static func lower(_ value: GlobalConfigTable) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigTable {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: GlobalConfigTable, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigTable_lift(_ handle: UInt64) throws -> GlobalConfigTable {
    return try FfiConverterTypeGlobalConfigTable.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigTable_lower(_ value: GlobalConfigTable) -> UInt64 {
    return FfiConverterTypeGlobalConfigTable.lower(value)
}






public protocol GlobalFlagTableProtocol: AnyObject, Sendable {
    
    func get(key: GlobalFlagKey) throws  -> Bool
    
    func getBoolConfig(key: GlobalFlagKey)  -> Bool
    
    func isTermsAccepted()  -> Bool
    
    func set(key: GlobalFlagKey, value: Bool) throws 
    
    func setBoolConfig(key: GlobalFlagKey, value: Bool) throws 
    
    func toggleBoolConfig(key: GlobalFlagKey) throws 
    
}
open class GlobalFlagTable: GlobalFlagTableProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_globalflagtable(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_globalflagtable(handle, $0) }
    }

    

    
open func get(key: GlobalFlagKey)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalflagtable_get(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalFlagKey_lower(key),$0
    )
})
}
    
open func getBoolConfig(key: GlobalFlagKey) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_globalflagtable_get_bool_config(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalFlagKey_lower(key),$0
    )
})
}
    
open func isTermsAccepted() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_globalflagtable_is_terms_accepted(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func set(key: GlobalFlagKey, value: Bool)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalflagtable_set(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalFlagKey_lower(key),
        FfiConverterBool.lower(value),$0
    )
}
}
    
open func setBoolConfig(key: GlobalFlagKey, value: Bool)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalflagtable_set_bool_config(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalFlagKey_lower(key),
        FfiConverterBool.lower(value),$0
    )
}
}
    
open func toggleBoolConfig(key: GlobalFlagKey)throws   {try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_globalflagtable_toggle_bool_config(
            self.uniffiCloneHandle(),
        FfiConverterTypeGlobalFlagKey_lower(key),$0
    )
}
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalFlagTable: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = GlobalFlagTable

    public static func lift(_ handle: UInt64) throws -> GlobalFlagTable {
        return GlobalFlagTable(unsafeFromHandle: handle)
    }

    public static func lower(_ value: GlobalFlagTable) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagTable {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: GlobalFlagTable, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagTable_lift(_ handle: UInt64) throws -> GlobalFlagTable {
    return try FfiConverterTypeGlobalFlagTable.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagTable_lower(_ value: GlobalFlagTable) -> UInt64 {
    return FfiConverterTypeGlobalFlagTable.lower(value)
}






public protocol HardwareExportProtocol: AnyObject, Sendable {
    
}
open class HardwareExport: HardwareExportProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_hardwareexport(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_hardwareexport(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHardwareExport: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = HardwareExport

    public static func lift(_ handle: UInt64) throws -> HardwareExport {
        return HardwareExport(unsafeFromHandle: handle)
    }

    public static func lower(_ value: HardwareExport) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HardwareExport {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: HardwareExport, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardwareExport_lift(_ handle: UInt64) throws -> HardwareExport {
    return try FfiConverterTypeHardwareExport.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardwareExport_lower(_ value: HardwareExport) -> UInt64 {
    return FfiConverterTypeHardwareExport.lower(value)
}






public protocol HeaderIconPresenterProtocol: AnyObject, Sendable {
    
    func backgroundColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int64)  -> FfiColor
    
    func iconColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int64)  -> FfiColor
    
    func ringColor(state: TransactionState, colorScheme: FfiColorScheme, direction: TransactionDirection, confirmations: Int64, ringNumber: Int64)  -> FfiColor
    
}
open class HeaderIconPresenter: HeaderIconPresenterProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_headericonpresenter(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_headericonpresenter_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_headericonpresenter(handle, $0) }
    }

    

    
open func backgroundColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int64) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor_lift(try! rustCall() {
    uniffi_cove_fn_method_headericonpresenter_background_color(
            self.uniffiCloneHandle(),
        FfiConverterTypeTransactionState_lower(state),
        FfiConverterTypeTransactionDirection_lower(direction),
        FfiConverterTypeFfiColorScheme_lower(colorScheme),
        FfiConverterInt64.lower(confirmationCount),$0
    )
})
}
    
open func iconColor(state: TransactionState, direction: TransactionDirection, colorScheme: FfiColorScheme, confirmationCount: Int64) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor_lift(try! rustCall() {
    uniffi_cove_fn_method_headericonpresenter_icon_color(
            self.uniffiCloneHandle(),
        FfiConverterTypeTransactionState_lower(state),
        FfiConverterTypeTransactionDirection_lower(direction),
        FfiConverterTypeFfiColorScheme_lower(colorScheme),
        FfiConverterInt64.lower(confirmationCount),$0
    )
})
}
    
open func ringColor(state: TransactionState, colorScheme: FfiColorScheme, direction: TransactionDirection, confirmations: Int64, ringNumber: Int64) -> FfiColor  {
    return try!  FfiConverterTypeFfiColor_lift(try! rustCall() {
    uniffi_cove_fn_method_headericonpresenter_ring_color(
            self.uniffiCloneHandle(),
        FfiConverterTypeTransactionState_lower(state),
        FfiConverterTypeFfiColorScheme_lower(colorScheme),
        FfiConverterTypeTransactionDirection_lower(direction),
        FfiConverterInt64.lower(confirmations),
        FfiConverterInt64.lower(ringNumber),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeaderIconPresenter: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = HeaderIconPresenter

    public static func lift(_ handle: UInt64) throws -> HeaderIconPresenter {
        return HeaderIconPresenter(unsafeFromHandle: handle)
    }

    public static func lower(_ value: HeaderIconPresenter) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HeaderIconPresenter {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: HeaderIconPresenter, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderIconPresenter_lift(_ handle: UInt64) throws -> HeaderIconPresenter {
    return try FfiConverterTypeHeaderIconPresenter.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeaderIconPresenter_lower(_ value: HeaderIconPresenter) -> UInt64 {
    return FfiConverterTypeHeaderIconPresenter.lower(value)
}






public protocol HistoricalPriceTableProtocol: AnyObject, Sendable {
    
}
open class HistoricalPriceTable: HistoricalPriceTableProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_historicalpricetable(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_historicalpricetable(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHistoricalPriceTable: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = HistoricalPriceTable

    public static func lift(_ handle: UInt64) throws -> HistoricalPriceTable {
        return HistoricalPriceTable(unsafeFromHandle: handle)
    }

    public static func lower(_ value: HistoricalPriceTable) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoricalPriceTable {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: HistoricalPriceTable, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceTable_lift(_ handle: UInt64) throws -> HistoricalPriceTable {
    return try FfiConverterTypeHistoricalPriceTable.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceTable_lower(_ value: HistoricalPriceTable) -> UInt64 {
    return FfiConverterTypeHistoricalPriceTable.lower(value)
}






public protocol HistoricalPricesResponseProtocol: AnyObject, Sendable {
    
}
open class HistoricalPricesResponse: HistoricalPricesResponseProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_historicalpricesresponse(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_historicalpricesresponse(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHistoricalPricesResponse: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = HistoricalPricesResponse

    public static func lift(_ handle: UInt64) throws -> HistoricalPricesResponse {
        return HistoricalPricesResponse(unsafeFromHandle: handle)
    }

    public static func lower(_ value: HistoricalPricesResponse) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoricalPricesResponse {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: HistoricalPricesResponse, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPricesResponse_lift(_ handle: UInt64) throws -> HistoricalPricesResponse {
    return try FfiConverterTypeHistoricalPricesResponse.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPricesResponse_lower(_ value: HistoricalPricesResponse) -> UInt64 {
    return FfiConverterTypeHistoricalPricesResponse.lower(value)
}






public protocol LabelManagerProtocol: AnyObject, Sendable {
    
    func deleteLabelsForTxn(txId: TxId) throws 
    
    func export() async throws  -> String
    
    func exportDefaultFileName(name: String)  -> String
    
    /**
     * Export labels as BBQr-encoded QR strings for animated display
     */
    func exportToBbqrWithDensity(density: QrDensity) async throws  -> [String]
    
    func hasLabels()  -> Bool
    
    func `import`(jsonl: String) throws 
    
    func importLabels(labels: Bip329Labels) throws 
    
    func insertOrUpdateLabelsForTxn(details: TransactionDetails, label: String, origin: String?) throws 
    
    func transactionLabel(txId: TxId)  -> String?
    
}
open class LabelManager: LabelManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_labelmanager(self.handle, $0) }
    }
public convenience init(id: WalletId) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_labelmanager_new(
        FfiConverterTypeWalletId_lower(id),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_labelmanager(handle, $0) }
    }

    

    
open func deleteLabelsForTxn(txId: TxId)throws   {try rustCallWithError(FfiConverterTypeLabelManagerError_lift) {
    uniffi_cove_fn_method_labelmanager_delete_labels_for_txn(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(txId),$0
    )
}
}
    
open func export()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_labelmanager_export(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeLabelManagerError_lift
        )
}
    
open func exportDefaultFileName(name: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_labelmanager_export_default_file_name(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(name),$0
    )
})
}
    
    /**
     * Export labels as BBQr-encoded QR strings for animated display
     */
open func exportToBbqrWithDensity(density: QrDensity)async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_labelmanager_export_to_bbqr_with_density(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQrDensity_lower(density)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeLabelManagerError_lift
        )
}
    
open func hasLabels() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_labelmanager_has_labels(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func `import`(jsonl: String)throws   {try rustCallWithError(FfiConverterTypeLabelManagerError_lift) {
    uniffi_cove_fn_method_labelmanager_import(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(jsonl),$0
    )
}
}
    
open func importLabels(labels: Bip329Labels)throws   {try rustCallWithError(FfiConverterTypeLabelManagerError_lift) {
    uniffi_cove_fn_method_labelmanager_importlabels(
            self.uniffiCloneHandle(),
        FfiConverterTypeBip329Labels_lower(labels),$0
    )
}
}
    
open func insertOrUpdateLabelsForTxn(details: TransactionDetails, label: String, origin: String?)throws   {try rustCallWithError(FfiConverterTypeLabelManagerError_lift) {
    uniffi_cove_fn_method_labelmanager_insert_or_update_labels_for_txn(
            self.uniffiCloneHandle(),
        FfiConverterTypeTransactionDetails_lower(details),
        FfiConverterString.lower(label),
        FfiConverterOptionString.lower(origin),$0
    )
}
}
    
open func transactionLabel(txId: TxId) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_labelmanager_transaction_label(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(txId),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabelManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = LabelManager

    public static func lift(_ handle: UInt64) throws -> LabelManager {
        return LabelManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: LabelManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: LabelManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelManager_lift(_ handle: UInt64) throws -> LabelManager {
    return try FfiConverterTypeLabelManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelManager_lower(_ value: LabelManager) -> UInt64 {
    return FfiConverterTypeLabelManager.lower(value)
}






public protocol LabelsTableProtocol: AnyObject, Sendable {
    
}
open class LabelsTable: LabelsTableProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_labelstable(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_labelstable(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabelsTable: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = LabelsTable

    public static func lift(_ handle: UInt64) throws -> LabelsTable {
        return LabelsTable(unsafeFromHandle: handle)
    }

    public static func lower(_ value: LabelsTable) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelsTable {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: LabelsTable, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelsTable_lift(_ handle: UInt64) throws -> LabelsTable {
    return try FfiConverterTypeLabelsTable.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelsTable_lower(_ value: LabelsTable) -> UInt64 {
    return FfiConverterTypeLabelsTable.lower(value)
}






public protocol MnemonicProtocol: AnyObject, Sendable {
    
    func allWords()  -> [GroupedWord]
    
    /**
     * Converts mnemonic to SeedQR standard format string
     * Each word is converted to its 4-digit BIP39 index (0000-2047)
     */
    func toSeedQrString() throws  -> String
    
    func words()  -> [String]
    
}
open class Mnemonic: MnemonicProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_mnemonic(self.handle, $0) }
    }
public convenience init(id: WalletId)throws  {
    let handle =
        try rustCallWithError(FfiConverterTypeMnemonicError_lift) {
    uniffi_cove_fn_constructor_mnemonic_new(
        FfiConverterTypeWalletId_lower(id),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_mnemonic(handle, $0) }
    }

    
public static func preview(numberOfBip39Words: NumberOfBip39Words) -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic_lift(try! rustCall() {
    uniffi_cove_fn_constructor_mnemonic_preview(
        FfiConverterTypeNumberOfBip39Words_lower(numberOfBip39Words),$0
    )
})
}
    

    
open func allWords() -> [GroupedWord]  {
    return try!  FfiConverterSequenceTypeGroupedWord.lift(try! rustCall() {
    uniffi_cove_fn_method_mnemonic_all_words(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Converts mnemonic to SeedQR standard format string
     * Each word is converted to its 4-digit BIP39 index (0000-2047)
     */
open func toSeedQrString()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeMnemonicError_lift) {
    uniffi_cove_fn_method_mnemonic_to_seed_qr_string(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func words() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_mnemonic_words(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonic: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Mnemonic

    public static func lift(_ handle: UInt64) throws -> Mnemonic {
        return Mnemonic(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Mnemonic) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lift(_ handle: UInt64) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> UInt64 {
    return FfiConverterTypeMnemonic.lower(value)
}






public protocol NodeSelectorProtocol: AnyObject, Sendable {
    
    /**
     * Check the node url and set it as selected node if it is valid
     */
    func checkAndSaveNode(node: Node) async throws 
    
    func checkSelectedNode(node: Node) async throws 
    
    func nodeList()  -> [NodeSelection]
    
    /**
     * Use the url and name of the custom node to set it as the selected node
     */
    func parseCustomNode(url: String, name: String, enteredName: String) throws  -> Node
    
    func selectPresetNode(name: String) throws  -> Node
    
    func selectedNode()  -> NodeSelection
    
}
open class NodeSelector: NodeSelectorProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_nodeselector(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_nodeselector_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_nodeselector(handle, $0) }
    }

    

    
    /**
     * Check the node url and set it as selected node if it is valid
     */
open func checkAndSaveNode(node: Node)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_nodeselector_check_and_save_node(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeNode_lower(node)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNodeSelectorError_lift
        )
}
    
open func checkSelectedNode(node: Node)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_nodeselector_check_selected_node(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeNode_lower(node)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNodeSelectorError_lift
        )
}
    
open func nodeList() -> [NodeSelection]  {
    return try!  FfiConverterSequenceTypeNodeSelection.lift(try! rustCall() {
    uniffi_cove_fn_method_nodeselector_node_list(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Use the url and name of the custom node to set it as the selected node
     */
open func parseCustomNode(url: String, name: String, enteredName: String)throws  -> Node  {
    return try  FfiConverterTypeNode_lift(try rustCallWithError(FfiConverterTypeNodeSelectorError_lift) {
    uniffi_cove_fn_method_nodeselector_parse_custom_node(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(url),
        FfiConverterString.lower(name),
        FfiConverterString.lower(enteredName),$0
    )
})
}
    
open func selectPresetNode(name: String)throws  -> Node  {
    return try  FfiConverterTypeNode_lift(try rustCallWithError(FfiConverterTypeNodeSelectorError_lift) {
    uniffi_cove_fn_method_nodeselector_select_preset_node(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(name),$0
    )
})
}
    
open func selectedNode() -> NodeSelection  {
    return try!  FfiConverterTypeNodeSelection_lift(try! rustCall() {
    uniffi_cove_fn_method_nodeselector_selected_node(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeSelector: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = NodeSelector

    public static func lift(_ handle: UInt64) throws -> NodeSelector {
        return NodeSelector(unsafeFromHandle: handle)
    }

    public static func lower(_ value: NodeSelector) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelector {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: NodeSelector, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelector_lift(_ handle: UInt64) throws -> NodeSelector {
    return try FfiConverterTypeNodeSelector.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelector_lower(_ value: NodeSelector) -> UInt64 {
    return FfiConverterTypeNodeSelector.lower(value)
}






public protocol PendingWalletProtocol: AnyObject, Sendable {
    
}
open class PendingWallet: PendingWalletProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_pendingwallet(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_pendingwallet(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWallet: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = PendingWallet

    public static func lift(_ handle: UInt64) throws -> PendingWallet {
        return PendingWallet(unsafeFromHandle: handle)
    }

    public static func lower(_ value: PendingWallet) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWallet {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: PendingWallet, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWallet_lift(_ handle: UInt64) throws -> PendingWallet {
    return try FfiConverterTypePendingWallet.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWallet_lower(_ value: PendingWallet) -> UInt64 {
    return FfiConverterTypePendingWallet.lower(value)
}






public protocol PriceResponseProtocol: AnyObject, Sendable {
    
    func get()  -> UInt64
    
    func getForCurrency(currency: FiatCurrency)  -> UInt64
    
}
open class PriceResponse: PriceResponseProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_priceresponse(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_priceresponse(handle, $0) }
    }

    

    
open func get() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_priceresponse_get(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func getForCurrency(currency: FiatCurrency) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_priceresponse_get_for_currency(
            self.uniffiCloneHandle(),
        FfiConverterTypeFiatCurrency_lower(currency),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePriceResponse: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = PriceResponse

    public static func lift(_ handle: UInt64) throws -> PriceResponse {
        return PriceResponse(unsafeFromHandle: handle)
    }

    public static func lower(_ value: PriceResponse) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PriceResponse {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: PriceResponse, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePriceResponse_lift(_ handle: UInt64) throws -> PriceResponse {
    return try FfiConverterTypePriceResponse.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePriceResponse_lower(_ value: PriceResponse) -> UInt64 {
    return FfiConverterTypePriceResponse.lower(value)
}






public protocol PushTxProtocol: AnyObject, Sendable {
    
}
open class PushTx: PushTxProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_pushtx(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_pushtx(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePushTx: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = PushTx

    public static func lift(_ handle: UInt64) throws -> PushTx {
        return PushTx(unsafeFromHandle: handle)
    }

    public static func lower(_ value: PushTx) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushTx {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: PushTx, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePushTx_lift(_ handle: UInt64) throws -> PushTx {
    return try FfiConverterTypePushTx.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePushTx_lower(_ value: PushTx) -> UInt64 {
    return FfiConverterTypePushTx.lower(value)
}






/**
 * FFI wrapper for QrScanner state machine.
 *
 * This is the main entry point for QR scanning from Swift/Kotlin.
 * It wraps the internal state machine in a Mutex for thread safety.
 */
public protocol QrScannerProtocol: AnyObject, Sendable {
    
    /**
     * Reset the scanner state for a new scan session.
     */
    func reset() 
    
    /**
     * Scan a QR code and return the result.
     *
     * On first scan, detects the format and returns either:
     * - `Complete(MultiFormat)` for single-part QRs
     * - `InProgress(ScanProgress)` for multi-part QRs (BBQr or UR)
     *
     * On subsequent scans, adds parts and returns updated status.
     * The haptic field indicates what feedback the platform should trigger.
     */
    func scan(qr: StringOrData) throws  -> ScanResult
    
}
/**
 * FFI wrapper for QrScanner state machine.
 *
 * This is the main entry point for QR scanning from Swift/Kotlin.
 * It wraps the internal state machine in a Mutex for thread safety.
 */
open class QrScanner: QrScannerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_qrscanner(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_qrscanner_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_qrscanner(handle, $0) }
    }

    

    
    /**
     * Reset the scanner state for a new scan session.
     */
open func reset()  {try! rustCall() {
    uniffi_cove_fn_method_qrscanner_reset(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Scan a QR code and return the result.
     *
     * On first scan, detects the format and returns either:
     * - `Complete(MultiFormat)` for single-part QRs
     * - `InProgress(ScanProgress)` for multi-part QRs (BBQr or UR)
     *
     * On subsequent scans, adds parts and returns updated status.
     * The haptic field indicates what feedback the platform should trigger.
     */
open func scan(qr: StringOrData)throws  -> ScanResult  {
    return try  FfiConverterTypeScanResult_lift(try rustCallWithError(FfiConverterTypeMultiQrError_lift) {
    uniffi_cove_fn_method_qrscanner_scan(
            self.uniffiCloneHandle(),
        FfiConverterTypeStringOrData_lower(qr),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQrScanner: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = QrScanner

    public static func lift(_ handle: UInt64) throws -> QrScanner {
        return QrScanner(unsafeFromHandle: handle)
    }

    public static func lower(_ value: QrScanner) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrScanner {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: QrScanner, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrScanner_lift(_ handle: UInt64) throws -> QrScanner {
    return try FfiConverterTypeQrScanner.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrScanner_lower(_ value: QrScanner) -> UInt64 {
    return FfiConverterTypeQrScanner.lower(value)
}






public protocol RouteFactoryProtocol: AnyObject, Sendable {
    
    func coinControlSend(id: WalletId, utxos: [Utxo])  -> Route
    
    func coldWalletImport(route: ColdWalletRoute)  -> Route
    
    func hotWallet(route: HotWalletRoute)  -> Route
    
    func hotWalletImportFromScan()  -> Route
    
    func isSameParentRoute(route: Route, routeToCheck: Route)  -> Bool
    
    func loadAndResetNestedTo(defaultRoute: Route, nestedRoutes: [Route])  -> Route
    
    func loadAndResetTo(resetTo: Route)  -> Route
    
    func loadAndResetToAfter(resetTo: Route, time: UInt32)  -> Route
    
    func mainWalletSettings(id: WalletId)  -> Route
    
    func nestedSettings(route: SettingsRoute)  -> [Route]
    
    func nestedWalletSettings(id: WalletId)  -> [Route]
    
    func newHotWallet()  -> Route
    
    func newWalletSelect()  -> Route
    
    func qrImport()  -> Route
    
    func secretWords(walletId: WalletId)  -> Route
    
    func send(send: SendRoute)  -> Route
    
    func sendConfirm(id: WalletId, details: ConfirmDetails, signedTransaction: BitcoinTransaction?, signedPsbt: Psbt?)  -> Route
    
    func sendHardwareExport(id: WalletId, details: ConfirmDetails)  -> Route
    
    func sendSetAmount(id: WalletId, address: Address?, amount: Amount?)  -> Route
    
    func walletSettings(id: WalletId, route: WalletSettingsRoute)  -> Route
    
}
open class RouteFactory: RouteFactoryProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_routefactory(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_routefactory_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_routefactory(handle, $0) }
    }

    

    
open func coinControlSend(id: WalletId, utxos: [Utxo]) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_coin_control_send(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),
        FfiConverterSequenceTypeUtxo.lower(utxos),$0
    )
})
}
    
open func coldWalletImport(route: ColdWalletRoute) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_cold_wallet_import(
            self.uniffiCloneHandle(),
        FfiConverterTypeColdWalletRoute_lower(route),$0
    )
})
}
    
open func hotWallet(route: HotWalletRoute) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_hot_wallet(
            self.uniffiCloneHandle(),
        FfiConverterTypeHotWalletRoute_lower(route),$0
    )
})
}
    
open func hotWalletImportFromScan() -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_hot_wallet_import_from_scan(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isSameParentRoute(route: Route, routeToCheck: Route) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_is_same_parent_route(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(route),
        FfiConverterTypeRoute_lower(routeToCheck),$0
    )
})
}
    
open func loadAndResetNestedTo(defaultRoute: Route, nestedRoutes: [Route]) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_load_and_reset_nested_to(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(defaultRoute),
        FfiConverterSequenceTypeRoute.lower(nestedRoutes),$0
    )
})
}
    
open func loadAndResetTo(resetTo: Route) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_load_and_reset_to(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(resetTo),$0
    )
})
}
    
open func loadAndResetToAfter(resetTo: Route, time: UInt32) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_load_and_reset_to_after(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoute_lower(resetTo),
        FfiConverterUInt32.lower(time),$0
    )
})
}
    
open func mainWalletSettings(id: WalletId) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_main_wallet_settings(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),$0
    )
})
}
    
open func nestedSettings(route: SettingsRoute) -> [Route]  {
    return try!  FfiConverterSequenceTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_nested_settings(
            self.uniffiCloneHandle(),
        FfiConverterTypeSettingsRoute_lower(route),$0
    )
})
}
    
open func nestedWalletSettings(id: WalletId) -> [Route]  {
    return try!  FfiConverterSequenceTypeRoute.lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_nested_wallet_settings(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),$0
    )
})
}
    
open func newHotWallet() -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_new_hot_wallet(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func newWalletSelect() -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_new_wallet_select(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func qrImport() -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_qr_import(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func secretWords(walletId: WalletId) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_secret_words(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(walletId),$0
    )
})
}
    
open func send(send: SendRoute) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send(
            self.uniffiCloneHandle(),
        FfiConverterTypeSendRoute_lower(send),$0
    )
})
}
    
open func sendConfirm(id: WalletId, details: ConfirmDetails, signedTransaction: BitcoinTransaction? = nil, signedPsbt: Psbt? = nil) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send_confirm(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),
        FfiConverterTypeConfirmDetails_lower(details),
        FfiConverterOptionTypeBitcoinTransaction.lower(signedTransaction),
        FfiConverterOptionTypePsbt.lower(signedPsbt),$0
    )
})
}
    
open func sendHardwareExport(id: WalletId, details: ConfirmDetails) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send_hardware_export(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),
        FfiConverterTypeConfirmDetails_lower(details),$0
    )
})
}
    
open func sendSetAmount(id: WalletId, address: Address? = nil, amount: Amount? = nil) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_send_set_amount(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),
        FfiConverterOptionTypeAddress.lower(address),
        FfiConverterOptionTypeAmount.lower(amount),$0
    )
})
}
    
open func walletSettings(id: WalletId, route: WalletSettingsRoute) -> Route  {
    return try!  FfiConverterTypeRoute_lift(try! rustCall() {
    uniffi_cove_fn_method_routefactory_wallet_settings(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletId_lower(id),
        FfiConverterTypeWalletSettingsRoute_lower(route),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRouteFactory: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RouteFactory

    public static func lift(_ handle: UInt64) throws -> RouteFactory {
        return RouteFactory(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RouteFactory) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteFactory {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RouteFactory, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteFactory_lift(_ handle: UInt64) throws -> RouteFactory {
    return try FfiConverterTypeRouteFactory.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteFactory_lower(_ value: RouteFactory) -> UInt64 {
    return FfiConverterTypeRouteFactory.lower(value)
}






public protocol RustAuthManagerProtocol: AnyObject, Sendable {
    
    /**
     * Get the auth type for the app
     */
    func authType()  -> AuthType
    
    /**
     * Check to see if the passed in PIN matches the decoy pin
     */
    func checkDecoyPin(pin: String)  -> Bool
    
    /**
     * Check to see if the passed in PIN matches the wipe data PIN
     */
    func checkWipeDataPin(pin: String)  -> Bool
    
    /**
     * Delete the decoy pin
     */
    func deleteDecoyPin() 
    
    /**
     * Delete the wipe data pin
     */
    func deleteWipeDataPin() 
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: AuthManagerAction) 
    
    /**
     * Check if decoy pin is enabled, not if the user is in decoy mode
     */
    func isDecoyPinEnabled()  -> Bool
    
    /**
     * Actually check if the user is in decoy mode
     */
    func isInDecoyMode()  -> Bool
    
    /**
     * Check if the wipe data pin is enabled
     */
    func isWipeDataPinEnabled()  -> Bool
    
    func listenForUpdates(reconciler: AuthManagerReconciler) 
    
    func lockedAt()  -> UInt64?
    
    func send(message: AuthManagerReconcileMessage) 
    
    func setAuthType(authType: AuthType) 
    
    /**
     * Set the decoy pin
     */
    func setDecoyPin(pin: String) throws 
    
    func setLockedAt(lockedAt: UInt64) throws 
    
    /**
     * Set the wipe data pin
     */
    func setWipeDataPin(pin: String) throws 
    
    /**
     * Switch from main mode to decoy mode
     */
    func switchToDecoyMode() 
    
    /**
     * Switch from decoy mode to main mode
     */
    func switchToMainMode() 
    
    /**
     * Validate a new PIN doesn't conflict with existing PINs
     */
    func validateNewPin(newPin: String)  -> String?
    
    /**
     * Validate if we have the correct settings to be able to set a decoy or wipe data pin
     */
    func validatePinSettings(pin: String) throws 
    
    /**
     * Validate a security settings action and return what UI to show
     */
    func validateSecurityAction(action: SecuritySettingsAction, unverifiedWalletIds: [WalletId])  -> SecuritySettingsResult
    
}
open class RustAuthManager: RustAuthManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_rustauthmanager(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_rustauthmanager_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustauthmanager(handle, $0) }
    }

    

    
    /**
     * Get the auth type for the app
     */
open func authType() -> AuthType  {
    return try!  FfiConverterTypeAuthType_lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_auth_type(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Check to see if the passed in PIN matches the decoy pin
     */
open func checkDecoyPin(pin: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_checkdecoypin(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(pin),$0
    )
})
}
    
    /**
     * Check to see if the passed in PIN matches the wipe data PIN
     */
open func checkWipeDataPin(pin: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_checkwipedatapin(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(pin),$0
    )
})
}
    
    /**
     * Delete the decoy pin
     */
open func deleteDecoyPin()  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_delete_decoy_pin(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Delete the wipe data pin
     */
open func deleteWipeDataPin()  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_delete_wipe_data_pin(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: AuthManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypeAuthManagerAction_lower(action),$0
    )
}
}
    
    /**
     * Check if decoy pin is enabled, not if the user is in decoy mode
     */
open func isDecoyPinEnabled() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_is_decoy_pin_enabled(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Actually check if the user is in decoy mode
     */
open func isInDecoyMode() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_is_in_decoy_mode(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Check if the wipe data pin is enabled
     */
open func isWipeDataPinEnabled() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_is_wipe_data_pin_enabled(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func listenForUpdates(reconciler: AuthManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceAuthManagerReconciler_lower(reconciler),$0
    )
}
}
    
open func lockedAt() -> UInt64?  {
    return try!  FfiConverterOptionUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_locked_at(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func send(message: AuthManagerReconcileMessage)  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_send(
            self.uniffiCloneHandle(),
        FfiConverterTypeAuthManagerReconcileMessage_lower(message),$0
    )
}
}
    
open func setAuthType(authType: AuthType)  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_set_auth_type(
            self.uniffiCloneHandle(),
        FfiConverterTypeAuthType_lower(authType),$0
    )
}
}
    
    /**
     * Set the decoy pin
     */
open func setDecoyPin(pin: String)throws   {try rustCallWithError(FfiConverterTypeAuthManagerError_lift) {
    uniffi_cove_fn_method_rustauthmanager_set_decoy_pin(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(pin),$0
    )
}
}
    
open func setLockedAt(lockedAt: UInt64)throws   {try rustCallWithError(FfiConverterTypeAuthManagerError_lift) {
    uniffi_cove_fn_method_rustauthmanager_set_locked_at(
            self.uniffiCloneHandle(),
        FfiConverterUInt64.lower(lockedAt),$0
    )
}
}
    
    /**
     * Set the wipe data pin
     */
open func setWipeDataPin(pin: String)throws   {try rustCallWithError(FfiConverterTypeAuthManagerError_lift) {
    uniffi_cove_fn_method_rustauthmanager_set_wipe_data_pin(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(pin),$0
    )
}
}
    
    /**
     * Switch from main mode to decoy mode
     */
open func switchToDecoyMode()  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_switch_to_decoy_mode(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Switch from decoy mode to main mode
     */
open func switchToMainMode()  {try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_switch_to_main_mode(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Validate a new PIN doesn't conflict with existing PINs
     */
open func validateNewPin(newPin: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_validate_new_pin(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(newPin),$0
    )
})
}
    
    /**
     * Validate if we have the correct settings to be able to set a decoy or wipe data pin
     */
open func validatePinSettings(pin: String)throws   {try rustCallWithError(FfiConverterTypeTrickPinError_lift) {
    uniffi_cove_fn_method_rustauthmanager_validate_pin_settings(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(pin),$0
    )
}
}
    
    /**
     * Validate a security settings action and return what UI to show
     */
open func validateSecurityAction(action: SecuritySettingsAction, unverifiedWalletIds: [WalletId]) -> SecuritySettingsResult  {
    return try!  FfiConverterTypeSecuritySettingsResult_lift(try! rustCall() {
    uniffi_cove_fn_method_rustauthmanager_validate_security_action(
            self.uniffiCloneHandle(),
        FfiConverterTypeSecuritySettingsAction_lower(action),
        FfiConverterSequenceTypeWalletId.lower(unverifiedWalletIds),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustAuthManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RustAuthManager

    public static func lift(_ handle: UInt64) throws -> RustAuthManager {
        return RustAuthManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RustAuthManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustAuthManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RustAuthManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustAuthManager_lift(_ handle: UInt64) throws -> RustAuthManager {
    return try FfiConverterTypeRustAuthManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustAuthManager_lower(_ value: RustAuthManager) -> UInt64 {
    return FfiConverterTypeRustAuthManager.lower(value)
}






public protocol RustCoinControlManagerProtocol: AnyObject, Sendable {
    
    func buttonPresentation(button: CoinControlListSortKey)  -> ButtonPresentation
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: CoinControlManagerAction) 
    
    func id()  -> WalletId
    
    func listenForUpdates(reconciler: CoinControlManagerReconciler) 
    
    func reloadLabels() async 
    
    func selectedUtxos()  -> [Utxo]
    
    func unit()  -> BitcoinUnit
    
    func utxos()  -> [Utxo]
    
}
open class RustCoinControlManager: RustCoinControlManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_rustcoincontrolmanager(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustcoincontrolmanager(handle, $0) }
    }

    
public static func previewNew(outputCount: UInt8 = UInt8(20), changeCount: UInt8 = UInt8(4)) -> RustCoinControlManager  {
    return try!  FfiConverterTypeRustCoinControlManager_lift(try! rustCall() {
    uniffi_cove_fn_constructor_rustcoincontrolmanager_preview_new(
        FfiConverterUInt8.lower(outputCount),
        FfiConverterUInt8.lower(changeCount),$0
    )
})
}
    

    
open func buttonPresentation(button: CoinControlListSortKey) -> ButtonPresentation  {
    return try!  FfiConverterTypeButtonPresentation_lift(try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_button_presentation(
            self.uniffiCloneHandle(),
        FfiConverterTypeCoinControlListSortKey_lower(button),$0
    )
})
}
    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: CoinControlManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypeCoinControlManagerAction_lower(action),$0
    )
}
}
    
open func id() -> WalletId  {
    return try!  FfiConverterTypeWalletId_lift(try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func listenForUpdates(reconciler: CoinControlManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceCoinControlManagerReconciler_lower(reconciler),$0
    )
}
}
    
open func reloadLabels()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustcoincontrolmanager_reload_labels(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func selectedUtxos() -> [Utxo]  {
    return try!  FfiConverterSequenceTypeUtxo.lift(try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_selected_utxos(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func unit() -> BitcoinUnit  {
    return try!  FfiConverterTypeBitcoinUnit_lift(try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_unit(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func utxos() -> [Utxo]  {
    return try!  FfiConverterSequenceTypeUtxo.lift(try! rustCall() {
    uniffi_cove_fn_method_rustcoincontrolmanager_utxos(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustCoinControlManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RustCoinControlManager

    public static func lift(_ handle: UInt64) throws -> RustCoinControlManager {
        return RustCoinControlManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RustCoinControlManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustCoinControlManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RustCoinControlManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustCoinControlManager_lift(_ handle: UInt64) throws -> RustCoinControlManager {
    return try FfiConverterTypeRustCoinControlManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustCoinControlManager_lower(_ value: RustCoinControlManager) -> UInt64 {
    return FfiConverterTypeRustCoinControlManager.lower(value)
}






public protocol RustImportWalletManagerProtocol: AnyObject, Sendable {
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: ImportWalletManagerAction) 
    
    /**
     * Import wallet view from entered words
     */
    func importWallet(enteredWords: [[String]]) throws  -> WalletMetadata
    
    func listenForUpdates(reconciler: ImportWalletManagerReconciler) 
    
}
open class RustImportWalletManager: RustImportWalletManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_rustimportwalletmanager(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_rustimportwalletmanager_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustimportwalletmanager(handle, $0) }
    }

    

    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: ImportWalletManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustimportwalletmanager_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypeImportWalletManagerAction_lower(action),$0
    )
}
}
    
    /**
     * Import wallet view from entered words
     */
open func importWallet(enteredWords: [[String]])throws  -> WalletMetadata  {
    return try  FfiConverterTypeWalletMetadata_lift(try rustCallWithError(FfiConverterTypeImportWalletError_lift) {
    uniffi_cove_fn_method_rustimportwalletmanager_import_wallet(
            self.uniffiCloneHandle(),
        FfiConverterSequenceSequenceString.lower(enteredWords),$0
    )
})
}
    
open func listenForUpdates(reconciler: ImportWalletManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustimportwalletmanager_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceImportWalletManagerReconciler_lower(reconciler),$0
    )
}
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustImportWalletManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RustImportWalletManager

    public static func lift(_ handle: UInt64) throws -> RustImportWalletManager {
        return RustImportWalletManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RustImportWalletManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustImportWalletManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RustImportWalletManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustImportWalletManager_lift(_ handle: UInt64) throws -> RustImportWalletManager {
    return try FfiConverterTypeRustImportWalletManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustImportWalletManager_lower(_ value: RustImportWalletManager) -> UInt64 {
    return FfiConverterTypeRustImportWalletManager.lower(value)
}






public protocol RustPendingWalletManagerProtocol: AnyObject, Sendable {
    
    func bip39Words()  -> [String]
    
    func bip39WordsGrouped()  -> [[GroupedWord]]
    
    func cardIndexes()  -> UInt8
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: PendingWalletManagerAction) 
    
    func getState()  -> PendingWalletManagerState
    
    func listenForUpdates(reconciler: PendingWalletManagerReconciler) 
    
    func numberOfWordsCount()  -> UInt8
    
    func saveWallet() throws  -> WalletMetadata
    
}
open class RustPendingWalletManager: RustPendingWalletManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_rustpendingwalletmanager(self.handle, $0) }
    }
public convenience init(numberOfWords: NumberOfBip39Words) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_rustpendingwalletmanager_new(
        FfiConverterTypeNumberOfBip39Words_lower(numberOfWords),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustpendingwalletmanager(handle, $0) }
    }

    

    
open func bip39Words() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func bip39WordsGrouped() -> [[GroupedWord]]  {
    return try!  FfiConverterSequenceSequenceTypeGroupedWord.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_bip_39_words_grouped(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func cardIndexes() -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_card_indexes(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: PendingWalletManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypePendingWalletManagerAction_lower(action),$0
    )
}
}
    
open func getState() -> PendingWalletManagerState  {
    return try!  FfiConverterTypePendingWalletManagerState_lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_get_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func listenForUpdates(reconciler: PendingWalletManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfacePendingWalletManagerReconciler_lower(reconciler),$0
    )
}
}
    
open func numberOfWordsCount() -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_rustpendingwalletmanager_number_of_words_count(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func saveWallet()throws  -> WalletMetadata  {
    return try  FfiConverterTypeWalletMetadata_lift(try rustCallWithError(FfiConverterTypePendingWalletManagerError_lift) {
    uniffi_cove_fn_method_rustpendingwalletmanager_save_wallet(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustPendingWalletManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RustPendingWalletManager

    public static func lift(_ handle: UInt64) throws -> RustPendingWalletManager {
        return RustPendingWalletManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RustPendingWalletManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustPendingWalletManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RustPendingWalletManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustPendingWalletManager_lift(_ handle: UInt64) throws -> RustPendingWalletManager {
    return try FfiConverterTypeRustPendingWalletManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustPendingWalletManager_lower(_ value: RustPendingWalletManager) -> UInt64 {
    return FfiConverterTypeRustPendingWalletManager.lower(value)
}






public protocol RustSendFlowManagerProtocol: AnyObject, Sendable {
    
    func amount()  -> Amount
    
    func amountExceedsBalance()  -> Bool
    
    func amountSats()  -> UInt64
    
    /**
     * action from the frontend to change the state of the view model
     */
    func dispatch(action: SendFlowManagerAction) 
    
    func displayFiatAmount(amount: Double, withSuffix: Bool)  -> String
    
    func enteringFiatAmount()  -> String
    
    /**
     * get the custom fee rate option
     */
    func getCustomFeeOption(feeRate: FeeRate, feeSpeed: FeeSpeed) async throws  -> FeeRateOptionWithTotalFee
    
    func listenForUpdates(reconciler: SendFlowManagerReconciler) 
    
    func maxSendMinusFees()  -> Amount?
    
    func maxSendMinusFeesAndSmallUtxo()  -> Amount?
    
    func sanitizeBtcEnteringAmount(oldValue: String, newValue: String)  -> String?
    
    func sanitizeFiatEnteringAmount(oldValue: String, newValue: String)  -> String?
    
    func sendAmountBtc()  -> String
    
    func sendAmountFiat()  -> String
    
    func totalFeeString()  -> String?
    
    func totalSpentInBtc()  -> String
    
    func totalSpentInFiat()  -> String
    
    func utxos()  -> [Utxo]?
    
    func validateAddress(displayAlert: Bool)  -> Bool
    
    func validateAmount(displayAlert: Bool)  -> Bool
    
    func validateFeePercentage(displayAlert: Bool)  -> Bool
    
    /**
     * Wait until we have base fee rates, returns false if timeout
     * Returns immediately if we already have cached fees
     * Only blocks if no cached fees exist (first launch, network needed)
     * On timeout: shows alert and pops route
     */
    func waitForInit() async  -> Bool
    
    func walletId()  -> WalletId
    
}
open class RustSendFlowManager: RustSendFlowManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_rustsendflowmanager(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustsendflowmanager(handle, $0) }
    }

    

    
open func amount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amountExceedsBalance() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_amount_exceeds_balance(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amountSats() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_amount_sats(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * action from the frontend to change the state of the view model
     */
open func dispatch(action: SendFlowManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypeSendFlowManagerAction_lower(action),$0
    )
}
}
    
open func displayFiatAmount(amount: Double, withSuffix: Bool = true) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_display_fiat_amount(
            self.uniffiCloneHandle(),
        FfiConverterDouble.lower(amount),
        FfiConverterBool.lower(withSuffix),$0
    )
})
}
    
open func enteringFiatAmount() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_entering_fiat_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * get the custom fee rate option
     */
open func getCustomFeeOption(feeRate: FeeRate, feeSpeed: FeeSpeed)async throws  -> FeeRateOptionWithTotalFee  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustsendflowmanager_get_custom_fee_option(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeFeeRate_lower(feeRate),FfiConverterTypeFeeSpeed_lower(feeSpeed)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeFeeRateOptionWithTotalFee_lift,
            errorHandler: FfiConverterTypeSendFlowError_lift
        )
}
    
open func listenForUpdates(reconciler: SendFlowManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceSendFlowManagerReconciler_lower(reconciler),$0
    )
}
}
    
open func maxSendMinusFees() -> Amount?  {
    return try!  FfiConverterOptionTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_maxsendminusfees(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func maxSendMinusFeesAndSmallUtxo() -> Amount?  {
    return try!  FfiConverterOptionTypeAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_maxsendminusfeesandsmallutxo(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sanitizeBtcEnteringAmount(oldValue: String, newValue: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_sanitize_btc_entering_amount(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(oldValue),
        FfiConverterString.lower(newValue),$0
    )
})
}
    
open func sanitizeFiatEnteringAmount(oldValue: String, newValue: String) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_sanitize_fiat_entering_amount(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(oldValue),
        FfiConverterString.lower(newValue),$0
    )
})
}
    
open func sendAmountBtc() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_send_amount_btc(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sendAmountFiat() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_send_amount_fiat(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func totalFeeString() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_total_fee_string(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func totalSpentInBtc() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_total_spent_in_btc(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func totalSpentInFiat() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_total_spent_in_fiat(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func utxos() -> [Utxo]?  {
    return try!  FfiConverterOptionSequenceTypeUtxo.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_utxos(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func validateAddress(displayAlert: Bool = false) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_validate_address(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(displayAlert),$0
    )
})
}
    
open func validateAmount(displayAlert: Bool = false) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_validate_amount(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(displayAlert),$0
    )
})
}
    
open func validateFeePercentage(displayAlert: Bool = false) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_validate_fee_percentage(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(displayAlert),$0
    )
})
}
    
    /**
     * Wait until we have base fee rates, returns false if timeout
     * Returns immediately if we already have cached fees
     * Only blocks if no cached fees exist (first launch, network needed)
     * On timeout: shows alert and pops route
     */
open func waitForInit()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustsendflowmanager_wait_for_init(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_i8,
            completeFunc: ffi_cove_rust_future_complete_i8,
            freeFunc: ffi_cove_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
open func walletId() -> WalletId  {
    return try!  FfiConverterTypeWalletId_lift(try! rustCall() {
    uniffi_cove_fn_method_rustsendflowmanager_wallet_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustSendFlowManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RustSendFlowManager

    public static func lift(_ handle: UInt64) throws -> RustSendFlowManager {
        return RustSendFlowManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RustSendFlowManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustSendFlowManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RustSendFlowManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustSendFlowManager_lift(_ handle: UInt64) throws -> RustSendFlowManager {
    return try FfiConverterTypeRustSendFlowManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustSendFlowManager_lower(_ value: RustSendFlowManager) -> UInt64 {
    return FfiConverterTypeRustSendFlowManager.lower(value)
}






public protocol RustWalletManagerProtocol: AnyObject, Sendable {
    
    /**
     * Get address at the given index
     */
    func addressAt(index: UInt32) async throws  -> AddressInfo
    
    /**
     * Sync method using cached prices, returns None if no cached prices
     */
    func amountInFiat(amount: Amount)  -> Double?
    
    func balance() async  -> Balance
    
    func broadcastTransaction(signedTransaction: BitcoinTransaction) async throws 
    
    func convertAndDisplayFiat(amount: Amount, prices: PriceResponse, withSuffix: Bool)  -> String
    
    func convertFromFiatString(fiatAmount: String, prices: PriceResponse)  -> Amount
    
    func convertToFiat(amount: Amount, prices: PriceResponse)  -> Double
    
    func createTransactionsWithFiatExport() async throws  -> String
    
    func currentBlockHeight() async throws  -> UInt32
    
    func deleteUnsignedTransaction(txId: TxId) throws 
    
    func deleteWallet() throws 
    
    /**
     * Returns the warning message for the first delete confirmation dialog
     */
    func deletionWarningMessage()  -> String
    
    /**
     * Action from the frontend to change the state of the view model
     */
    func dispatch(action: WalletManagerAction) 
    
    func displayAmount(amount: Amount, showUnit: Bool)  -> String
    
    func displayFiatAmount(amount: Double, withSuffix: Bool)  -> String
    
    func displaySentAndReceivedAmount(sentAndReceived: SentAndReceived)  -> String
    
    /**
     * Export labels as QR codes with conditional loading popup
     */
    func exportLabelsForQr(density: QrDensity) async throws  -> [String]
    
    /**
     * Export labels for share with conditional loading popup
     */
    func exportLabelsForShare() async throws  -> LabelExportResult
    
    /**
     * Export transactions as CSV with conditional loading popup
     */
    func exportTransactionsCsv() async throws  -> TransactionExportResult
    
    /**
     * Export public descriptors (xpub) as QR codes
     */
    func exportXpubForQr(density: QrDensity) async throws  -> [String]
    
    /**
     * Export public descriptors (xpub) for share
     */
    func exportXpubForShare() async throws  -> XpubExportResult
    
    func feeRateOptions() async throws  -> FeeRateOptions
    
    func fees()  -> FeeResponse?
    
    /**
     * Finalize a signed PSBT
     */
    func finalizePsbt(psbt: Psbt) async throws  -> BitcoinTransaction
    
    func firstAddress() async throws  -> AddressInfo
    
    func forceUpdateHeight() async throws  -> UInt32
    
    func forceWalletScan() async 
    
    func getFeeOptions() async throws  -> FeeRateOptions
    
    /**
     * gets the transactions for the wallet that are currently available
     */
    func getTransactions() async 
    
    func getUnsignedTransactions() throws  -> [UnsignedTransaction]
    
    func labelManager()  -> LabelManager
    
    func listenForUpdates(reconciler: WalletManagerReconciler) 
    
    func markWalletAsVerified() throws 
    
    func masterFingerprint()  -> String?
    
    func newCoinControlManager() async  -> RustCoinControlManager
    
    func newSendFlowManager(balance: Balance)  -> RustSendFlowManager
    
    /**
     * Get the next address for the wallet
     */
    func nextAddress() async throws  -> AddressInfoWithDerivation
    
    func numberOfConfirmations(blockHeight: UInt32) async throws  -> UInt32
    
    func numberOfConfirmationsFmt(blockHeight: UInt32) async throws  -> String
    
    /**
     * Returns the number of confirmation steps required to delete this wallet
     * - 2: Cold wallets, xpub-only wallets, or verified hot wallets
     * - 3: Hot wallets that are NOT verified (highest risk)
     */
    func requiredDeletionConfirmations()  -> UInt8
    
    func saveUnsignedTransaction(details: ConfirmDetails) throws 
    
    func selectedFiatCurrency()  -> FiatCurrency
    
    func sentAndReceivedFiat(sentAndReceived: SentAndReceived) async throws  -> Double
    
    func setWalletMetadata(metadata: WalletMetadata) 
    
    func signAndBroadcastTransaction(psbt: Psbt) async throws 
    
    func splitTransactionOutputs(outputs: [AddressAndAmount]) async throws  -> SplitOutput
    
    func startWalletScan() async throws 
    
    func switchToDifferentWalletAddressType(walletAddressType: WalletAddressType) async throws 
    
    func transactionDetails(txId: TxId) async throws  -> TransactionDetails
    
    func validateMetadata() 
    
    func walletMetadata()  -> WalletMetadata
    
    func wordValidator() throws  -> WordValidator
    
}
open class RustWalletManager: RustWalletManagerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_rustwalletmanager(self.handle, $0) }
    }
public convenience init(id: WalletId)throws  {
    let handle =
        try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_constructor_rustwalletmanager_new(
        FfiConverterTypeWalletId_lower(id),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_rustwalletmanager(handle, $0) }
    }

    
public static func previewNewWallet() -> RustWalletManager  {
    return try!  FfiConverterTypeRustWalletManager_lift(try! rustCall() {
    uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet($0
    )
})
}
    
public static func previewNewWalletWithMetadata(metadata: WalletMetadata) -> RustWalletManager  {
    return try!  FfiConverterTypeRustWalletManager_lift(try! rustCall() {
    uniffi_cove_fn_constructor_rustwalletmanager_preview_new_wallet_with_metadata(
        FfiConverterTypeWalletMetadata_lower(metadata),$0
    )
})
}
    
public static func tryNewFromTapSigner(tapSigner: TapSigner, deriveInfo: DeriveInfo, backup: Data? = nil)throws  -> RustWalletManager  {
    return try  FfiConverterTypeRustWalletManager_lift(try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_tap_signer(
        FfiConverterTypeTapSigner_lower(tapSigner),
        FfiConverterTypeDeriveInfo_lower(deriveInfo),
        FfiConverterOptionData.lower(backup),$0
    )
})
}
    
public static func tryNewFromXpub(xpub: String)throws  -> RustWalletManager  {
    return try  FfiConverterTypeRustWalletManager_lift(try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_constructor_rustwalletmanager_try_new_from_xpub(
        FfiConverterString.lower(xpub),$0
    )
})
}
    

    
    /**
     * Get address at the given index
     */
open func addressAt(index: UInt32)async throws  -> AddressInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_address_at(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt32.lower(index)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeAddressInfo_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
    /**
     * Sync method using cached prices, returns None if no cached prices
     */
open func amountInFiat(amount: Amount) -> Double?  {
    return try!  FfiConverterOptionDouble.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_amount_in_fiat(
            self.uniffiCloneHandle(),
        FfiConverterTypeAmount_lower(amount),$0
    )
})
}
    
open func balance()async  -> Balance  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_balance(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeBalance_lift,
            errorHandler: nil
            
        )
}
    
open func broadcastTransaction(signedTransaction: BitcoinTransaction)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_broadcast_transaction(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeBitcoinTransaction_lower(signedTransaction)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func convertAndDisplayFiat(amount: Amount, prices: PriceResponse, withSuffix: Bool = true) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_convert_and_display_fiat(
            self.uniffiCloneHandle(),
        FfiConverterTypeAmount_lower(amount),
        FfiConverterTypePriceResponse_lower(prices),
        FfiConverterBool.lower(withSuffix),$0
    )
})
}
    
open func convertFromFiatString(fiatAmount: String, prices: PriceResponse) -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_convert_from_fiat_string(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(fiatAmount),
        FfiConverterTypePriceResponse_lower(prices),$0
    )
})
}
    
open func convertToFiat(amount: Amount, prices: PriceResponse) -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_convert_to_fiat(
            self.uniffiCloneHandle(),
        FfiConverterTypeAmount_lower(amount),
        FfiConverterTypePriceResponse_lower(prices),$0
    )
})
}
    
open func createTransactionsWithFiatExport()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_create_transactions_with_fiat_export(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func currentBlockHeight()async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_current_block_height(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u32,
            completeFunc: ffi_cove_rust_future_complete_u32,
            freeFunc: ffi_cove_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func deleteUnsignedTransaction(txId: TxId)throws   {try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_method_rustwalletmanager_delete_unsigned_transaction(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(txId),$0
    )
}
}
    
open func deleteWallet()throws   {try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_method_rustwalletmanager_delete_wallet(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Returns the warning message for the first delete confirmation dialog
     */
open func deletionWarningMessage() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_deletion_warning_message(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Action from the frontend to change the state of the view model
     */
open func dispatch(action: WalletManagerAction)  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_dispatch(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletManagerAction_lower(action),$0
    )
}
}
    
open func displayAmount(amount: Amount, showUnit: Bool = true) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_display_amount(
            self.uniffiCloneHandle(),
        FfiConverterTypeAmount_lower(amount),
        FfiConverterBool.lower(showUnit),$0
    )
})
}
    
open func displayFiatAmount(amount: Double, withSuffix: Bool = true) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_display_fiat_amount(
            self.uniffiCloneHandle(),
        FfiConverterDouble.lower(amount),
        FfiConverterBool.lower(withSuffix),$0
    )
})
}
    
open func displaySentAndReceivedAmount(sentAndReceived: SentAndReceived) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_display_sent_and_received_amount(
            self.uniffiCloneHandle(),
        FfiConverterTypeSentAndReceived_lower(sentAndReceived),$0
    )
})
}
    
    /**
     * Export labels as QR codes with conditional loading popup
     */
open func exportLabelsForQr(density: QrDensity)async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_export_labels_for_qr(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQrDensity_lower(density)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeLabelManagerError_lift
        )
}
    
    /**
     * Export labels for share with conditional loading popup
     */
open func exportLabelsForShare()async throws  -> LabelExportResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_export_labels_for_share(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLabelExportResult_lift,
            errorHandler: FfiConverterTypeLabelManagerError_lift
        )
}
    
    /**
     * Export transactions as CSV with conditional loading popup
     */
open func exportTransactionsCsv()async throws  -> TransactionExportResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_export_transactions_csv(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransactionExportResult_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
    /**
     * Export public descriptors (xpub) as QR codes
     */
open func exportXpubForQr(density: QrDensity)async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_export_xpub_for_qr(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQrDensity_lower(density)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
    /**
     * Export public descriptors (xpub) for share
     */
open func exportXpubForShare()async throws  -> XpubExportResult  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_export_xpub_for_share(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeXpubExportResult_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func feeRateOptions()async throws  -> FeeRateOptions  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_fee_rate_options(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeFeeRateOptions_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func fees() -> FeeResponse?  {
    return try!  FfiConverterOptionTypeFeeResponse.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_fees(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Finalize a signed PSBT
     */
open func finalizePsbt(psbt: Psbt)async throws  -> BitcoinTransaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_finalize_psbt(
                    self.uniffiCloneHandle(),
                    FfiConverterTypePsbt_lower(psbt)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeBitcoinTransaction_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func firstAddress()async throws  -> AddressInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_first_address(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeAddressInfo_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func forceUpdateHeight()async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_force_update_height(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u32,
            completeFunc: ffi_cove_rust_future_complete_u32,
            freeFunc: ffi_cove_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func forceWalletScan()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_force_wallet_scan(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func getFeeOptions()async throws  -> FeeRateOptions  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_get_fee_options(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeFeeRateOptions_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
    /**
     * gets the transactions for the wallet that are currently available
     */
open func getTransactions()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_get_transactions(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func getUnsignedTransactions()throws  -> [UnsignedTransaction]  {
    return try  FfiConverterSequenceTypeUnsignedTransaction.lift(try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_method_rustwalletmanager_get_unsigned_transactions(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func labelManager() -> LabelManager  {
    return try!  FfiConverterTypeLabelManager_lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_label_manager(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func listenForUpdates(reconciler: WalletManagerReconciler)  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_listen_for_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceWalletManagerReconciler_lower(reconciler),$0
    )
}
}
    
open func markWalletAsVerified()throws   {try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_method_rustwalletmanager_mark_wallet_as_verified(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func masterFingerprint() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_master_fingerprint(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func newCoinControlManager()async  -> RustCoinControlManager  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_new_coin_control_manager(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeRustCoinControlManager_lift,
            errorHandler: nil
            
        )
}
    
open func newSendFlowManager(balance: Balance) -> RustSendFlowManager  {
    return try!  FfiConverterTypeRustSendFlowManager_lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_new_send_flow_manager(
            self.uniffiCloneHandle(),
        FfiConverterTypeBalance_lower(balance),$0
    )
})
}
    
    /**
     * Get the next address for the wallet
     */
open func nextAddress()async throws  -> AddressInfoWithDerivation  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_next_address(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeAddressInfoWithDerivation_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func numberOfConfirmations(blockHeight: UInt32)async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt32.lower(blockHeight)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u32,
            completeFunc: ffi_cove_rust_future_complete_u32,
            freeFunc: ffi_cove_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func numberOfConfirmationsFmt(blockHeight: UInt32)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_number_of_confirmations_fmt(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt32.lower(blockHeight)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
    /**
     * Returns the number of confirmation steps required to delete this wallet
     * - 2: Cold wallets, xpub-only wallets, or verified hot wallets
     * - 3: Hot wallets that are NOT verified (highest risk)
     */
open func requiredDeletionConfirmations() -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_required_deletion_confirmations(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func saveUnsignedTransaction(details: ConfirmDetails)throws   {try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_method_rustwalletmanager_save_unsigned_transaction(
            self.uniffiCloneHandle(),
        FfiConverterTypeConfirmDetails_lower(details),$0
    )
}
}
    
open func selectedFiatCurrency() -> FiatCurrency  {
    return try!  FfiConverterTypeFiatCurrency_lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_selected_fiat_currency(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sentAndReceivedFiat(sentAndReceived: SentAndReceived)async throws  -> Double  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_sent_and_received_fiat(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeSentAndReceived_lower(sentAndReceived)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_f64,
            completeFunc: ffi_cove_rust_future_complete_f64,
            freeFunc: ffi_cove_rust_future_free_f64,
            liftFunc: FfiConverterDouble.lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func setWalletMetadata(metadata: WalletMetadata)  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_set_wallet_metadata(
            self.uniffiCloneHandle(),
        FfiConverterTypeWalletMetadata_lower(metadata),$0
    )
}
}
    
open func signAndBroadcastTransaction(psbt: Psbt)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_sign_and_broadcast_transaction(
                    self.uniffiCloneHandle(),
                    FfiConverterTypePsbt_lower(psbt)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func splitTransactionOutputs(outputs: [AddressAndAmount])async throws  -> SplitOutput  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_split_transaction_outputs(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceTypeAddressAndAmount.lower(outputs)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSplitOutput_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func startWalletScan()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_start_wallet_scan(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func switchToDifferentWalletAddressType(walletAddressType: WalletAddressType)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_switch_to_different_wallet_address_type(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeWalletAddressType_lower(walletAddressType)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func transactionDetails(txId: TxId)async throws  -> TransactionDetails  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_rustwalletmanager_transaction_details(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTxId_lower(txId)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeTransactionDetails_lift,
            errorHandler: FfiConverterTypeWalletManagerError_lift
        )
}
    
open func validateMetadata()  {try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_validate_metadata(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func walletMetadata() -> WalletMetadata  {
    return try!  FfiConverterTypeWalletMetadata_lift(try! rustCall() {
    uniffi_cove_fn_method_rustwalletmanager_wallet_metadata(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func wordValidator()throws  -> WordValidator  {
    return try  FfiConverterTypeWordValidator_lift(try rustCallWithError(FfiConverterTypeWalletManagerError_lift) {
    uniffi_cove_fn_method_rustwalletmanager_word_validator(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRustWalletManager: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RustWalletManager

    public static func lift(_ handle: UInt64) throws -> RustWalletManager {
        return RustWalletManager(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RustWalletManager) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustWalletManager {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RustWalletManager, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustWalletManager_lift(_ handle: UInt64) throws -> RustWalletManager {
    return try FfiConverterTypeRustWalletManager.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRustWalletManager_lower(_ value: RustWalletManager) -> UInt64 {
    return FfiConverterTypeRustWalletManager.lower(value)
}






public protocol SeedQrProtocol: AnyObject, Sendable {
    
    func getWords()  -> [String]
    
    func groupedPlainWords(groupsOf: UInt8)  -> [[String]]
    
}
open class SeedQr: SeedQrProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_seedqr(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_seedqr(handle, $0) }
    }

    
public static func newFromData(data: Data)throws  -> SeedQr  {
    return try  FfiConverterTypeSeedQr_lift(try rustCallWithError(FfiConverterTypeSeedQrError_lift) {
    uniffi_cove_fn_constructor_seedqr_new_from_data(
        FfiConverterData.lower(data),$0
    )
})
}
    
public static func newFromStr(qr: String)throws  -> SeedQr  {
    return try  FfiConverterTypeSeedQr_lift(try rustCallWithError(FfiConverterTypeSeedQrError_lift) {
    uniffi_cove_fn_constructor_seedqr_new_from_str(
        FfiConverterString.lower(qr),$0
    )
})
}
    

    
open func getWords() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_seedqr_get_words(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func groupedPlainWords(groupsOf: UInt8) -> [[String]]  {
    return try!  FfiConverterSequenceSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_seedqr_grouped_plain_words(
            self.uniffiCloneHandle(),
        FfiConverterUInt8.lower(groupsOf),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeedQr: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SeedQr

    public static func lift(_ handle: UInt64) throws -> SeedQr {
        return SeedQr(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SeedQr) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedQr {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SeedQr, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedQr_lift(_ handle: UInt64) throws -> SeedQr {
    return try FfiConverterTypeSeedQr.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedQr_lower(_ value: SeedQr) -> UInt64 {
    return FfiConverterTypeSeedQr.lower(value)
}






public protocol SendFlowManagerStateProtocol: AnyObject, Sendable {
    
}
open class SendFlowManagerState: SendFlowManagerStateProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_sendflowmanagerstate(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_sendflowmanagerstate(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowManagerState: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SendFlowManagerState

    public static func lift(_ handle: UInt64) throws -> SendFlowManagerState {
        return SendFlowManagerState(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SendFlowManagerState) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowManagerState {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SendFlowManagerState, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowManagerState_lift(_ handle: UInt64) throws -> SendFlowManagerState {
    return try FfiConverterTypeSendFlowManagerState.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowManagerState_lower(_ value: SendFlowManagerState) -> UInt64 {
    return FfiConverterTypeSendFlowManagerState.lower(value)
}






public protocol SetupCmdProtocol: AnyObject, Sendable {
    
}
open class SetupCmd: SetupCmdProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_setupcmd(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_setupcmd(handle, $0) }
    }

    
public static func tryNew(factoryPin: String, newPin: String, chainCode: Data? = nil)throws  -> SetupCmd  {
    return try  FfiConverterTypeSetupCmd_lift(try rustCallWithError(FfiConverterTypeTapSignerReaderError_lift) {
    uniffi_cove_fn_constructor_setupcmd_try_new(
        FfiConverterString.lower(factoryPin),
        FfiConverterString.lower(newPin),
        FfiConverterOptionData.lower(chainCode),$0
    )
})
}
    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetupCmd: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SetupCmd

    public static func lift(_ handle: UInt64) throws -> SetupCmd {
        return SetupCmd(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SetupCmd) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetupCmd {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SetupCmd, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetupCmd_lift(_ handle: UInt64) throws -> SetupCmd {
    return try FfiConverterTypeSetupCmd.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetupCmd_lower(_ value: SetupCmd) -> UInt64 {
    return FfiConverterTypeSetupCmd.lower(value)
}






public protocol TapSignerReaderProtocol: AnyObject, Sendable {
    
    /**
     * User started the setup process, but errored out before completing the setup, we can continue from the last step
     */
    func continueSetup(response: SetupCmdResponse) async throws  -> SetupCmdResponse
    
    /**
     * Get the last response from the reader
     */
    func lastResponse()  -> TapSignerResponse?
    
    func run() async throws  -> TapSignerResponse
    
    /**
     * Start the setup process
     */
    func setup(cmd: SetupCmd) async throws  -> SetupCmdResponse
    
    func sign(psbt: Psbt, pin: String) async throws  -> Psbt
    
}
open class TapSignerReader: TapSignerReaderProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_tapsignerreader(self.handle, $0) }
    }
public convenience init(transport: TapcardTransportProtocol, cmd: TapSignerCmd? = nil)async throws  {
    let handle =
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_constructor_tapsignerreader_new(FfiConverterCallbackInterfaceTapcardTransportProtocol_lower(transport),FfiConverterOptionTypeTapSignerCmd.lower(cmd)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeTapSignerReader_lift,
            errorHandler: FfiConverterTypeTapSignerReaderError_lift
        )
        
        .uniffiCloneHandle()
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_tapsignerreader(handle, $0) }
    }

    

    
    /**
     * User started the setup process, but errored out before completing the setup, we can continue from the last step
     */
open func continueSetup(response: SetupCmdResponse)async throws  -> SetupCmdResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_tapsignerreader_continue_setup(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeSetupCmdResponse_lower(response)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSetupCmdResponse_lift,
            errorHandler: FfiConverterTypeTapSignerReaderError_lift
        )
}
    
    /**
     * Get the last response from the reader
     */
open func lastResponse() -> TapSignerResponse?  {
    return try!  FfiConverterOptionTypeTapSignerResponse.lift(try! rustCall() {
    uniffi_cove_fn_method_tapsignerreader_last_response(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func run()async throws  -> TapSignerResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_tapsignerreader_run(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTapSignerResponse_lift,
            errorHandler: FfiConverterTypeTapSignerReaderError_lift
        )
}
    
    /**
     * Start the setup process
     */
open func setup(cmd: SetupCmd)async throws  -> SetupCmdResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_tapsignerreader_setup(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeSetupCmd_lower(cmd)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSetupCmdResponse_lift,
            errorHandler: FfiConverterTypeTapSignerReaderError_lift
        )
}
    
open func sign(psbt: Psbt, pin: String)async throws  -> Psbt  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_tapsignerreader_sign(
                    self.uniffiCloneHandle(),
                    FfiConverterTypePsbt_lower(psbt),FfiConverterString.lower(pin)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypePsbt_lift,
            errorHandler: FfiConverterTypeTapSignerReaderError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerReader: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TapSignerReader

    public static func lift(_ handle: UInt64) throws -> TapSignerReader {
        return TapSignerReader(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TapSignerReader) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerReader {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TapSignerReader, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerReader_lift(_ handle: UInt64) throws -> TapSignerReader {
    return try FfiConverterTypeTapSignerReader.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerReader_lower(_ value: TapSignerReader) -> UInt64 {
    return FfiConverterTypeTapSignerReader.lower(value)
}






public protocol TransactionDetailsProtocol: AnyObject, Sendable {
    
    func address()  -> Address?
    
    func addressSpacedOut()  -> String?
    
    func amount()  -> Amount
    
    func amountFiat() async throws  -> Double
    
    func amountFiatFmt() async throws  -> String
    
    func amountFiatFmtCached()  -> String?
    
    func amountFmt(unit: BitcoinUnit)  -> String
    
    func blockNumber()  -> UInt32?
    
    func blockNumberFmt()  -> String?
    
    func confirmationDateTime()  -> String?
    
    func feeFiatFmt() async throws  -> String
    
    func feeFiatFmtCached()  -> String?
    
    func feeFmt(unit: BitcoinUnit)  -> String?
    
    /**
     * Historical fiat value at time of transaction - async version (fetches from API if not cached)
     */
    func historicalFiatFmt() async throws  -> String
    
    /**
     * Historical fiat value at time of transaction - cached version (no network calls)
     */
    func historicalFiatFmtCached()  -> String?
    
    func isConfirmed()  -> Bool
    
    func isReceived()  -> Bool
    
    func isSent()  -> Bool
    
    func sentSansFeeFiatFmt() async throws  -> String
    
    func sentSansFeeFiatFmtCached()  -> String?
    
    func sentSansFeeFmt(unit: BitcoinUnit)  -> String?
    
    func transactionLabel()  -> String?
    
    func transactionUrl()  -> String
    
    func txId()  -> TxId
    
}
open class TransactionDetails: TransactionDetailsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_transactiondetails(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_transactiondetails(handle, $0) }
    }

    
public static func previewConfirmedReceived() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails_lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_received($0
    )
})
}
    
public static func previewConfirmedSent() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails_lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_confirmed_sent($0
    )
})
}
    
public static func previewNewConfirmed() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails_lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_new_confirmed($0
    )
})
}
    
public static func previewNewWithLabel(label: String = "bike payment") -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails_lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_new_with_label(
        FfiConverterString.lower(label),$0
    )
})
}
    
public static func previewPendingReceived() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails_lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_pending_received($0
    )
})
}
    
public static func previewPendingSent() -> TransactionDetails  {
    return try!  FfiConverterTypeTransactionDetails_lift(try! rustCall() {
    uniffi_cove_fn_constructor_transactiondetails_preview_pending_sent($0
    )
})
}
    

    
open func address() -> Address?  {
    return try!  FfiConverterOptionTypeAddress.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_address(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func addressSpacedOut() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_address_spaced_out(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amountFiat()async throws  -> Double  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_amount_fiat(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_f64,
            completeFunc: ffi_cove_rust_future_complete_f64,
            freeFunc: ffi_cove_rust_future_free_f64,
            liftFunc: FfiConverterDouble.lift,
            errorHandler: FfiConverterTypeTransactionDetailError_lift
        )
}
    
open func amountFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_amount_fiat_fmt(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError_lift
        )
}
    
open func amountFiatFmtCached() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_amount_fiat_fmt_cached(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func amountFmt(unit: BitcoinUnit) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_amount_fmt(
            self.uniffiCloneHandle(),
        FfiConverterTypeBitcoinUnit_lower(unit),$0
    )
})
}
    
open func blockNumber() -> UInt32?  {
    return try!  FfiConverterOptionUInt32.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_block_number(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func blockNumberFmt() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_block_number_fmt(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func confirmationDateTime() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_confirmation_date_time(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_fee_fiat_fmt(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError_lift
        )
}
    
open func feeFiatFmtCached() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_fee_fiat_fmt_cached(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func feeFmt(unit: BitcoinUnit) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_fee_fmt(
            self.uniffiCloneHandle(),
        FfiConverterTypeBitcoinUnit_lower(unit),$0
    )
})
}
    
    /**
     * Historical fiat value at time of transaction - async version (fetches from API if not cached)
     */
open func historicalFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_historical_fiat_fmt(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError_lift
        )
}
    
    /**
     * Historical fiat value at time of transaction - cached version (no network calls)
     */
open func historicalFiatFmtCached() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_historical_fiat_fmt_cached(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isConfirmed() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_is_confirmed(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isReceived() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_is_received(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isSent() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_is_sent(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sentSansFeeFiatFmt()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fiat_fmt(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_cove_rust_future_poll_rust_buffer,
            completeFunc: ffi_cove_rust_future_complete_rust_buffer,
            freeFunc: ffi_cove_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeTransactionDetailError_lift
        )
}
    
open func sentSansFeeFiatFmtCached() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fiat_fmt_cached(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sentSansFeeFmt(unit: BitcoinUnit) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_sent_sans_fee_fmt(
            self.uniffiCloneHandle(),
        FfiConverterTypeBitcoinUnit_lower(unit),$0
    )
})
}
    
open func transactionLabel() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_transaction_label(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func transactionUrl() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_transaction_url(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_transactiondetails_tx_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDetails: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TransactionDetails

    public static func lift(_ handle: UInt64) throws -> TransactionDetails {
        return TransactionDetails(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TransactionDetails) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetails {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TransactionDetails, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetails_lift(_ handle: UInt64) throws -> TransactionDetails {
    return try FfiConverterTypeTransactionDetails.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetails_lower(_ value: TransactionDetails) -> UInt64 {
    return FfiConverterTypeTransactionDetails.lower(value)
}






public protocol UnconfirmedTransactionProtocol: AnyObject, Sendable {
    
    func fiatAmount()  -> FiatAmount?
    
    func id()  -> TxId
    
    func label()  -> String
    
    func lastSeen()  -> UInt64
    
    func sentAndReceived()  -> SentAndReceived
    
}
open class UnconfirmedTransaction: UnconfirmedTransactionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_unconfirmedtransaction(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_unconfirmedtransaction(handle, $0) }
    }

    

    
open func fiatAmount() -> FiatAmount?  {
    return try!  FfiConverterOptionTypeFiatAmount.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_fiat_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_label(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func lastSeen() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_last_seen(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sentAndReceived() -> SentAndReceived  {
    return try!  FfiConverterTypeSentAndReceived_lift(try! rustCall() {
    uniffi_cove_fn_method_unconfirmedtransaction_sent_and_received(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnconfirmedTransaction: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UnconfirmedTransaction

    public static func lift(_ handle: UInt64) throws -> UnconfirmedTransaction {
        return UnconfirmedTransaction(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UnconfirmedTransaction) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnconfirmedTransaction {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UnconfirmedTransaction, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTransaction_lift(_ handle: UInt64) throws -> UnconfirmedTransaction {
    return try FfiConverterTypeUnconfirmedTransaction.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnconfirmedTransaction_lower(_ value: UnconfirmedTransaction) -> UInt64 {
    return FfiConverterTypeUnconfirmedTransaction.lower(value)
}






public protocol UnsignedTransactionProtocol: AnyObject, Sendable {
    
    func details()  -> ConfirmDetails
    
    func id()  -> TxId
    
    func label()  -> String
    
    func sendingAmount()  -> Amount
    
    func spendingAmount()  -> Amount
    
}
open class UnsignedTransaction: UnsignedTransactionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_unsignedtransaction(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_unsignedtransaction(handle, $0) }
    }

    
public static func previewNew() -> UnsignedTransaction  {
    return try!  FfiConverterTypeUnsignedTransaction_lift(try! rustCall() {
    uniffi_cove_fn_constructor_unsignedtransaction_preview_new($0
    )
})
}
    

    
open func details() -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_details(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func id() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func label() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_label(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func sendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_sending_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func spendingAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransaction_spending_amount(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransaction: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UnsignedTransaction

    public static func lift(_ handle: UInt64) throws -> UnsignedTransaction {
        return UnsignedTransaction(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UnsignedTransaction) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransaction {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UnsignedTransaction, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransaction_lift(_ handle: UInt64) throws -> UnsignedTransaction {
    return try FfiConverterTypeUnsignedTransaction.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransaction_lower(_ value: UnsignedTransaction) -> UInt64 {
    return FfiConverterTypeUnsignedTransaction.lower(value)
}






public protocol UnsignedTransactionRecordProtocol: AnyObject, Sendable {
    
    func confirmDetails()  -> ConfirmDetails
    
    func createdAt()  -> UInt64
    
    func txId()  -> TxId
    
    func walletId()  -> WalletId
    
}
open class UnsignedTransactionRecord: UnsignedTransactionRecordProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_unsignedtransactionrecord(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_unsignedtransactionrecord(handle, $0) }
    }

    

    
open func confirmDetails() -> ConfirmDetails  {
    return try!  FfiConverterTypeConfirmDetails_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_confirm_details(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func createdAt() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_created_at(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func txId() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_tx_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func walletId() -> WalletId  {
    return try!  FfiConverterTypeWalletId_lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionrecord_wallet_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransactionRecord: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UnsignedTransactionRecord

    public static func lift(_ handle: UInt64) throws -> UnsignedTransactionRecord {
        return UnsignedTransactionRecord(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UnsignedTransactionRecord) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransactionRecord {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UnsignedTransactionRecord, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionRecord_lift(_ handle: UInt64) throws -> UnsignedTransactionRecord {
    return try FfiConverterTypeUnsignedTransactionRecord.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionRecord_lower(_ value: UnsignedTransactionRecord) -> UInt64 {
    return FfiConverterTypeUnsignedTransactionRecord.lower(value)
}






public protocol UnsignedTransactionsTableProtocol: AnyObject, Sendable {
    
    func getTx(txId: TxId)  -> UnsignedTransactionRecord?
    
    func getTxThrow(txId: TxId) throws  -> UnsignedTransactionRecord
    
}
open class UnsignedTransactionsTable: UnsignedTransactionsTableProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_unsignedtransactionstable(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_unsignedtransactionstable(handle, $0) }
    }

    

    
open func getTx(txId: TxId) -> UnsignedTransactionRecord?  {
    return try!  FfiConverterOptionTypeUnsignedTransactionRecord.lift(try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionstable_gettx(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(txId),$0
    )
})
}
    
open func getTxThrow(txId: TxId)throws  -> UnsignedTransactionRecord  {
    return try  FfiConverterTypeUnsignedTransactionRecord_lift(try rustCallWithError(FfiConverterTypeUnsignedTransactionsTableError_lift) {
    uniffi_cove_fn_method_unsignedtransactionstable_gettxthrow(
            self.uniffiCloneHandle(),
        FfiConverterTypeTxId_lower(txId),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransactionsTable: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UnsignedTransactionsTable

    public static func lift(_ handle: UInt64) throws -> UnsignedTransactionsTable {
        return UnsignedTransactionsTable(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UnsignedTransactionsTable) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransactionsTable {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UnsignedTransactionsTable, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionsTable_lift(_ handle: UInt64) throws -> UnsignedTransactionsTable {
    return try FfiConverterTypeUnsignedTransactionsTable.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionsTable_lower(_ value: UnsignedTransactionsTable) -> UInt64 {
    return FfiConverterTypeUnsignedTransactionsTable.lower(value)
}






/**
 * Result of a completed UR decode
 */
public protocol UrResultProtocol: AnyObject, Sendable {
    
    func data()  -> Data
    
    func isHdkey()  -> Bool
    
    func isPsbt()  -> Bool
    
    func isSeed()  -> Bool
    
    func urType()  -> UrType
    
}
/**
 * Result of a completed UR decode
 */
open class UrResult: UrResultProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_urresult(self.handle, $0) }
    }
public convenience init(data: Data, urType: UrType) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_urresult_new(
        FfiConverterData.lower(data),
        FfiConverterTypeUrType_lower(urType),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_urresult(handle, $0) }
    }

    

    
open func data() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_cove_fn_method_urresult_data(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isHdkey() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_urresult_is_hdkey(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isPsbt() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_urresult_is_psbt(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isSeed() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_urresult_is_seed(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func urType() -> UrType  {
    return try!  FfiConverterTypeUrType_lift(try! rustCall() {
    uniffi_cove_fn_method_urresult_ur_type(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrResult: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UrResult

    public static func lift(_ handle: UInt64) throws -> UrResult {
        return UrResult(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UrResult) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrResult {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UrResult, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrResult_lift(_ handle: UInt64) throws -> UrResult {
    return try FfiConverterTypeUrResult.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrResult_lower(_ value: UrResult) -> UInt64 {
    return FfiConverterTypeUrResult.lower(value)
}






public protocol WalletProtocol: AnyObject, Sendable {
    
    func id()  -> WalletId
    
}
open class Wallet: WalletProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_wallet(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_wallet(handle, $0) }
    }

    
public static func newFromExport(export: HardwareExport)throws  -> Wallet  {
    return try  FfiConverterTypeWallet_lift(try rustCallWithError(FfiConverterTypeWalletError_lift) {
    uniffi_cove_fn_constructor_wallet_new_from_export(
        FfiConverterTypeHardwareExport_lower(export),$0
    )
})
}
    
public static func newFromXpub(xpub: String)throws  -> Wallet  {
    return try  FfiConverterTypeWallet_lift(try rustCallWithError(FfiConverterTypeWalletError_lift) {
    uniffi_cove_fn_constructor_wallet_new_from_xpub(
        FfiConverterString.lower(xpub),$0
    )
})
}
    
public static func previewNewWallet() -> Wallet  {
    return try!  FfiConverterTypeWallet_lift(try! rustCall() {
    uniffi_cove_fn_constructor_wallet_previewnewwallet($0
    )
})
}
    

    
open func id() -> WalletId  {
    return try!  FfiConverterTypeWalletId_lift(try! rustCall() {
    uniffi_cove_fn_method_wallet_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Wallet

    public static func lift(_ handle: UInt64) throws -> Wallet {
        return Wallet(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Wallet) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lift(_ handle: UInt64) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UInt64 {
    return FfiConverterTypeWallet.lower(value)
}






public protocol WalletDataDbProtocol: AnyObject, Sendable {
    
}
open class WalletDataDb: WalletDataDbProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_walletdatadb(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletdatadb(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletDataDb: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WalletDataDb

    public static func lift(_ handle: UInt64) throws -> WalletDataDb {
        return WalletDataDb(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WalletDataDb) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletDataDb {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WalletDataDb, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataDb_lift(_ handle: UInt64) throws -> WalletDataDb {
    return try FfiConverterTypeWalletDataDb.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataDb_lower(_ value: WalletDataDb) -> UInt64 {
    return FfiConverterTypeWalletDataDb.lower(value)
}






public protocol WalletKeyProtocol: AnyObject, Sendable {
    
}
open class WalletKey: WalletKeyProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_walletkey(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletkey(handle, $0) }
    }

    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletKey: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WalletKey

    public static func lift(_ handle: UInt64) throws -> WalletKey {
        return WalletKey(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WalletKey) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletKey {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WalletKey, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletKey_lift(_ handle: UInt64) throws -> WalletKey {
    return try FfiConverterTypeWalletKey.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletKey_lower(_ value: WalletKey) -> UInt64 {
    return FfiConverterTypeWalletKey.lower(value)
}






public protocol WalletsTableProtocol: AnyObject, Sendable {
    
    func all() throws  -> [WalletMetadata]
    
    func allSortedActive() throws  -> [WalletMetadata]
    
    func isEmpty() throws  -> Bool
    
    func len(network: Network, mode: WalletMode) throws  -> UInt16
    
}
open class WalletsTable: WalletsTableProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_walletstable(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_walletstable(handle, $0) }
    }

    

    
open func all()throws  -> [WalletMetadata]  {
    return try  FfiConverterSequenceTypeWalletMetadata.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_walletstable_all(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func allSortedActive()throws  -> [WalletMetadata]  {
    return try  FfiConverterSequenceTypeWalletMetadata.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_walletstable_all_sorted_active(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isEmpty()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_walletstable_is_empty(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func len(network: Network, mode: WalletMode)throws  -> UInt16  {
    return try  FfiConverterUInt16.lift(try rustCallWithError(FfiConverterTypeDatabaseError_lift) {
    uniffi_cove_fn_method_walletstable_len(
            self.uniffiCloneHandle(),
        FfiConverterTypeNetwork_lower(network),
        FfiConverterTypeWalletMode_lower(mode),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletsTable: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WalletsTable

    public static func lift(_ handle: UInt64) throws -> WalletsTable {
        return WalletsTable(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WalletsTable) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletsTable {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WalletsTable, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletsTable_lift(_ handle: UInt64) throws -> WalletsTable {
    return try FfiConverterTypeWalletsTable.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletsTable_lower(_ value: WalletsTable) -> UInt64 {
    return FfiConverterTypeWalletsTable.lower(value)
}






public protocol WordValidatorProtocol: AnyObject, Sendable {
    
    func isComplete(wordNumber: UInt8)  -> Bool
    
    func isWordCorrect(word: String, `for`: UInt8)  -> Bool
    
    func possibleWords(`for`: UInt8)  -> [String]
    
}
open class WordValidator: WordValidatorProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_wordvalidator(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_wordvalidator(handle, $0) }
    }

    
public static func preview(preview: Bool, numberOfWords: NumberOfBip39Words? = nil) -> WordValidator  {
    return try!  FfiConverterTypeWordValidator_lift(try! rustCall() {
    uniffi_cove_fn_constructor_wordvalidator_preview(
        FfiConverterBool.lower(preview),
        FfiConverterOptionTypeNumberOfBip39Words.lower(numberOfWords),$0
    )
})
}
    

    
open func isComplete(wordNumber: UInt8) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_wordvalidator_is_complete(
            self.uniffiCloneHandle(),
        FfiConverterUInt8.lower(wordNumber),$0
    )
})
}
    
open func isWordCorrect(word: String, `for`: UInt8) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_wordvalidator_is_word_correct(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),
        FfiConverterUInt8.lower(`for`),$0
    )
})
}
    
open func possibleWords(`for`: UInt8) -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_wordvalidator_possible_words(
            self.uniffiCloneHandle(),
        FfiConverterUInt8.lower(`for`),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordValidator: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WordValidator

    public static func lift(_ handle: UInt64) throws -> WordValidator {
        return WordValidator(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WordValidator) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordValidator {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WordValidator, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordValidator_lift(_ handle: UInt64) throws -> WordValidator {
    return try FfiConverterTypeWordValidator.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordValidator_lower(_ value: WordValidator) -> UInt64 {
    return FfiConverterTypeWordValidator.lower(value)
}






/**
 * State machine for word verification flow
 *
 * UI sends events (select_word, animation_complete, etc.) and receives
 * StateTransition results that tell it what state to render and what
 * animations to play.
 */
public protocol WordVerifyStateMachineProtocol: AnyObject, Sendable {
    
    /**
     * Animation to target complete - transition to Correct or Incorrect
     *
     * Returns a transition with the result state and dwell duration.
     */
    func animationComplete()  -> StateTransition
    
    /**
     * Get the animation configuration
     */
    func config()  -> WordVerifyAnimationConfig
    
    /**
     * Dwell time complete - advance word or start return animation
     *
     * If correct: transitions to None and signals to advance word.
     * If incorrect: transitions to Returning state.
     */
    func dwellComplete()  -> StateTransition
    
    /**
     * Check if all words have been verified
     */
    func isComplete()  -> Bool
    
    /**
     * Get possible words for the current word number
     */
    func possibleWords()  -> [String]
    
    /**
     * Reset to a specific word number (useful for going back)
     */
    func resetToWord(wordNumber: UInt8) 
    
    /**
     * Return animation complete (after incorrect) - back to None
     */
    func returnComplete()  -> StateTransition
    
    /**
     * User tapped a word - start the checking animation
     *
     * Returns a transition with Checking state and the animation duration.
     * If already animating, returns no-change.
     */
    func selectWord(word: String)  -> StateTransition
    
    /**
     * Get the current state
     */
    func state()  -> WordCheckState
    
    /**
     * Get the current word number being verified (1-indexed)
     */
    func wordNumber()  -> UInt8
    
}
/**
 * State machine for word verification flow
 *
 * UI sends events (select_word, animation_complete, etc.) and receives
 * StateTransition results that tell it what state to render and what
 * animations to play.
 */
open class WordVerifyStateMachine: WordVerifyStateMachineProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_cove_fn_clone_wordverifystatemachine(self.handle, $0) }
    }
    /**
     * Create a new state machine with the given validator
     */
public convenience init(validator: WordValidator, startingWordNumber: UInt8) {
    let handle =
        try! rustCall() {
    uniffi_cove_fn_constructor_wordverifystatemachine_new(
        FfiConverterTypeWordValidator_lower(validator),
        FfiConverterUInt8.lower(startingWordNumber),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_cove_fn_free_wordverifystatemachine(handle, $0) }
    }

    

    
    /**
     * Animation to target complete - transition to Correct or Incorrect
     *
     * Returns a transition with the result state and dwell duration.
     */
open func animationComplete() -> StateTransition  {
    return try!  FfiConverterTypeStateTransition_lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_animation_complete(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the animation configuration
     */
open func config() -> WordVerifyAnimationConfig  {
    return try!  FfiConverterTypeWordVerifyAnimationConfig_lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_config(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Dwell time complete - advance word or start return animation
     *
     * If correct: transitions to None and signals to advance word.
     * If incorrect: transitions to Returning state.
     */
open func dwellComplete() -> StateTransition  {
    return try!  FfiConverterTypeStateTransition_lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_dwell_complete(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Check if all words have been verified
     */
open func isComplete() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_is_complete(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get possible words for the current word number
     */
open func possibleWords() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_possible_words(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Reset to a specific word number (useful for going back)
     */
open func resetToWord(wordNumber: UInt8)  {try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_reset_to_word(
            self.uniffiCloneHandle(),
        FfiConverterUInt8.lower(wordNumber),$0
    )
}
}
    
    /**
     * Return animation complete (after incorrect) - back to None
     */
open func returnComplete() -> StateTransition  {
    return try!  FfiConverterTypeStateTransition_lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_return_complete(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * User tapped a word - start the checking animation
     *
     * Returns a transition with Checking state and the animation duration.
     * If already animating, returns no-change.
     */
open func selectWord(word: String) -> StateTransition  {
    return try!  FfiConverterTypeStateTransition_lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_select_word(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(word),$0
    )
})
}
    
    /**
     * Get the current state
     */
open func state() -> WordCheckState  {
    return try!  FfiConverterTypeWordCheckState_lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the current word number being verified (1-indexed)
     */
open func wordNumber() -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_method_wordverifystatemachine_word_number(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordVerifyStateMachine: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WordVerifyStateMachine

    public static func lift(_ handle: UInt64) throws -> WordVerifyStateMachine {
        return WordVerifyStateMachine(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WordVerifyStateMachine) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordVerifyStateMachine {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WordVerifyStateMachine, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordVerifyStateMachine_lift(_ handle: UInt64) throws -> WordVerifyStateMachine {
    return try FfiConverterTypeWordVerifyStateMachine.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordVerifyStateMachine_lower(_ value: WordVerifyStateMachine) -> UInt64 {
    return FfiConverterTypeWordVerifyStateMachine.lower(value)
}




public struct AppState {
    public var router: Router

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(router: Router) {
        self.router = router
    }

    

    
}

#if compiler(>=6)
extension AppState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppState {
        return
            try AppState(
                router: FfiConverterTypeRouter.read(from: &buf)
        )
    }

    public static func write(_ value: AppState, into buf: inout [UInt8]) {
        FfiConverterTypeRouter.write(value.router, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppState_lift(_ buf: RustBuffer) throws -> AppState {
    return try FfiConverterTypeAppState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppState_lower(_ value: AppState) -> RustBuffer {
    return FfiConverterTypeAppState.lower(value)
}


public struct AuthManagerState: Equatable, Hashable {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }

    

    
}

#if compiler(>=6)
extension AuthManagerState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthManagerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthManagerState {
        return
            AuthManagerState()
    }

    public static func write(_ value: AuthManagerState, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerState_lift(_ buf: RustBuffer) throws -> AuthManagerState {
    return try FfiConverterTypeAuthManagerState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerState_lower(_ value: AuthManagerState) -> RustBuffer {
    return FfiConverterTypeAuthManagerState.lower(value)
}


public struct ConfirmedDetails: Equatable, Hashable {
    public var blockNumber: UInt32
    public var confirmationTime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockNumber: UInt32, confirmationTime: UInt64) {
        self.blockNumber = blockNumber
        self.confirmationTime = confirmationTime
    }

    

    
}

#if compiler(>=6)
extension ConfirmedDetails: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmedDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmedDetails {
        return
            try ConfirmedDetails(
                blockNumber: FfiConverterUInt32.read(from: &buf), 
                confirmationTime: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmedDetails, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.blockNumber, into: &buf)
        FfiConverterUInt64.write(value.confirmationTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedDetails_lift(_ buf: RustBuffer) throws -> ConfirmedDetails {
    return try FfiConverterTypeConfirmedDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmedDetails_lower(_ value: ConfirmedDetails) -> RustBuffer {
    return FfiConverterTypeConfirmedDetails.lower(value)
}


public struct ContinueFromBackup {
    public var backup: Data
    public var continueCmd: SetupCmd
    public var error: TapSignerReaderError

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backup: Data, continueCmd: SetupCmd, error: TapSignerReaderError) {
        self.backup = backup
        self.continueCmd = continueCmd
        self.error = error
    }

    

    
}

#if compiler(>=6)
extension ContinueFromBackup: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContinueFromBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContinueFromBackup {
        return
            try ContinueFromBackup(
                backup: FfiConverterData.read(from: &buf), 
                continueCmd: FfiConverterTypeSetupCmd.read(from: &buf), 
                error: FfiConverterTypeTapSignerReaderError.read(from: &buf)
        )
    }

    public static func write(_ value: ContinueFromBackup, into buf: inout [UInt8]) {
        FfiConverterData.write(value.backup, into: &buf)
        FfiConverterTypeSetupCmd.write(value.continueCmd, into: &buf)
        FfiConverterTypeTapSignerReaderError.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContinueFromBackup_lift(_ buf: RustBuffer) throws -> ContinueFromBackup {
    return try FfiConverterTypeContinueFromBackup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContinueFromBackup_lower(_ value: ContinueFromBackup) -> RustBuffer {
    return FfiConverterTypeContinueFromBackup.lower(value)
}


public struct ContinueFromDerive {
    public var backup: Data
    public var deriveInfo: DeriveInfo
    public var continueCmd: SetupCmd
    public var error: TapSignerReaderError

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backup: Data, deriveInfo: DeriveInfo, continueCmd: SetupCmd, error: TapSignerReaderError) {
        self.backup = backup
        self.deriveInfo = deriveInfo
        self.continueCmd = continueCmd
        self.error = error
    }

    

    
}

#if compiler(>=6)
extension ContinueFromDerive: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContinueFromDerive: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContinueFromDerive {
        return
            try ContinueFromDerive(
                backup: FfiConverterData.read(from: &buf), 
                deriveInfo: FfiConverterTypeDeriveInfo.read(from: &buf), 
                continueCmd: FfiConverterTypeSetupCmd.read(from: &buf), 
                error: FfiConverterTypeTapSignerReaderError.read(from: &buf)
        )
    }

    public static func write(_ value: ContinueFromDerive, into buf: inout [UInt8]) {
        FfiConverterData.write(value.backup, into: &buf)
        FfiConverterTypeDeriveInfo.write(value.deriveInfo, into: &buf)
        FfiConverterTypeSetupCmd.write(value.continueCmd, into: &buf)
        FfiConverterTypeTapSignerReaderError.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContinueFromDerive_lift(_ buf: RustBuffer) throws -> ContinueFromDerive {
    return try FfiConverterTypeContinueFromDerive.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContinueFromDerive_lower(_ value: ContinueFromDerive) -> RustBuffer {
    return FfiConverterTypeContinueFromDerive.lower(value)
}


public struct ContinueFromInit {
    public var continueCmd: SetupCmd
    public var error: TapSignerReaderError

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(continueCmd: SetupCmd, error: TapSignerReaderError) {
        self.continueCmd = continueCmd
        self.error = error
    }

    

    
}

#if compiler(>=6)
extension ContinueFromInit: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContinueFromInit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContinueFromInit {
        return
            try ContinueFromInit(
                continueCmd: FfiConverterTypeSetupCmd.read(from: &buf), 
                error: FfiConverterTypeTapSignerReaderError.read(from: &buf)
        )
    }

    public static func write(_ value: ContinueFromInit, into buf: inout [UInt8]) {
        FfiConverterTypeSetupCmd.write(value.continueCmd, into: &buf)
        FfiConverterTypeTapSignerReaderError.write(value.error, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContinueFromInit_lift(_ buf: RustBuffer) throws -> ContinueFromInit {
    return try FfiConverterTypeContinueFromInit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContinueFromInit_lower(_ value: ContinueFromInit) -> RustBuffer {
    return FfiConverterTypeContinueFromInit.lower(value)
}


public struct DeriveInfo: Equatable, Hashable {
    public var masterPubkey: Data
    public var pubkey: Data
    public var chainCode: Data
    public var path: [UInt32]
    public var network: Network

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterPubkey: Data, pubkey: Data, chainCode: Data, path: [UInt32], network: Network) {
        self.masterPubkey = masterPubkey
        self.pubkey = pubkey
        self.chainCode = chainCode
        self.path = path
        self.network = network
    }

    

    
}

#if compiler(>=6)
extension DeriveInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeriveInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeriveInfo {
        return
            try DeriveInfo(
                masterPubkey: FfiConverterData.read(from: &buf), 
                pubkey: FfiConverterData.read(from: &buf), 
                chainCode: FfiConverterData.read(from: &buf), 
                path: FfiConverterSequenceUInt32.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf)
        )
    }

    public static func write(_ value: DeriveInfo, into buf: inout [UInt8]) {
        FfiConverterData.write(value.masterPubkey, into: &buf)
        FfiConverterData.write(value.pubkey, into: &buf)
        FfiConverterData.write(value.chainCode, into: &buf)
        FfiConverterSequenceUInt32.write(value.path, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeriveInfo_lift(_ buf: RustBuffer) throws -> DeriveInfo {
    return try FfiConverterTypeDeriveInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeriveInfo_lower(_ value: DeriveInfo) -> RustBuffer {
    return FfiConverterTypeDeriveInfo.lower(value)
}


public struct FeeResponse: Equatable, Hashable {
    public var fastestFee: Float
    public var halfHourFee: Float
    public var hourFee: Float
    public var economyFee: Float
    public var minimumFee: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fastestFee: Float, halfHourFee: Float, hourFee: Float, economyFee: Float, minimumFee: Float) {
        self.fastestFee = fastestFee
        self.halfHourFee = halfHourFee
        self.hourFee = hourFee
        self.economyFee = economyFee
        self.minimumFee = minimumFee
    }

    

    
}

#if compiler(>=6)
extension FeeResponse: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeResponse {
        return
            try FeeResponse(
                fastestFee: FfiConverterFloat.read(from: &buf), 
                halfHourFee: FfiConverterFloat.read(from: &buf), 
                hourFee: FfiConverterFloat.read(from: &buf), 
                economyFee: FfiConverterFloat.read(from: &buf), 
                minimumFee: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: FeeResponse, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.fastestFee, into: &buf)
        FfiConverterFloat.write(value.halfHourFee, into: &buf)
        FfiConverterFloat.write(value.hourFee, into: &buf)
        FfiConverterFloat.write(value.economyFee, into: &buf)
        FfiConverterFloat.write(value.minimumFee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeResponse_lift(_ buf: RustBuffer) throws -> FeeResponse {
    return try FfiConverterTypeFeeResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeResponse_lower(_ value: FeeResponse) -> RustBuffer {
    return FfiConverterTypeFeeResponse.lower(value)
}


public struct FiatAmount: Equatable, Hashable {
    public var amount: Double
    public var currency: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Double, currency: FiatCurrency) {
        self.amount = amount
        self.currency = currency
    }

    

    
}

#if compiler(>=6)
extension FiatAmount: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatAmount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatAmount {
        return
            try FiatAmount(
                amount: FfiConverterDouble.read(from: &buf), 
                currency: FfiConverterTypeFiatCurrency.read(from: &buf)
        )
    }

    public static func write(_ value: FiatAmount, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.amount, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.currency, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatAmount_lift(_ buf: RustBuffer) throws -> FiatAmount {
    return try FfiConverterTypeFiatAmount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatAmount_lower(_ value: FiatAmount) -> RustBuffer {
    return FfiConverterTypeFiatAmount.lower(value)
}


public struct FoundAddress: Equatable, Hashable {
    public var type: WalletAddressType
    public var firstAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: WalletAddressType, firstAddress: String) {
        self.type = type
        self.firstAddress = firstAddress
    }

    

    
}

#if compiler(>=6)
extension FoundAddress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFoundAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FoundAddress {
        return
            try FoundAddress(
                type: FfiConverterTypeWalletAddressType.read(from: &buf), 
                firstAddress: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FoundAddress, into buf: inout [UInt8]) {
        FfiConverterTypeWalletAddressType.write(value.type, into: &buf)
        FfiConverterString.write(value.firstAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundAddress_lift(_ buf: RustBuffer) throws -> FoundAddress {
    return try FfiConverterTypeFoundAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFoundAddress_lower(_ value: FoundAddress) -> RustBuffer {
    return FfiConverterTypeFoundAddress.lower(value)
}


public struct GroupedWord: Equatable, Hashable {
    public var number: UInt8
    public var word: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: UInt8, word: String) {
        self.number = number
        self.word = word
    }

    

    
}

#if compiler(>=6)
extension GroupedWord: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupedWord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupedWord {
        return
            try GroupedWord(
                number: FfiConverterUInt8.read(from: &buf), 
                word: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GroupedWord, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.number, into: &buf)
        FfiConverterString.write(value.word, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupedWord_lift(_ buf: RustBuffer) throws -> GroupedWord {
    return try FfiConverterTypeGroupedWord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupedWord_lower(_ value: GroupedWord) -> RustBuffer {
    return FfiConverterTypeGroupedWord.lower(value)
}


/**
 * A space-efficient version of `HistoricalPrice` where only USD is required
 * and other currencies are optional to save space when they aren't available
 */
public struct HistoricalPriceRecord: Equatable, Hashable {
    public var time: UInt64
    public var usd: Float
    public var eur: Float?
    public var gbp: Float?
    public var cad: Float?
    public var chf: Float?
    public var aud: Float?
    public var jpy: Float?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(time: UInt64, usd: Float, eur: Float?, gbp: Float?, cad: Float?, chf: Float?, aud: Float?, jpy: Float?) {
        self.time = time
        self.usd = usd
        self.eur = eur
        self.gbp = gbp
        self.cad = cad
        self.chf = chf
        self.aud = aud
        self.jpy = jpy
    }

    

    
}

#if compiler(>=6)
extension HistoricalPriceRecord: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHistoricalPriceRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoricalPriceRecord {
        return
            try HistoricalPriceRecord(
                time: FfiConverterUInt64.read(from: &buf), 
                usd: FfiConverterFloat.read(from: &buf), 
                eur: FfiConverterOptionFloat.read(from: &buf), 
                gbp: FfiConverterOptionFloat.read(from: &buf), 
                cad: FfiConverterOptionFloat.read(from: &buf), 
                chf: FfiConverterOptionFloat.read(from: &buf), 
                aud: FfiConverterOptionFloat.read(from: &buf), 
                jpy: FfiConverterOptionFloat.read(from: &buf)
        )
    }

    public static func write(_ value: HistoricalPriceRecord, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.time, into: &buf)
        FfiConverterFloat.write(value.usd, into: &buf)
        FfiConverterOptionFloat.write(value.eur, into: &buf)
        FfiConverterOptionFloat.write(value.gbp, into: &buf)
        FfiConverterOptionFloat.write(value.cad, into: &buf)
        FfiConverterOptionFloat.write(value.chf, into: &buf)
        FfiConverterOptionFloat.write(value.aud, into: &buf)
        FfiConverterOptionFloat.write(value.jpy, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceRecord_lift(_ buf: RustBuffer) throws -> HistoricalPriceRecord {
    return try FfiConverterTypeHistoricalPriceRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceRecord_lower(_ value: HistoricalPriceRecord) -> RustBuffer {
    return FfiConverterTypeHistoricalPriceRecord.lower(value)
}


public struct ImportWalletManagerState: Equatable, Hashable {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }

    

    
}

#if compiler(>=6)
extension ImportWalletManagerState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletManagerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletManagerState {
        return
            ImportWalletManagerState()
    }

    public static func write(_ value: ImportWalletManagerState, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerState_lift(_ buf: RustBuffer) throws -> ImportWalletManagerState {
    return try FfiConverterTypeImportWalletManagerState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerState_lower(_ value: ImportWalletManagerState) -> RustBuffer {
    return FfiConverterTypeImportWalletManagerState.lower(value)
}


public struct InternalOnlyMetadata: Equatable, Hashable {
    public var addressIndex: AddressIndex?
    /**
     * this is the last time the wallet was scanned, this includes the initial scna, expanded scan, and incremental scan
     */
    public var lastScanFinished: TimeInterval?
    public var lastHeightFetched: BlockSizeLast?
    /**
     * this is the time that a full expanded scan was completed, this should only happen once
     */
    public var performedFullScanAt: UInt64?
    public var storeType: StoreType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressIndex: AddressIndex?, 
        /**
         * this is the last time the wallet was scanned, this includes the initial scna, expanded scan, and incremental scan
         */lastScanFinished: TimeInterval?, lastHeightFetched: BlockSizeLast?, 
        /**
         * this is the time that a full expanded scan was completed, this should only happen once
         */performedFullScanAt: UInt64?, storeType: StoreType) {
        self.addressIndex = addressIndex
        self.lastScanFinished = lastScanFinished
        self.lastHeightFetched = lastHeightFetched
        self.performedFullScanAt = performedFullScanAt
        self.storeType = storeType
    }

    

    
}

#if compiler(>=6)
extension InternalOnlyMetadata: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInternalOnlyMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InternalOnlyMetadata {
        return
            try InternalOnlyMetadata(
                addressIndex: FfiConverterOptionTypeAddressIndex.read(from: &buf), 
                lastScanFinished: FfiConverterOptionDuration.read(from: &buf), 
                lastHeightFetched: FfiConverterOptionTypeBlockSizeLast.read(from: &buf), 
                performedFullScanAt: FfiConverterOptionUInt64.read(from: &buf), 
                storeType: FfiConverterTypeStoreType.read(from: &buf)
        )
    }

    public static func write(_ value: InternalOnlyMetadata, into buf: inout [UInt8]) {
        FfiConverterOptionTypeAddressIndex.write(value.addressIndex, into: &buf)
        FfiConverterOptionDuration.write(value.lastScanFinished, into: &buf)
        FfiConverterOptionTypeBlockSizeLast.write(value.lastHeightFetched, into: &buf)
        FfiConverterOptionUInt64.write(value.performedFullScanAt, into: &buf)
        FfiConverterTypeStoreType.write(value.storeType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInternalOnlyMetadata_lift(_ buf: RustBuffer) throws -> InternalOnlyMetadata {
    return try FfiConverterTypeInternalOnlyMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInternalOnlyMetadata_lower(_ value: InternalOnlyMetadata) -> RustBuffer {
    return FfiConverterTypeInternalOnlyMetadata.lower(value)
}


public struct LabelExportResult: Equatable, Hashable {
    public var content: String
    public var filename: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(content: String, filename: String) {
        self.content = content
        self.filename = filename
    }

    

    
}

#if compiler(>=6)
extension LabelExportResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabelExportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelExportResult {
        return
            try LabelExportResult(
                content: FfiConverterString.read(from: &buf), 
                filename: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LabelExportResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterString.write(value.filename, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelExportResult_lift(_ buf: RustBuffer) throws -> LabelExportResult {
    return try FfiConverterTypeLabelExportResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelExportResult_lower(_ value: LabelExportResult) -> RustBuffer {
    return FfiConverterTypeLabelExportResult.lower(value)
}


public struct Node: Equatable, Hashable {
    public var name: String
    public var network: Network
    public var apiType: ApiType
    public var url: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, network: Network, apiType: ApiType, url: String) {
        self.name = name
        self.network = network
        self.apiType = apiType
        self.url = url
    }

    

    
}

#if compiler(>=6)
extension Node: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        return
            try Node(
                name: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                apiType: FfiConverterTypeApiType.read(from: &buf), 
                url: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterTypeApiType.write(value.apiType, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lift(_ buf: RustBuffer) throws -> Node {
    return try FfiConverterTypeNode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lower(_ value: Node) -> RustBuffer {
    return FfiConverterTypeNode.lower(value)
}


public struct PendingDetails: Equatable, Hashable {
    public var lastSeen: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastSeen: UInt64) {
        self.lastSeen = lastSeen
    }

    

    
}

#if compiler(>=6)
extension PendingDetails: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingDetails {
        return
            try PendingDetails(
                lastSeen: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PendingDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.lastSeen, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingDetails_lift(_ buf: RustBuffer) throws -> PendingDetails {
    return try FfiConverterTypePendingDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingDetails_lower(_ value: PendingDetails) -> RustBuffer {
    return FfiConverterTypePendingDetails.lower(value)
}


public struct PendingWalletManagerState {
    public var numberOfWords: NumberOfBip39Words
    public var wallet: PendingWallet

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfWords: NumberOfBip39Words, wallet: PendingWallet) {
        self.numberOfWords = numberOfWords
        self.wallet = wallet
    }

    

    
}

#if compiler(>=6)
extension PendingWalletManagerState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerState {
        return
            try PendingWalletManagerState(
                numberOfWords: FfiConverterTypeNumberOfBip39Words.read(from: &buf), 
                wallet: FfiConverterTypePendingWallet.read(from: &buf)
        )
    }

    public static func write(_ value: PendingWalletManagerState, into buf: inout [UInt8]) {
        FfiConverterTypeNumberOfBip39Words.write(value.numberOfWords, into: &buf)
        FfiConverterTypePendingWallet.write(value.wallet, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerState_lift(_ buf: RustBuffer) throws -> PendingWalletManagerState {
    return try FfiConverterTypePendingWalletManagerState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerState_lower(_ value: PendingWalletManagerState) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerState.lower(value)
}


public struct Router {
    public var app: FfiApp
    public var `default`: Route
    public var routes: [Route]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(app: FfiApp, `default`: Route, routes: [Route]) {
        self.app = app
        self.`default` = `default`
        self.routes = routes
    }

    

    
}

#if compiler(>=6)
extension Router: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRouter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Router {
        return
            try Router(
                app: FfiConverterTypeFfiApp.read(from: &buf), 
                default: FfiConverterTypeRoute.read(from: &buf), 
                routes: FfiConverterSequenceTypeRoute.read(from: &buf)
        )
    }

    public static func write(_ value: Router, into buf: inout [UInt8]) {
        FfiConverterTypeFfiApp.write(value.app, into: &buf)
        FfiConverterTypeRoute.write(value.`default`, into: &buf)
        FfiConverterSequenceTypeRoute.write(value.routes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouter_lift(_ buf: RustBuffer) throws -> Router {
    return try FfiConverterTypeRouter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRouter_lower(_ value: Router) -> RustBuffer {
    return FfiConverterTypeRouter.lower(value)
}


public struct ScanningInfo: Equatable, Hashable {
    public var addressType: WalletAddressType
    public var count: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressType: WalletAddressType, count: UInt32) {
        self.addressType = addressType
        self.count = count
    }

    

    
}

#if compiler(>=6)
extension ScanningInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanningInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanningInfo {
        return
            try ScanningInfo(
                addressType: FfiConverterTypeWalletAddressType.read(from: &buf), 
                count: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ScanningInfo, into buf: inout [UInt8]) {
        FfiConverterTypeWalletAddressType.write(value.addressType, into: &buf)
        FfiConverterUInt32.write(value.count, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanningInfo_lift(_ buf: RustBuffer) throws -> ScanningInfo {
    return try FfiConverterTypeScanningInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanningInfo_lower(_ value: ScanningInfo) -> RustBuffer {
    return FfiConverterTypeScanningInfo.lower(value)
}


public struct SendFlowCoinControlMode {
    public var utxoList: UtxoList
    public var isMaxSelected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(utxoList: UtxoList, isMaxSelected: Bool) {
        self.utxoList = utxoList
        self.isMaxSelected = isMaxSelected
    }

    

    
}

#if compiler(>=6)
extension SendFlowCoinControlMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowCoinControlMode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowCoinControlMode {
        return
            try SendFlowCoinControlMode(
                utxoList: FfiConverterTypeUtxoList.read(from: &buf), 
                isMaxSelected: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SendFlowCoinControlMode, into buf: inout [UInt8]) {
        FfiConverterTypeUtxoList.write(value.utxoList, into: &buf)
        FfiConverterBool.write(value.isMaxSelected, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowCoinControlMode_lift(_ buf: RustBuffer) throws -> SendFlowCoinControlMode {
    return try FfiConverterTypeSendFlowCoinControlMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowCoinControlMode_lower(_ value: SendFlowCoinControlMode) -> RustBuffer {
    return FfiConverterTypeSendFlowCoinControlMode.lower(value)
}


public struct SendRouteConfirmArgs {
    public var id: WalletId
    public var details: ConfirmDetails
    public var signedTransaction: BitcoinTransaction?
    public var signedPsbt: Psbt?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: WalletId, details: ConfirmDetails, signedTransaction: BitcoinTransaction?, signedPsbt: Psbt?) {
        self.id = id
        self.details = details
        self.signedTransaction = signedTransaction
        self.signedPsbt = signedPsbt
    }

    

    
}

#if compiler(>=6)
extension SendRouteConfirmArgs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendRouteConfirmArgs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendRouteConfirmArgs {
        return
            try SendRouteConfirmArgs(
                id: FfiConverterTypeWalletId.read(from: &buf), 
                details: FfiConverterTypeConfirmDetails.read(from: &buf), 
                signedTransaction: FfiConverterOptionTypeBitcoinTransaction.read(from: &buf), 
                signedPsbt: FfiConverterOptionTypePsbt.read(from: &buf)
        )
    }

    public static func write(_ value: SendRouteConfirmArgs, into buf: inout [UInt8]) {
        FfiConverterTypeWalletId.write(value.id, into: &buf)
        FfiConverterTypeConfirmDetails.write(value.details, into: &buf)
        FfiConverterOptionTypeBitcoinTransaction.write(value.signedTransaction, into: &buf)
        FfiConverterOptionTypePsbt.write(value.signedPsbt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendRouteConfirmArgs_lift(_ buf: RustBuffer) throws -> SendRouteConfirmArgs {
    return try FfiConverterTypeSendRouteConfirmArgs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendRouteConfirmArgs_lower(_ value: SendRouteConfirmArgs) -> RustBuffer {
    return FfiConverterTypeSendRouteConfirmArgs.lower(value)
}


/**
 * Result of a state transition
 */
public struct StateTransition: Equatable, Hashable {
    /**
     * The new state after the transition
     */
    public var newState: WordCheckState
    /**
     * Whether the UI should advance to the next word
     */
    public var shouldAdvanceWord: Bool
    /**
     * Suggested animation/delay duration in ms (None if no animation needed)
     */
    public var animationDurationMs: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The new state after the transition
         */newState: WordCheckState, 
        /**
         * Whether the UI should advance to the next word
         */shouldAdvanceWord: Bool, 
        /**
         * Suggested animation/delay duration in ms (None if no animation needed)
         */animationDurationMs: UInt32?) {
        self.newState = newState
        self.shouldAdvanceWord = shouldAdvanceWord
        self.animationDurationMs = animationDurationMs
    }

    

    
}

#if compiler(>=6)
extension StateTransition: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStateTransition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateTransition {
        return
            try StateTransition(
                newState: FfiConverterTypeWordCheckState.read(from: &buf), 
                shouldAdvanceWord: FfiConverterBool.read(from: &buf), 
                animationDurationMs: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: StateTransition, into buf: inout [UInt8]) {
        FfiConverterTypeWordCheckState.write(value.newState, into: &buf)
        FfiConverterBool.write(value.shouldAdvanceWord, into: &buf)
        FfiConverterOptionUInt32.write(value.animationDurationMs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStateTransition_lift(_ buf: RustBuffer) throws -> StateTransition {
    return try FfiConverterTypeStateTransition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStateTransition_lower(_ value: StateTransition) -> RustBuffer {
    return FfiConverterTypeStateTransition.lower(value)
}


public struct TapSignerConfirmPinArgs {
    public var tapSigner: TapSigner
    public var startingPin: String
    public var newPin: String
    public var chainCode: String?
    public var action: TapSignerPinAction

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tapSigner: TapSigner, startingPin: String, newPin: String, chainCode: String?, action: TapSignerPinAction) {
        self.tapSigner = tapSigner
        self.startingPin = startingPin
        self.newPin = newPin
        self.chainCode = chainCode
        self.action = action
    }

    

    
}

#if compiler(>=6)
extension TapSignerConfirmPinArgs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerConfirmPinArgs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerConfirmPinArgs {
        return
            try TapSignerConfirmPinArgs(
                tapSigner: FfiConverterTypeTapSigner.read(from: &buf), 
                startingPin: FfiConverterString.read(from: &buf), 
                newPin: FfiConverterString.read(from: &buf), 
                chainCode: FfiConverterOptionString.read(from: &buf), 
                action: FfiConverterTypeTapSignerPinAction.read(from: &buf)
        )
    }

    public static func write(_ value: TapSignerConfirmPinArgs, into buf: inout [UInt8]) {
        FfiConverterTypeTapSigner.write(value.tapSigner, into: &buf)
        FfiConverterString.write(value.startingPin, into: &buf)
        FfiConverterString.write(value.newPin, into: &buf)
        FfiConverterOptionString.write(value.chainCode, into: &buf)
        FfiConverterTypeTapSignerPinAction.write(value.action, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerConfirmPinArgs_lift(_ buf: RustBuffer) throws -> TapSignerConfirmPinArgs {
    return try FfiConverterTypeTapSignerConfirmPinArgs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerConfirmPinArgs_lower(_ value: TapSignerConfirmPinArgs) -> RustBuffer {
    return FfiConverterTypeTapSignerConfirmPinArgs.lower(value)
}


public struct TapSignerNewPinArgs {
    public var tapSigner: TapSigner
    public var startingPin: String
    public var chainCode: String?
    public var action: TapSignerPinAction

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(tapSigner: TapSigner, startingPin: String, chainCode: String?, action: TapSignerPinAction) {
        self.tapSigner = tapSigner
        self.startingPin = startingPin
        self.chainCode = chainCode
        self.action = action
    }

    

    
}

#if compiler(>=6)
extension TapSignerNewPinArgs: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerNewPinArgs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerNewPinArgs {
        return
            try TapSignerNewPinArgs(
                tapSigner: FfiConverterTypeTapSigner.read(from: &buf), 
                startingPin: FfiConverterString.read(from: &buf), 
                chainCode: FfiConverterOptionString.read(from: &buf), 
                action: FfiConverterTypeTapSignerPinAction.read(from: &buf)
        )
    }

    public static func write(_ value: TapSignerNewPinArgs, into buf: inout [UInt8]) {
        FfiConverterTypeTapSigner.write(value.tapSigner, into: &buf)
        FfiConverterString.write(value.startingPin, into: &buf)
        FfiConverterOptionString.write(value.chainCode, into: &buf)
        FfiConverterTypeTapSignerPinAction.write(value.action, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerNewPinArgs_lift(_ buf: RustBuffer) throws -> TapSignerNewPinArgs {
    return try FfiConverterTypeTapSignerNewPinArgs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerNewPinArgs_lower(_ value: TapSignerNewPinArgs) -> RustBuffer {
    return FfiConverterTypeTapSignerNewPinArgs.lower(value)
}


public struct TapSignerSetupComplete: Equatable, Hashable {
    public var backup: Data
    public var deriveInfo: DeriveInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backup: Data, deriveInfo: DeriveInfo) {
        self.backup = backup
        self.deriveInfo = deriveInfo
    }

    

    
}

#if compiler(>=6)
extension TapSignerSetupComplete: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerSetupComplete: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerSetupComplete {
        return
            try TapSignerSetupComplete(
                backup: FfiConverterData.read(from: &buf), 
                deriveInfo: FfiConverterTypeDeriveInfo.read(from: &buf)
        )
    }

    public static func write(_ value: TapSignerSetupComplete, into buf: inout [UInt8]) {
        FfiConverterData.write(value.backup, into: &buf)
        FfiConverterTypeDeriveInfo.write(value.deriveInfo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerSetupComplete_lift(_ buf: RustBuffer) throws -> TapSignerSetupComplete {
    return try FfiConverterTypeTapSignerSetupComplete.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerSetupComplete_lower(_ value: TapSignerSetupComplete) -> RustBuffer {
    return FfiConverterTypeTapSignerSetupComplete.lower(value)
}


public struct TransactionExportResult: Equatable, Hashable {
    public var content: String
    public var filename: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(content: String, filename: String) {
        self.content = content
        self.filename = filename
    }

    

    
}

#if compiler(>=6)
extension TransactionExportResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionExportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionExportResult {
        return
            try TransactionExportResult(
                content: FfiConverterString.read(from: &buf), 
                filename: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionExportResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterString.write(value.filename, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionExportResult_lift(_ buf: RustBuffer) throws -> TransactionExportResult {
    return try FfiConverterTypeTransactionExportResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionExportResult_lower(_ value: TransactionExportResult) -> RustBuffer {
    return FfiConverterTypeTransactionExportResult.lower(value)
}


public struct WalletMetadata: Equatable, Hashable {
    public var id: WalletId
    public var name: String
    public var color: WalletColor
    public var verified: Bool
    public var network: Network
    public var masterFingerprint: Fingerprint?
    public var selectedUnit: BitcoinUnit
    public var sensitiveVisible: Bool
    public var detailsExpanded: Bool
    public var walletType: WalletType
    public var walletMode: WalletMode
    public var discoveryState: DiscoveryState
    public var addressType: WalletAddressType
    public var fiatOrBtc: FiatOrBtc
    public var origin: String?
    /**
     * Metadata data specific to different hardware wallets
     */
    public var hardwareMetadata: HardwareWalletMetadata?
    /**
     * Show labels for transactions i the transaction list
     * If false, we only show either `Sent` or `Received` labels
     */
    public var showLabels: Bool
    public var `internal`: InternalOnlyMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: WalletId, name: String, color: WalletColor, verified: Bool, network: Network, masterFingerprint: Fingerprint?, selectedUnit: BitcoinUnit, sensitiveVisible: Bool, detailsExpanded: Bool, walletType: WalletType, walletMode: WalletMode, discoveryState: DiscoveryState, addressType: WalletAddressType, fiatOrBtc: FiatOrBtc, origin: String?, 
        /**
         * Metadata data specific to different hardware wallets
         */hardwareMetadata: HardwareWalletMetadata?, 
        /**
         * Show labels for transactions i the transaction list
         * If false, we only show either `Sent` or `Received` labels
         */showLabels: Bool, `internal`: InternalOnlyMetadata) {
        self.id = id
        self.name = name
        self.color = color
        self.verified = verified
        self.network = network
        self.masterFingerprint = masterFingerprint
        self.selectedUnit = selectedUnit
        self.sensitiveVisible = sensitiveVisible
        self.detailsExpanded = detailsExpanded
        self.walletType = walletType
        self.walletMode = walletMode
        self.discoveryState = discoveryState
        self.addressType = addressType
        self.fiatOrBtc = fiatOrBtc
        self.origin = origin
        self.hardwareMetadata = hardwareMetadata
        self.showLabels = showLabels
        self.`internal` = `internal`
    }

    

    
// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: WalletMetadata, other: WalletMetadata) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletmetadata_uniffi_trait_eq_eq(
            FfiConverterTypeWalletMetadata_lower(self),
        FfiConverterTypeWalletMetadata_lower(other),$0
    )
}
    )
}
// The local Rust `Hash` implementation
public func hash(into hasher: inout Hasher) {
    let val = try!  FfiConverterUInt64.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletmetadata_uniffi_trait_hash(
            FfiConverterTypeWalletMetadata_lower(self),$0
    )
}
    )
    hasher.combine(val)
}
}

#if compiler(>=6)
extension WalletMetadata: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletMetadata {
        return
            try WalletMetadata(
                id: FfiConverterTypeWalletId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                color: FfiConverterTypeWalletColor.read(from: &buf), 
                verified: FfiConverterBool.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                masterFingerprint: FfiConverterOptionTypeFingerprint.read(from: &buf), 
                selectedUnit: FfiConverterTypeBitcoinUnit.read(from: &buf), 
                sensitiveVisible: FfiConverterBool.read(from: &buf), 
                detailsExpanded: FfiConverterBool.read(from: &buf), 
                walletType: FfiConverterTypeWalletType.read(from: &buf), 
                walletMode: FfiConverterTypeWalletMode.read(from: &buf), 
                discoveryState: FfiConverterTypeDiscoveryState.read(from: &buf), 
                addressType: FfiConverterTypeWalletAddressType.read(from: &buf), 
                fiatOrBtc: FfiConverterTypeFiatOrBtc.read(from: &buf), 
                origin: FfiConverterOptionString.read(from: &buf), 
                hardwareMetadata: FfiConverterOptionTypeHardwareWalletMetadata.read(from: &buf), 
                showLabels: FfiConverterBool.read(from: &buf), 
                internal: FfiConverterTypeInternalOnlyMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: WalletMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeWalletColor.write(value.color, into: &buf)
        FfiConverterBool.write(value.verified, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionTypeFingerprint.write(value.masterFingerprint, into: &buf)
        FfiConverterTypeBitcoinUnit.write(value.selectedUnit, into: &buf)
        FfiConverterBool.write(value.sensitiveVisible, into: &buf)
        FfiConverterBool.write(value.detailsExpanded, into: &buf)
        FfiConverterTypeWalletType.write(value.walletType, into: &buf)
        FfiConverterTypeWalletMode.write(value.walletMode, into: &buf)
        FfiConverterTypeDiscoveryState.write(value.discoveryState, into: &buf)
        FfiConverterTypeWalletAddressType.write(value.addressType, into: &buf)
        FfiConverterTypeFiatOrBtc.write(value.fiatOrBtc, into: &buf)
        FfiConverterOptionString.write(value.origin, into: &buf)
        FfiConverterOptionTypeHardwareWalletMetadata.write(value.hardwareMetadata, into: &buf)
        FfiConverterBool.write(value.showLabels, into: &buf)
        FfiConverterTypeInternalOnlyMetadata.write(value.`internal`, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletMetadata_lift(_ buf: RustBuffer) throws -> WalletMetadata {
    return try FfiConverterTypeWalletMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletMetadata_lower(_ value: WalletMetadata) -> RustBuffer {
    return FfiConverterTypeWalletMetadata.lower(value)
}


/**
 * Animation timing configuration
 */
public struct WordVerifyAnimationConfig: Equatable, Hashable {
    /**
     * Duration (ms) for chip to travel to target when correct
     */
    public var moveDurationMsCorrect: UInt32
    /**
     * Duration (ms) for chip to travel to target when incorrect
     */
    public var moveDurationMsIncorrect: UInt32
    /**
     * How long (ms) chip stays at target after arriving (correct)
     */
    public var dwellDurationMsCorrect: UInt32
    /**
     * How long (ms) chip stays at target after arriving (incorrect)
     */
    public var dwellDurationMsIncorrect: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Duration (ms) for chip to travel to target when correct
         */moveDurationMsCorrect: UInt32, 
        /**
         * Duration (ms) for chip to travel to target when incorrect
         */moveDurationMsIncorrect: UInt32, 
        /**
         * How long (ms) chip stays at target after arriving (correct)
         */dwellDurationMsCorrect: UInt32, 
        /**
         * How long (ms) chip stays at target after arriving (incorrect)
         */dwellDurationMsIncorrect: UInt32) {
        self.moveDurationMsCorrect = moveDurationMsCorrect
        self.moveDurationMsIncorrect = moveDurationMsIncorrect
        self.dwellDurationMsCorrect = dwellDurationMsCorrect
        self.dwellDurationMsIncorrect = dwellDurationMsIncorrect
    }

    

    
}

#if compiler(>=6)
extension WordVerifyAnimationConfig: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordVerifyAnimationConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordVerifyAnimationConfig {
        return
            try WordVerifyAnimationConfig(
                moveDurationMsCorrect: FfiConverterUInt32.read(from: &buf), 
                moveDurationMsIncorrect: FfiConverterUInt32.read(from: &buf), 
                dwellDurationMsCorrect: FfiConverterUInt32.read(from: &buf), 
                dwellDurationMsIncorrect: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: WordVerifyAnimationConfig, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.moveDurationMsCorrect, into: &buf)
        FfiConverterUInt32.write(value.moveDurationMsIncorrect, into: &buf)
        FfiConverterUInt32.write(value.dwellDurationMsCorrect, into: &buf)
        FfiConverterUInt32.write(value.dwellDurationMsIncorrect, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordVerifyAnimationConfig_lift(_ buf: RustBuffer) throws -> WordVerifyAnimationConfig {
    return try FfiConverterTypeWordVerifyAnimationConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordVerifyAnimationConfig_lower(_ value: WordVerifyAnimationConfig) -> RustBuffer {
    return FfiConverterTypeWordVerifyAnimationConfig.lower(value)
}


public struct XpubExportResult: Equatable, Hashable {
    public var content: String
    public var filename: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(content: String, filename: String) {
        self.content = content
        self.filename = filename
    }

    

    
}

#if compiler(>=6)
extension XpubExportResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeXpubExportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> XpubExportResult {
        return
            try XpubExportResult(
                content: FfiConverterString.read(from: &buf), 
                filename: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: XpubExportResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterString.write(value.filename, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXpubExportResult_lift(_ buf: RustBuffer) throws -> XpubExportResult {
    return try FfiConverterTypeXpubExportResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXpubExportResult_lower(_ value: XpubExportResult) -> RustBuffer {
    return FfiConverterTypeXpubExportResult.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AfterPinAction {
    
    case derive
    case change
    case backup
    case sign(Psbt
    )





}

#if compiler(>=6)
extension AfterPinAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAfterPinAction: FfiConverterRustBuffer {
    typealias SwiftType = AfterPinAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AfterPinAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .derive
        
        case 2: return .change
        
        case 3: return .backup
        
        case 4: return .sign(try FfiConverterTypePsbt.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AfterPinAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .derive:
            writeInt(&buf, Int32(1))
        
        
        case .change:
            writeInt(&buf, Int32(2))
        
        
        case .backup:
            writeInt(&buf, Int32(3))
        
        
        case let .sign(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypePsbt.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAfterPinAction_lift(_ buf: RustBuffer) throws -> AfterPinAction {
    return try FfiConverterTypeAfterPinAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAfterPinAction_lower(_ value: AfterPinAction) -> RustBuffer {
    return FfiConverterTypeAfterPinAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AmountOrMax {
    
    case amount(Amount
    )
    case max





}

#if compiler(>=6)
extension AmountOrMax: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAmountOrMax: FfiConverterRustBuffer {
    typealias SwiftType = AmountOrMax

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AmountOrMax {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 2: return .max
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AmountOrMax, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAmount.write(v1, into: &buf)
            
        
        case .max:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmountOrMax_lift(_ buf: RustBuffer) throws -> AmountOrMax {
    return try FfiConverterTypeAmountOrMax.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAmountOrMax_lower(_ value: AmountOrMax) -> RustBuffer {
    return FfiConverterTypeAmountOrMax.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ApiType: Equatable, Hashable {
    
    case esplora
    case electrum
    case rpc





}

#if compiler(>=6)
extension ApiType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeApiType: FfiConverterRustBuffer {
    typealias SwiftType = ApiType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .esplora
        
        case 2: return .electrum
        
        case 3: return .rpc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ApiType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .esplora:
            writeInt(&buf, Int32(1))
        
        
        case .electrum:
            writeInt(&buf, Int32(2))
        
        
        case .rpc:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApiType_lift(_ buf: RustBuffer) throws -> ApiType {
    return try FfiConverterTypeApiType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApiType_lower(_ value: ApiType) -> RustBuffer {
    return FfiConverterTypeApiType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AppAction {
    
    case updateRoute(routes: [Route]
    )
    case pushRoute(Route
    )
    case popRoute
    case changeNetwork(network: Network
    )
    case changeColorScheme(ColorSchemeSelection
    )
    case changeFiatCurrency(FiatCurrency
    )
    case setSelectedNode(Node
    )
    case updateFiatPrices
    case updateFees
    case acceptTerms





}

#if compiler(>=6)
extension AppAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppAction: FfiConverterRustBuffer {
    typealias SwiftType = AppAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateRoute(routes: try FfiConverterSequenceTypeRoute.read(from: &buf)
        )
        
        case 2: return .pushRoute(try FfiConverterTypeRoute.read(from: &buf)
        )
        
        case 3: return .popRoute
        
        case 4: return .changeNetwork(network: try FfiConverterTypeNetwork.read(from: &buf)
        )
        
        case 5: return .changeColorScheme(try FfiConverterTypeColorSchemeSelection.read(from: &buf)
        )
        
        case 6: return .changeFiatCurrency(try FfiConverterTypeFiatCurrency.read(from: &buf)
        )
        
        case 7: return .setSelectedNode(try FfiConverterTypeNode.read(from: &buf)
        )
        
        case 8: return .updateFiatPrices
        
        case 9: return .updateFees
        
        case 10: return .acceptTerms
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateRoute(routes):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoute.write(routes, into: &buf)
            
        
        case let .pushRoute(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRoute.write(v1, into: &buf)
            
        
        case .popRoute:
            writeInt(&buf, Int32(3))
        
        
        case let .changeNetwork(network):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNetwork.write(network, into: &buf)
            
        
        case let .changeColorScheme(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeColorSchemeSelection.write(v1, into: &buf)
            
        
        case let .changeFiatCurrency(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFiatCurrency.write(v1, into: &buf)
            
        
        case let .setSelectedNode(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        
        case .updateFiatPrices:
            writeInt(&buf, Int32(8))
        
        
        case .updateFees:
            writeInt(&buf, Int32(9))
        
        
        case .acceptTerms:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppAction_lift(_ buf: RustBuffer) throws -> AppAction {
    return try FfiConverterTypeAppAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppAction_lower(_ value: AppAction) -> RustBuffer {
    return FfiConverterTypeAppAction.lower(value)
}



public enum AppError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case PricesError(String
    )
    case FeesError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_apperror_uniffi_trait_display(
            FfiConverterTypeAppError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension AppError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppError: FfiConverterRustBuffer {
    typealias SwiftType = AppError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PricesError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .FeesError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .PricesError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .FeesError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppError_lift(_ buf: RustBuffer) throws -> AppError {
    return try FfiConverterTypeAppError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppError_lower(_ value: AppError) -> RustBuffer {
    return FfiConverterTypeAppError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AppStateReconcileMessage {
    
    case defaultRouteChanged(Route,[Route]
    )
    case routeUpdated([Route]
    )
    case databaseUpdated
    case colorSchemeChanged(ColorSchemeSelection
    )
    case selectedNodeChanged(Node
    )
    case selectedNetworkChanged(Network
    )
    case fiatPricesChanged(PriceResponse
    )
    case feesChanged(FeeResponse
    )
    case fiatCurrencyChanged(FiatCurrency
    )
    case walletModeChanged(WalletMode
    )
    case pushedRoute(Route
    )
    case acceptedTerms
    case walletsChanged
    case showLoadingPopup
    case hideLoadingPopup





}

#if compiler(>=6)
extension AppStateReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppStateReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = AppStateReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppStateReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .defaultRouteChanged(try FfiConverterTypeRoute.read(from: &buf), try FfiConverterSequenceTypeRoute.read(from: &buf)
        )
        
        case 2: return .routeUpdated(try FfiConverterSequenceTypeRoute.read(from: &buf)
        )
        
        case 3: return .databaseUpdated
        
        case 4: return .colorSchemeChanged(try FfiConverterTypeColorSchemeSelection.read(from: &buf)
        )
        
        case 5: return .selectedNodeChanged(try FfiConverterTypeNode.read(from: &buf)
        )
        
        case 6: return .selectedNetworkChanged(try FfiConverterTypeNetwork.read(from: &buf)
        )
        
        case 7: return .fiatPricesChanged(try FfiConverterTypePriceResponse.read(from: &buf)
        )
        
        case 8: return .feesChanged(try FfiConverterTypeFeeResponse.read(from: &buf)
        )
        
        case 9: return .fiatCurrencyChanged(try FfiConverterTypeFiatCurrency.read(from: &buf)
        )
        
        case 10: return .walletModeChanged(try FfiConverterTypeWalletMode.read(from: &buf)
        )
        
        case 11: return .pushedRoute(try FfiConverterTypeRoute.read(from: &buf)
        )
        
        case 12: return .acceptedTerms
        
        case 13: return .walletsChanged
        
        case 14: return .showLoadingPopup
        
        case 15: return .hideLoadingPopup
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppStateReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .defaultRouteChanged(v1,v2):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoute.write(v1, into: &buf)
            FfiConverterSequenceTypeRoute.write(v2, into: &buf)
            
        
        case let .routeUpdated(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeRoute.write(v1, into: &buf)
            
        
        case .databaseUpdated:
            writeInt(&buf, Int32(3))
        
        
        case let .colorSchemeChanged(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeColorSchemeSelection.write(v1, into: &buf)
            
        
        case let .selectedNodeChanged(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        
        case let .selectedNetworkChanged(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNetwork.write(v1, into: &buf)
            
        
        case let .fiatPricesChanged(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypePriceResponse.write(v1, into: &buf)
            
        
        case let .feesChanged(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFeeResponse.write(v1, into: &buf)
            
        
        case let .fiatCurrencyChanged(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeFiatCurrency.write(v1, into: &buf)
            
        
        case let .walletModeChanged(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeWalletMode.write(v1, into: &buf)
            
        
        case let .pushedRoute(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeRoute.write(v1, into: &buf)
            
        
        case .acceptedTerms:
            writeInt(&buf, Int32(12))
        
        
        case .walletsChanged:
            writeInt(&buf, Int32(13))
        
        
        case .showLoadingPopup:
            writeInt(&buf, Int32(14))
        
        
        case .hideLoadingPopup:
            writeInt(&buf, Int32(15))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppStateReconcileMessage_lift(_ buf: RustBuffer) throws -> AppStateReconcileMessage {
    return try FfiConverterTypeAppStateReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppStateReconcileMessage_lower(_ value: AppStateReconcileMessage) -> RustBuffer {
    return FfiConverterTypeAppStateReconcileMessage.lower(value)
}



public enum AuthError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case DatabaseSaveError(DatabaseError
    )
    case DatabaseGetError(DatabaseError
    )
    case HashError(String
    )
    case ParseHashedPinError(String
    )
    case VerificationFailed(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_autherror_uniffi_trait_display(
            FfiConverterTypeAuthError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension AuthError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthError: FfiConverterRustBuffer {
    typealias SwiftType = AuthError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DatabaseSaveError(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 2: return .DatabaseGetError(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 3: return .HashError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .ParseHashedPinError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .VerificationFailed(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DatabaseSaveError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .DatabaseGetError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .HashError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ParseHashedPinError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VerificationFailed(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthError_lift(_ buf: RustBuffer) throws -> AuthError {
    return try FfiConverterTypeAuthError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthError_lower(_ value: AuthError) -> RustBuffer {
    return FfiConverterTypeAuthError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthManagerAction: Equatable, Hashable {
    
    case updateAuthType(AuthType
    )
    case enableBiometric
    case disableBiometric
    case disablePin
    case setPin(String
    )
    case disableWipeDataPin
    case disableDecoyPin





}

#if compiler(>=6)
extension AuthManagerAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = AuthManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateAuthType(try FfiConverterTypeAuthType.read(from: &buf)
        )
        
        case 2: return .enableBiometric
        
        case 3: return .disableBiometric
        
        case 4: return .disablePin
        
        case 5: return .setPin(try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .disableWipeDataPin
        
        case 7: return .disableDecoyPin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateAuthType(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAuthType.write(v1, into: &buf)
            
        
        case .enableBiometric:
            writeInt(&buf, Int32(2))
        
        
        case .disableBiometric:
            writeInt(&buf, Int32(3))
        
        
        case .disablePin:
            writeInt(&buf, Int32(4))
        
        
        case let .setPin(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .disableWipeDataPin:
            writeInt(&buf, Int32(6))
        
        
        case .disableDecoyPin:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerAction_lift(_ buf: RustBuffer) throws -> AuthManagerAction {
    return try FfiConverterTypeAuthManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerAction_lower(_ value: AuthManagerAction) -> RustBuffer {
    return FfiConverterTypeAuthManagerAction.lower(value)
}



public enum AuthManagerError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case WipeDataSet(TrickPinError
    )
    case DecoySet(TrickPinError
    )
    case Database(DatabaseError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_authmanagererror_uniffi_trait_display(
            FfiConverterTypeAuthManagerError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension AuthManagerError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthManagerError: FfiConverterRustBuffer {
    typealias SwiftType = AuthManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .WipeDataSet(
            try FfiConverterTypeTrickPinError.read(from: &buf)
            )
        case 2: return .DecoySet(
            try FfiConverterTypeTrickPinError.read(from: &buf)
            )
        case 3: return .Database(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .WipeDataSet(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTrickPinError.write(v1, into: &buf)
            
        
        case let .DecoySet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTrickPinError.write(v1, into: &buf)
            
        
        case let .Database(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerError_lift(_ buf: RustBuffer) throws -> AuthManagerError {
    return try FfiConverterTypeAuthManagerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerError_lower(_ value: AuthManagerError) -> RustBuffer {
    return FfiConverterTypeAuthManagerError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthManagerReconcileMessage: Equatable, Hashable {
    
    case authTypeChanged(AuthType
    )
    case wipeDataPinChanged
    case decoyPinChanged





}

#if compiler(>=6)
extension AuthManagerReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = AuthManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authTypeChanged(try FfiConverterTypeAuthType.read(from: &buf)
        )
        
        case 2: return .wipeDataPinChanged
        
        case 3: return .decoyPinChanged
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .authTypeChanged(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAuthType.write(v1, into: &buf)
            
        
        case .wipeDataPinChanged:
            writeInt(&buf, Int32(2))
        
        
        case .decoyPinChanged:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> AuthManagerReconcileMessage {
    return try FfiConverterTypeAuthManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthManagerReconcileMessage_lower(_ value: AuthManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeAuthManagerReconcileMessage.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthType: Equatable, Hashable {
    
    case pin
    case biometric
    case both
    case none





}

#if compiler(>=6)
extension AuthType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthType: FfiConverterRustBuffer {
    typealias SwiftType = AuthType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pin
        
        case 2: return .biometric
        
        case 3: return .both
        
        case 4: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pin:
            writeInt(&buf, Int32(1))
        
        
        case .biometric:
            writeInt(&buf, Int32(2))
        
        
        case .both:
            writeInt(&buf, Int32(3))
        
        
        case .none:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthType_lift(_ buf: RustBuffer) throws -> AuthType {
    return try FfiConverterTypeAuthType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthType_lower(_ value: AuthType) -> RustBuffer {
    return FfiConverterTypeAuthType.lower(value)
}



public enum Bip39Error: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case BadWordCount(UInt32
    )
    case UnknownWord(UInt32
    )
    case BadEntropyBitCount(UInt32
    )
    case InvalidChecksum
    case AmbiguousLanguages

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_bip39error_uniffi_trait_display(
            FfiConverterTypeBip39Error_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension Bip39Error: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBip39Error: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadWordCount(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 2: return .UnknownWord(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 3: return .BadEntropyBitCount(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 4: return .InvalidChecksum
        case 5: return .AmbiguousLanguages

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BadWordCount(v1):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .UnknownWord(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .BadEntropyBitCount(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case .InvalidChecksum:
            writeInt(&buf, Int32(4))
        
        
        case .AmbiguousLanguages:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39Error_lift(_ buf: RustBuffer) throws -> Bip39Error {
    return try FfiConverterTypeBip39Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBip39Error_lower(_ value: Bip39Error) -> RustBuffer {
    return FfiConverterTypeBip39Error.lower(value)
}


public enum BitcoinTransactionError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case HexDecodeError(String
    )
    case ParseTransactionError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_bitcointransactionerror_uniffi_trait_display(
            FfiConverterTypeBitcoinTransactionError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension BitcoinTransactionError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitcoinTransactionError: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinTransactionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinTransactionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HexDecodeError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ParseTransactionError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinTransactionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .HexDecodeError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ParseTransactionError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTransactionError_lift(_ buf: RustBuffer) throws -> BitcoinTransactionError {
    return try FfiConverterTypeBitcoinTransactionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitcoinTransactionError_lower(_ value: BitcoinTransactionError) -> RustBuffer {
    return FfiConverterTypeBitcoinTransactionError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ButtonPresentation: Equatable, Hashable {
    
    case notSelected
    case selected(ListSortDirection
    )





}

#if compiler(>=6)
extension ButtonPresentation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeButtonPresentation: FfiConverterRustBuffer {
    typealias SwiftType = ButtonPresentation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ButtonPresentation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notSelected
        
        case 2: return .selected(try FfiConverterTypeListSortDirection.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ButtonPresentation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notSelected:
            writeInt(&buf, Int32(1))
        
        
        case let .selected(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeListSortDirection.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeButtonPresentation_lift(_ buf: RustBuffer) throws -> ButtonPresentation {
    return try FfiConverterTypeButtonPresentation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeButtonPresentation_lower(_ value: ButtonPresentation) -> RustBuffer {
    return FfiConverterTypeButtonPresentation.lower(value)
}



public enum ByteReaderError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case BufferTooSmall

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_bytereadererror_uniffi_trait_display(
            FfiConverterTypeByteReaderError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ByteReaderError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeByteReaderError: FfiConverterRustBuffer {
    typealias SwiftType = ByteReaderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ByteReaderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BufferTooSmall

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ByteReaderError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .BufferTooSmall:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeByteReaderError_lift(_ buf: RustBuffer) throws -> ByteReaderError {
    return try FfiConverterTypeByteReaderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeByteReaderError_lower(_ value: ByteReaderError) -> RustBuffer {
    return FfiConverterTypeByteReaderError.lower(value)
}


public enum CkTapError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case UnluckyNumber
    case BadArguments
    case BadAuth
    case NeedsAuth
    case UnknownCommand
    case InvalidCommand
    case InvalidState
    case WeakNonce
    case BadCbor
    case BackupFirst
    case RateLimited

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension CkTapError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCkTapError: FfiConverterRustBuffer {
    typealias SwiftType = CkTapError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CkTapError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UnluckyNumber
        case 2: return .BadArguments
        case 3: return .BadAuth
        case 4: return .NeedsAuth
        case 5: return .UnknownCommand
        case 6: return .InvalidCommand
        case 7: return .InvalidState
        case 8: return .WeakNonce
        case 9: return .BadCbor
        case 10: return .BackupFirst
        case 11: return .RateLimited

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CkTapError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .UnluckyNumber:
            writeInt(&buf, Int32(1))
        
        
        case .BadArguments:
            writeInt(&buf, Int32(2))
        
        
        case .BadAuth:
            writeInt(&buf, Int32(3))
        
        
        case .NeedsAuth:
            writeInt(&buf, Int32(4))
        
        
        case .UnknownCommand:
            writeInt(&buf, Int32(5))
        
        
        case .InvalidCommand:
            writeInt(&buf, Int32(6))
        
        
        case .InvalidState:
            writeInt(&buf, Int32(7))
        
        
        case .WeakNonce:
            writeInt(&buf, Int32(8))
        
        
        case .BadCbor:
            writeInt(&buf, Int32(9))
        
        
        case .BackupFirst:
            writeInt(&buf, Int32(10))
        
        
        case .RateLimited:
            writeInt(&buf, Int32(11))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCkTapError_lift(_ buf: RustBuffer) throws -> CkTapError {
    return try FfiConverterTypeCkTapError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCkTapError_lower(_ value: CkTapError) -> RustBuffer {
    return FfiConverterTypeCkTapError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinControlListSort: Equatable, Hashable {
    
    case date(ListSortDirection
    )
    case name(ListSortDirection
    )
    case amount(ListSortDirection
    )
    case change(UtxoType
    )





}

#if compiler(>=6)
extension CoinControlListSort: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlListSort: FfiConverterRustBuffer {
    typealias SwiftType = CoinControlListSort

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlListSort {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .date(try FfiConverterTypeListSortDirection.read(from: &buf)
        )
        
        case 2: return .name(try FfiConverterTypeListSortDirection.read(from: &buf)
        )
        
        case 3: return .amount(try FfiConverterTypeListSortDirection.read(from: &buf)
        )
        
        case 4: return .change(try FfiConverterTypeUtxoType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinControlListSort, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .date(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeListSortDirection.write(v1, into: &buf)
            
        
        case let .name(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeListSortDirection.write(v1, into: &buf)
            
        
        case let .amount(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeListSortDirection.write(v1, into: &buf)
            
        
        case let .change(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeUtxoType.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlListSort_lift(_ buf: RustBuffer) throws -> CoinControlListSort {
    return try FfiConverterTypeCoinControlListSort.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlListSort_lower(_ value: CoinControlListSort) -> RustBuffer {
    return FfiConverterTypeCoinControlListSort.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinControlListSortKey: Equatable, Hashable {
    
    case date
    case name
    case amount
    case change





}

#if compiler(>=6)
extension CoinControlListSortKey: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlListSortKey: FfiConverterRustBuffer {
    typealias SwiftType = CoinControlListSortKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlListSortKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .date
        
        case 2: return .name
        
        case 3: return .amount
        
        case 4: return .change
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinControlListSortKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .date:
            writeInt(&buf, Int32(1))
        
        
        case .name:
            writeInt(&buf, Int32(2))
        
        
        case .amount:
            writeInt(&buf, Int32(3))
        
        
        case .change:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlListSortKey_lift(_ buf: RustBuffer) throws -> CoinControlListSortKey {
    return try FfiConverterTypeCoinControlListSortKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlListSortKey_lower(_ value: CoinControlListSortKey) -> RustBuffer {
    return FfiConverterTypeCoinControlListSortKey.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinControlListSortState: Equatable, Hashable {
    
    case active(CoinControlListSort
    )
    case inactive(CoinControlListSort
    )





}

#if compiler(>=6)
extension CoinControlListSortState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlListSortState: FfiConverterRustBuffer {
    typealias SwiftType = CoinControlListSortState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlListSortState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .active(try FfiConverterTypeCoinControlListSort.read(from: &buf)
        )
        
        case 2: return .inactive(try FfiConverterTypeCoinControlListSort.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinControlListSortState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .active(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCoinControlListSort.write(v1, into: &buf)
            
        
        case let .inactive(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeCoinControlListSort.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlListSortState_lift(_ buf: RustBuffer) throws -> CoinControlListSortState {
    return try FfiConverterTypeCoinControlListSortState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlListSortState_lower(_ value: CoinControlListSortState) -> RustBuffer {
    return FfiConverterTypeCoinControlListSortState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinControlManagerAction {
    
    case changeSort(CoinControlListSortKey
    )
    case clearSearch
    case toggleSelectAll
    case toggleUnit
    case notifySelectedUtxosChanged([OutPoint]
    )
    case notifySearchChanged(String
    )





}

#if compiler(>=6)
extension CoinControlManagerAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = CoinControlManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .changeSort(try FfiConverterTypeCoinControlListSortKey.read(from: &buf)
        )
        
        case 2: return .clearSearch
        
        case 3: return .toggleSelectAll
        
        case 4: return .toggleUnit
        
        case 5: return .notifySelectedUtxosChanged(try FfiConverterSequenceTypeOutPoint.read(from: &buf)
        )
        
        case 6: return .notifySearchChanged(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinControlManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .changeSort(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCoinControlListSortKey.write(v1, into: &buf)
            
        
        case .clearSearch:
            writeInt(&buf, Int32(2))
        
        
        case .toggleSelectAll:
            writeInt(&buf, Int32(3))
        
        
        case .toggleUnit:
            writeInt(&buf, Int32(4))
        
        
        case let .notifySelectedUtxosChanged(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeOutPoint.write(v1, into: &buf)
            
        
        case let .notifySearchChanged(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlManagerAction_lift(_ buf: RustBuffer) throws -> CoinControlManagerAction {
    return try FfiConverterTypeCoinControlManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlManagerAction_lower(_ value: CoinControlManagerAction) -> RustBuffer {
    return FfiConverterTypeCoinControlManagerAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinControlManagerReconcileMessage {
    
    case clearSort
    case updateSort(CoinControlListSort
    )
    case updateUtxos([Utxo]
    )
    case updateSearch(String
    )
    case updateSelectedUtxos(utxos: [OutPoint], totalValue: Amount
    )
    case updateTotalSelectedAmount(Amount
    )
    case updateUnit(BitcoinUnit
    )





}

#if compiler(>=6)
extension CoinControlManagerReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = CoinControlManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .clearSort
        
        case 2: return .updateSort(try FfiConverterTypeCoinControlListSort.read(from: &buf)
        )
        
        case 3: return .updateUtxos(try FfiConverterSequenceTypeUtxo.read(from: &buf)
        )
        
        case 4: return .updateSearch(try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .updateSelectedUtxos(utxos: try FfiConverterSequenceTypeOutPoint.read(from: &buf), totalValue: try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 6: return .updateTotalSelectedAmount(try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 7: return .updateUnit(try FfiConverterTypeBitcoinUnit.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinControlManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .clearSort:
            writeInt(&buf, Int32(1))
        
        
        case let .updateSort(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeCoinControlListSort.write(v1, into: &buf)
            
        
        case let .updateUtxos(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeUtxo.write(v1, into: &buf)
            
        
        case let .updateSearch(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .updateSelectedUtxos(utxos,totalValue):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeOutPoint.write(utxos, into: &buf)
            FfiConverterTypeAmount.write(totalValue, into: &buf)
            
        
        case let .updateTotalSelectedAmount(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeAmount.write(v1, into: &buf)
            
        
        case let .updateUnit(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeBitcoinUnit.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> CoinControlManagerReconcileMessage {
    return try FfiConverterTypeCoinControlManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlManagerReconcileMessage_lower(_ value: CoinControlManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeCoinControlManagerReconcileMessage.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinControlRoute: Equatable, Hashable {
    
    case list(WalletId
    )





}

#if compiler(>=6)
extension CoinControlRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinControlRoute: FfiConverterRustBuffer {
    typealias SwiftType = CoinControlRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinControlRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .list(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinControlRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .list(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlRoute_lift(_ buf: RustBuffer) throws -> CoinControlRoute {
    return try FfiConverterTypeCoinControlRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinControlRoute_lower(_ value: CoinControlRoute) -> RustBuffer {
    return FfiConverterTypeCoinControlRoute.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ColdWalletRoute: Equatable, Hashable {
    
    case qrCode





}

#if compiler(>=6)
extension ColdWalletRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeColdWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = ColdWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ColdWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .qrCode
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ColdWalletRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .qrCode:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColdWalletRoute_lift(_ buf: RustBuffer) throws -> ColdWalletRoute {
    return try FfiConverterTypeColdWalletRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeColdWalletRoute_lower(_ value: ColdWalletRoute) -> RustBuffer {
    return FfiConverterTypeColdWalletRoute.lower(value)
}



public enum ConverterError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case FiatAmountFromStringError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_convertererror_uniffi_trait_display(
            FfiConverterTypeConverterError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ConverterError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConverterError: FfiConverterRustBuffer {
    typealias SwiftType = ConverterError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConverterError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .FiatAmountFromStringError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConverterError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .FiatAmountFromStringError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConverterError_lift(_ buf: RustBuffer) throws -> ConverterError {
    return try FfiConverterTypeConverterError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConverterError_lower(_ value: ConverterError) -> RustBuffer {
    return FfiConverterTypeConverterError.lower(value)
}


public enum DatabaseError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case DatabaseAccess(String
    )
    case TableAccess(String
    )
    case Wallets(WalletTableError
    )
    case GlobalFlag(GlobalFlagTableError
    )
    case GlobalConfig(GlobalConfigTableError
    )
    case GlobalCache(GlobalCacheTableError
    )
    case UnsignedTransactions(UnsignedTransactionsTableError
    )
    case HistoricalPrice(HistoricalPriceTableError
    )
    case Serialization(SerdeError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_databaseerror_uniffi_trait_display(
            FfiConverterTypeDatabaseError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension DatabaseError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDatabaseError: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DatabaseAccess(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .TableAccess(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Wallets(
            try FfiConverterTypeWalletTableError.read(from: &buf)
            )
        case 4: return .GlobalFlag(
            try FfiConverterTypeGlobalFlagTableError.read(from: &buf)
            )
        case 5: return .GlobalConfig(
            try FfiConverterTypeGlobalConfigTableError.read(from: &buf)
            )
        case 6: return .GlobalCache(
            try FfiConverterTypeGlobalCacheTableError.read(from: &buf)
            )
        case 7: return .UnsignedTransactions(
            try FfiConverterTypeUnsignedTransactionsTableError.read(from: &buf)
            )
        case 8: return .HistoricalPrice(
            try FfiConverterTypeHistoricalPriceTableError.read(from: &buf)
            )
        case 9: return .Serialization(
            try FfiConverterTypeSerdeError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DatabaseAccess(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .TableAccess(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Wallets(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletTableError.write(v1, into: &buf)
            
        
        case let .GlobalFlag(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeGlobalFlagTableError.write(v1, into: &buf)
            
        
        case let .GlobalConfig(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeGlobalConfigTableError.write(v1, into: &buf)
            
        
        case let .GlobalCache(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeGlobalCacheTableError.write(v1, into: &buf)
            
        
        case let .UnsignedTransactions(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeUnsignedTransactionsTableError.write(v1, into: &buf)
            
        
        case let .HistoricalPrice(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeHistoricalPriceTableError.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeSerdeError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabaseError_lift(_ buf: RustBuffer) throws -> DatabaseError {
    return try FfiConverterTypeDatabaseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDatabaseError_lower(_ value: DatabaseError) -> RustBuffer {
    return FfiConverterTypeDatabaseError.lower(value)
}


public enum DescriptorError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidDescriptor(String
    )
    case MissingKeys
    case TooManyKeys(UInt32
    )
    case InvalidDescriptorParse(String
    )
    case MissingDescriptor
    case MissingXpub
    case MissingDerivationPath
    case MissingScriptType
    case MissingFingerprint
    case InvalidXpub(String
    )
    case UnableToParseXpub(String
    )
    case NoXpubInDescriptor
    case SinglePubkeyNotSupported
    case MasterXpub
    case KeyExpressionError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_descriptorerror_uniffi_trait_display(
            FfiConverterTypeDescriptorError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension DescriptorError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDescriptorError: FfiConverterRustBuffer {
    typealias SwiftType = DescriptorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DescriptorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDescriptor(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .MissingKeys
        case 3: return .TooManyKeys(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 4: return .InvalidDescriptorParse(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .MissingDescriptor
        case 6: return .MissingXpub
        case 7: return .MissingDerivationPath
        case 8: return .MissingScriptType
        case 9: return .MissingFingerprint
        case 10: return .InvalidXpub(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .UnableToParseXpub(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .NoXpubInDescriptor
        case 13: return .SinglePubkeyNotSupported
        case 14: return .MasterXpub
        case 15: return .KeyExpressionError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DescriptorError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidDescriptor(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .MissingKeys:
            writeInt(&buf, Int32(2))
        
        
        case let .TooManyKeys(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .InvalidDescriptorParse(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .MissingDescriptor:
            writeInt(&buf, Int32(5))
        
        
        case .MissingXpub:
            writeInt(&buf, Int32(6))
        
        
        case .MissingDerivationPath:
            writeInt(&buf, Int32(7))
        
        
        case .MissingScriptType:
            writeInt(&buf, Int32(8))
        
        
        case .MissingFingerprint:
            writeInt(&buf, Int32(9))
        
        
        case let .InvalidXpub(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnableToParseXpub(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NoXpubInDescriptor:
            writeInt(&buf, Int32(12))
        
        
        case .SinglePubkeyNotSupported:
            writeInt(&buf, Int32(13))
        
        
        case .MasterXpub:
            writeInt(&buf, Int32(14))
        
        
        case let .KeyExpressionError(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorError_lift(_ buf: RustBuffer) throws -> DescriptorError {
    return try FfiConverterTypeDescriptorError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDescriptorError_lower(_ value: DescriptorError) -> RustBuffer {
    return FfiConverterTypeDescriptorError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DiscoveryState: Equatable, Hashable {
    
    case single
    case startedJson(FoundJson
    )
    case startedMnemonic
    case foundAddressesFromJson([FoundAddress],FoundJson
    )
    case foundAddressesFromMnemonic([FoundAddress]
    )
    case noneFound
    case choseAdressType





// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: DiscoveryState, other: DiscoveryState) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_fn_method_discoverystate_uniffi_trait_eq_eq(
            FfiConverterTypeDiscoveryState_lower(self),
        FfiConverterTypeDiscoveryState_lower(other),$0
    )
}
    )
}
// The local Rust `Hash` implementation
public func hash(into hasher: inout Hasher) {
    let val = try!  FfiConverterUInt64.lift(
        try! rustCall() {
    uniffi_cove_fn_method_discoverystate_uniffi_trait_hash(
            FfiConverterTypeDiscoveryState_lower(self),$0
    )
}
    )
    hasher.combine(val)
}
}

#if compiler(>=6)
extension DiscoveryState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDiscoveryState: FfiConverterRustBuffer {
    typealias SwiftType = DiscoveryState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DiscoveryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single
        
        case 2: return .startedJson(try FfiConverterTypeFoundJson.read(from: &buf)
        )
        
        case 3: return .startedMnemonic
        
        case 4: return .foundAddressesFromJson(try FfiConverterSequenceTypeFoundAddress.read(from: &buf), try FfiConverterTypeFoundJson.read(from: &buf)
        )
        
        case 5: return .foundAddressesFromMnemonic(try FfiConverterSequenceTypeFoundAddress.read(from: &buf)
        )
        
        case 6: return .noneFound
        
        case 7: return .choseAdressType
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DiscoveryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .single:
            writeInt(&buf, Int32(1))
        
        
        case let .startedJson(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFoundJson.write(v1, into: &buf)
            
        
        case .startedMnemonic:
            writeInt(&buf, Int32(3))
        
        
        case let .foundAddressesFromJson(v1,v2):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeFoundAddress.write(v1, into: &buf)
            FfiConverterTypeFoundJson.write(v2, into: &buf)
            
        
        case let .foundAddressesFromMnemonic(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeFoundAddress.write(v1, into: &buf)
            
        
        case .noneFound:
            writeInt(&buf, Int32(6))
        
        
        case .choseAdressType:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDiscoveryState_lift(_ buf: RustBuffer) throws -> DiscoveryState {
    return try FfiConverterTypeDiscoveryState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDiscoveryState_lower(_ value: DiscoveryState) -> RustBuffer {
    return FfiConverterTypeDiscoveryState.lower(value)
}



public enum FiatAmountError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * Unable to convert to fiat amount, prices client unavailable {0}
     */
    case PricesUnavailable(String
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension FiatAmountError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatAmountError: FfiConverterRustBuffer {
    typealias SwiftType = FiatAmountError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatAmountError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PricesUnavailable(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatAmountError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .PricesUnavailable(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatAmountError_lift(_ buf: RustBuffer) throws -> FiatAmountError {
    return try FfiConverterTypeFiatAmountError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatAmountError_lower(_ value: FiatAmountError) -> RustBuffer {
    return FfiConverterTypeFiatAmountError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FiatCurrency: Equatable, Hashable, CustomStringConvertible {
    
    case usd
    case cad
    case aud
    case eur
    case gbp
    case chf
    case jpy





// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_fiatcurrency_uniffi_trait_display(
            FfiConverterTypeFiatCurrency_lower(self),$0
    )
}
    )
}
}

#if compiler(>=6)
extension FiatCurrency: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .usd
        
        case 2: return .cad
        
        case 3: return .aud
        
        case 4: return .eur
        
        case 5: return .gbp
        
        case 6: return .chf
        
        case 7: return .jpy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .usd:
            writeInt(&buf, Int32(1))
        
        
        case .cad:
            writeInt(&buf, Int32(2))
        
        
        case .aud:
            writeInt(&buf, Int32(3))
        
        
        case .eur:
            writeInt(&buf, Int32(4))
        
        
        case .gbp:
            writeInt(&buf, Int32(5))
        
        
        case .chf:
            writeInt(&buf, Int32(6))
        
        
        case .jpy:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FiatOrBtc: Equatable, Hashable {
    
    case btc
    case fiat





}

#if compiler(>=6)
extension FiatOrBtc: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatOrBtc: FfiConverterRustBuffer {
    typealias SwiftType = FiatOrBtc

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatOrBtc {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .btc
        
        case 2: return .fiat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatOrBtc, into buf: inout [UInt8]) {
        switch value {
        
        
        case .btc:
            writeInt(&buf, Int32(1))
        
        
        case .fiat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatOrBtc_lift(_ buf: RustBuffer) throws -> FiatOrBtc {
    return try FfiConverterTypeFiatOrBtc.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatOrBtc_lower(_ value: FiatOrBtc) -> RustBuffer {
    return FfiConverterTypeFiatOrBtc.lower(value)
}



public enum FileHandlerError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case FileNotFound
    case OpenFile(String
    )
    case ReadFile(String
    )
    case NotRecognizedFormat(MultiFormatError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_filehandlererror_uniffi_trait_display(
            FfiConverterTypeFileHandlerError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension FileHandlerError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileHandlerError: FfiConverterRustBuffer {
    typealias SwiftType = FileHandlerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileHandlerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .FileNotFound
        case 2: return .OpenFile(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .ReadFile(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .NotRecognizedFormat(
            try FfiConverterTypeMultiFormatError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileHandlerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .FileNotFound:
            writeInt(&buf, Int32(1))
        
        
        case let .OpenFile(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ReadFile(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NotRecognizedFormat(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMultiFormatError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileHandlerError_lift(_ buf: RustBuffer) throws -> FileHandlerError {
    return try FfiConverterTypeFileHandlerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileHandlerError_lower(_ value: FileHandlerError) -> RustBuffer {
    return FfiConverterTypeFileHandlerError.lower(value)
}


public enum FingerprintError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case WalletNotFound

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_fingerprinterror_uniffi_trait_display(
            FfiConverterTypeFingerprintError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension FingerprintError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFingerprintError: FfiConverterRustBuffer {
    typealias SwiftType = FingerprintError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FingerprintError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .WalletNotFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FingerprintError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .WalletNotFound:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFingerprintError_lift(_ buf: RustBuffer) throws -> FingerprintError {
    return try FfiConverterTypeFingerprintError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFingerprintError_lower(_ value: FingerprintError) -> RustBuffer {
    return FfiConverterTypeFingerprintError.lower(value)
}


public enum GlobalCacheTableError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Save(String
    )
    case Read(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_globalcachetableerror_uniffi_trait_display(
            FfiConverterTypeGlobalCacheTableError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension GlobalCacheTableError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalCacheTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalCacheTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalCacheTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalCacheTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalCacheTableError_lift(_ buf: RustBuffer) throws -> GlobalCacheTableError {
    return try FfiConverterTypeGlobalCacheTableError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalCacheTableError_lower(_ value: GlobalCacheTableError) -> RustBuffer {
    return FfiConverterTypeGlobalCacheTableError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalConfigKey: Equatable, Hashable {
    
    case selectedWalletId
    case selectedNetwork
    case selectedFiatCurrency
    case selectedNode(Network
    )
    case colorScheme
    case authType
    case hashedPinCode
    case wipeDataPin
    case decoyPin
    case inDecoyMode
    case mainSelectedWalletId
    case decoySelectedWalletId
    case lockedAt





}

#if compiler(>=6)
extension GlobalConfigKey: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfigKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalConfigKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .selectedWalletId
        
        case 2: return .selectedNetwork
        
        case 3: return .selectedFiatCurrency
        
        case 4: return .selectedNode(try FfiConverterTypeNetwork.read(from: &buf)
        )
        
        case 5: return .colorScheme
        
        case 6: return .authType
        
        case 7: return .hashedPinCode
        
        case 8: return .wipeDataPin
        
        case 9: return .decoyPin
        
        case 10: return .inDecoyMode
        
        case 11: return .mainSelectedWalletId
        
        case 12: return .decoySelectedWalletId
        
        case 13: return .lockedAt
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalConfigKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .selectedWalletId:
            writeInt(&buf, Int32(1))
        
        
        case .selectedNetwork:
            writeInt(&buf, Int32(2))
        
        
        case .selectedFiatCurrency:
            writeInt(&buf, Int32(3))
        
        
        case let .selectedNode(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNetwork.write(v1, into: &buf)
            
        
        case .colorScheme:
            writeInt(&buf, Int32(5))
        
        
        case .authType:
            writeInt(&buf, Int32(6))
        
        
        case .hashedPinCode:
            writeInt(&buf, Int32(7))
        
        
        case .wipeDataPin:
            writeInt(&buf, Int32(8))
        
        
        case .decoyPin:
            writeInt(&buf, Int32(9))
        
        
        case .inDecoyMode:
            writeInt(&buf, Int32(10))
        
        
        case .mainSelectedWalletId:
            writeInt(&buf, Int32(11))
        
        
        case .decoySelectedWalletId:
            writeInt(&buf, Int32(12))
        
        
        case .lockedAt:
            writeInt(&buf, Int32(13))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigKey_lift(_ buf: RustBuffer) throws -> GlobalConfigKey {
    return try FfiConverterTypeGlobalConfigKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigKey_lower(_ value: GlobalConfigKey) -> RustBuffer {
    return FfiConverterTypeGlobalConfigKey.lower(value)
}



public enum GlobalConfigTableError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Save(String
    )
    case Read(String
    )
    case PinCodeMustBeHashed

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_globalconfigtableerror_uniffi_trait_display(
            FfiConverterTypeGlobalConfigTableError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension GlobalConfigTableError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfigTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalConfigTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfigTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .PinCodeMustBeHashed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalConfigTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .PinCodeMustBeHashed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigTableError_lift(_ buf: RustBuffer) throws -> GlobalConfigTableError {
    return try FfiConverterTypeGlobalConfigTableError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfigTableError_lower(_ value: GlobalConfigTableError) -> RustBuffer {
    return FfiConverterTypeGlobalConfigTableError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GlobalFlagKey: Equatable, Hashable {
    
    case completedOnboarding
    case acceptedTerms





}

#if compiler(>=6)
extension GlobalFlagKey: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalFlagKey: FfiConverterRustBuffer {
    typealias SwiftType = GlobalFlagKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .completedOnboarding
        
        case 2: return .acceptedTerms
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalFlagKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .completedOnboarding:
            writeInt(&buf, Int32(1))
        
        
        case .acceptedTerms:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagKey_lift(_ buf: RustBuffer) throws -> GlobalFlagKey {
    return try FfiConverterTypeGlobalFlagKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagKey_lower(_ value: GlobalFlagKey) -> RustBuffer {
    return FfiConverterTypeGlobalFlagKey.lower(value)
}



public enum GlobalFlagTableError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Save(String
    )
    case Read(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_globalflagtableerror_uniffi_trait_display(
            FfiConverterTypeGlobalFlagTableError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension GlobalFlagTableError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalFlagTableError: FfiConverterRustBuffer {
    typealias SwiftType = GlobalFlagTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalFlagTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalFlagTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagTableError_lift(_ buf: RustBuffer) throws -> GlobalFlagTableError {
    return try FfiConverterTypeGlobalFlagTableError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalFlagTableError_lower(_ value: GlobalFlagTableError) -> RustBuffer {
    return FfiConverterTypeGlobalFlagTableError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Haptic feedback hint for the platform to trigger
 */

public enum HapticFeedback: Equatable, Hashable {
    
    /**
     * Light tap - new part scanned in multi-part QR
     */
    case progress
    /**
     * Success notification - scan complete (single or multi-part)
     */
    case success
    /**
     * No haptic feedback (duplicate part, no change)
     */
    case none





}

#if compiler(>=6)
extension HapticFeedback: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHapticFeedback: FfiConverterRustBuffer {
    typealias SwiftType = HapticFeedback

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HapticFeedback {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .progress
        
        case 2: return .success
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HapticFeedback, into buf: inout [UInt8]) {
        switch value {
        
        
        case .progress:
            writeInt(&buf, Int32(1))
        
        
        case .success:
            writeInt(&buf, Int32(2))
        
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHapticFeedback_lift(_ buf: RustBuffer) throws -> HapticFeedback {
    return try FfiConverterTypeHapticFeedback.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHapticFeedback_lower(_ value: HapticFeedback) -> RustBuffer {
    return FfiConverterTypeHapticFeedback.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HardwareWalletMetadata {
    
    case tapSigner(TapSigner
    )





}

#if compiler(>=6)
extension HardwareWalletMetadata: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHardwareWalletMetadata: FfiConverterRustBuffer {
    typealias SwiftType = HardwareWalletMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HardwareWalletMetadata {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .tapSigner(try FfiConverterTypeTapSigner.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HardwareWalletMetadata, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .tapSigner(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardwareWalletMetadata_lift(_ buf: RustBuffer) throws -> HardwareWalletMetadata {
    return try FfiConverterTypeHardwareWalletMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardwareWalletMetadata_lower(_ value: HardwareWalletMetadata) -> RustBuffer {
    return FfiConverterTypeHardwareWalletMetadata.lower(value)
}



/**
 * Error type for `HistoricalPriceRecord`
 */
public enum HistoricalPriceRecordError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case ConversionError(ByteReaderError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_historicalpricerecorderror_uniffi_trait_display(
            FfiConverterTypeHistoricalPriceRecordError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension HistoricalPriceRecordError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHistoricalPriceRecordError: FfiConverterRustBuffer {
    typealias SwiftType = HistoricalPriceRecordError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoricalPriceRecordError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ConversionError(
            try FfiConverterTypeByteReaderError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HistoricalPriceRecordError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ConversionError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeByteReaderError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceRecordError_lift(_ buf: RustBuffer) throws -> HistoricalPriceRecordError {
    return try FfiConverterTypeHistoricalPriceRecordError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceRecordError_lower(_ value: HistoricalPriceRecordError) -> RustBuffer {
    return FfiConverterTypeHistoricalPriceRecordError.lower(value)
}


public enum HistoricalPriceTableError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Save(String
    )
    case Read(String
    )
    case NoRecordFound

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_historicalpricetableerror_uniffi_trait_display(
            FfiConverterTypeHistoricalPriceTableError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension HistoricalPriceTableError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHistoricalPriceTableError: FfiConverterRustBuffer {
    typealias SwiftType = HistoricalPriceTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoricalPriceTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .NoRecordFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HistoricalPriceTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NoRecordFound:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceTableError_lift(_ buf: RustBuffer) throws -> HistoricalPriceTableError {
    return try FfiConverterTypeHistoricalPriceTableError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoricalPriceTableError_lower(_ value: HistoricalPriceTableError) -> RustBuffer {
    return FfiConverterTypeHistoricalPriceTableError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HotWalletRoute: Equatable, Hashable {
    
    case select
    case create(NumberOfBip39Words
    )
    case `import`(NumberOfBip39Words,ImportType
    )
    case verifyWords(WalletId
    )





}

#if compiler(>=6)
extension HotWalletRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHotWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = HotWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HotWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .select
        
        case 2: return .create(try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        )
        
        case 3: return .`import`(try FfiConverterTypeNumberOfBip39Words.read(from: &buf), try FfiConverterTypeImportType.read(from: &buf)
        )
        
        case 4: return .verifyWords(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HotWalletRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .select:
            writeInt(&buf, Int32(1))
        
        
        case let .create(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            
        
        case let .`import`(v1,v2):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            FfiConverterTypeImportType.write(v2, into: &buf)
            
        
        case let .verifyWords(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHotWalletRoute_lift(_ buf: RustBuffer) throws -> HotWalletRoute {
    return try FfiConverterTypeHotWalletRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHotWalletRoute_lower(_ value: HotWalletRoute) -> RustBuffer {
    return FfiConverterTypeHotWalletRoute.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportType: Equatable, Hashable {
    
    case manual
    case nfc
    case qr





}

#if compiler(>=6)
extension ImportType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportType: FfiConverterRustBuffer {
    typealias SwiftType = ImportType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .manual
        
        case 2: return .nfc
        
        case 3: return .qr
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .manual:
            writeInt(&buf, Int32(1))
        
        
        case .nfc:
            writeInt(&buf, Int32(2))
        
        
        case .qr:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportType_lift(_ buf: RustBuffer) throws -> ImportType {
    return try FfiConverterTypeImportType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportType_lower(_ value: ImportType) -> RustBuffer {
    return FfiConverterTypeImportType.lower(value)
}



public enum ImportWalletError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case WalletImportError(String
    )
    case InvalidWordGroup(String
    )
    case Keychain(KeychainError
    )
    case WalletAlreadyExists(WalletId
    )
    case Database(DatabaseError
    )
    case BdkError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_importwalleterror_uniffi_trait_display(
            FfiConverterTypeImportWalletError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ImportWalletError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletError: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .WalletImportError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidWordGroup(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Keychain(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 4: return .WalletAlreadyExists(
            try FfiConverterTypeWalletId.read(from: &buf)
            )
        case 5: return .Database(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 6: return .BdkError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .WalletImportError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidWordGroup(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Keychain(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .WalletAlreadyExists(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .Database(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .BdkError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletError_lift(_ buf: RustBuffer) throws -> ImportWalletError {
    return try FfiConverterTypeImportWalletError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletError_lower(_ value: ImportWalletError) -> RustBuffer {
    return FfiConverterTypeImportWalletError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportWalletManagerAction: Equatable, Hashable {
    
    case noOp





}

#if compiler(>=6)
extension ImportWalletManagerAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noOp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noOp:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerAction_lift(_ buf: RustBuffer) throws -> ImportWalletManagerAction {
    return try FfiConverterTypeImportWalletManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerAction_lower(_ value: ImportWalletManagerAction) -> RustBuffer {
    return FfiConverterTypeImportWalletManagerAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ImportWalletManagerReconcileMessage: Equatable, Hashable {
    
    case noOp





}

#if compiler(>=6)
extension ImportWalletManagerReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImportWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = ImportWalletManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImportWalletManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .noOp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ImportWalletManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .noOp:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> ImportWalletManagerReconcileMessage {
    return try FfiConverterTypeImportWalletManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImportWalletManagerReconcileMessage_lower(_ value: ImportWalletManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeImportWalletManagerReconcileMessage.lower(value)
}



public enum InitError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case RootDataDirAlreadySet(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension InitError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInitError: FfiConverterRustBuffer {
    typealias SwiftType = InitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RootDataDirAlreadySet(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InitError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .RootDataDirAlreadySet(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInitError_lift(_ buf: RustBuffer) throws -> InitError {
    return try FfiConverterTypeInitError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInitError_lower(_ value: InitError) -> RustBuffer {
    return FfiConverterTypeInitError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InsertOrUpdate: Equatable, Hashable {
    
    case insert(Timestamp
    )
    case update(Timestamp
    )





}

#if compiler(>=6)
extension InsertOrUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInsertOrUpdate: FfiConverterRustBuffer {
    typealias SwiftType = InsertOrUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InsertOrUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .insert(try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 2: return .update(try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InsertOrUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .insert(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTimestamp.write(v1, into: &buf)
            
        
        case let .update(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTimestamp.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertOrUpdate_lift(_ buf: RustBuffer) throws -> InsertOrUpdate {
    return try FfiConverterTypeInsertOrUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInsertOrUpdate_lower(_ value: InsertOrUpdate) -> RustBuffer {
    return FfiConverterTypeInsertOrUpdate.lower(value)
}



public enum LabelDbError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Database(DatabaseError
    )
    case UnsupportedLabelType(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_labeldberror_uniffi_trait_display(
            FfiConverterTypeLabelDbError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension LabelDbError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabelDbError: FfiConverterRustBuffer {
    typealias SwiftType = LabelDbError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelDbError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Database(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 2: return .UnsupportedLabelType(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LabelDbError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Database(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .UnsupportedLabelType(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelDbError_lift(_ buf: RustBuffer) throws -> LabelDbError {
    return try FfiConverterTypeLabelDbError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelDbError_lower(_ value: LabelDbError) -> RustBuffer {
    return FfiConverterTypeLabelDbError.lower(value)
}


public enum LabelManagerError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Parse(String
    )
    case Save(String
    )
    case Get(String
    )
    case Export(String
    )
    case GetInputRecords(String
    )
    case GetOutputRecords(String
    )
    case SaveInputLabels(String
    )
    case SaveOutputLabels(String
    )
    case DeleteLabels(String
    )
    case SaveAddressLabels(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_labelmanagererror_uniffi_trait_display(
            FfiConverterTypeLabelManagerError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension LabelManagerError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLabelManagerError: FfiConverterRustBuffer {
    typealias SwiftType = LabelManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LabelManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Parse(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Get(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Export(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .GetInputRecords(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .GetOutputRecords(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .SaveInputLabels(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .SaveOutputLabels(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .DeleteLabels(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .SaveAddressLabels(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LabelManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Parse(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Save(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Get(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Export(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .GetInputRecords(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .GetOutputRecords(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SaveInputLabels(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SaveOutputLabels(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DeleteLabels(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SaveAddressLabels(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelManagerError_lift(_ buf: RustBuffer) throws -> LabelManagerError {
    return try FfiConverterTypeLabelManagerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLabelManagerError_lower(_ value: LabelManagerError) -> RustBuffer {
    return FfiConverterTypeLabelManagerError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ListSortDirection: Equatable, Hashable {
    
    case ascending
    case descending





}

#if compiler(>=6)
extension ListSortDirection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListSortDirection: FfiConverterRustBuffer {
    typealias SwiftType = ListSortDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListSortDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ascending
        
        case 2: return .descending
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ListSortDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ascending:
            writeInt(&buf, Int32(1))
        
        
        case .descending:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListSortDirection_lift(_ buf: RustBuffer) throws -> ListSortDirection {
    return try FfiConverterTypeListSortDirection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListSortDirection_lower(_ value: ListSortDirection) -> RustBuffer {
    return FfiConverterTypeListSortDirection.lower(value)
}



public enum MnemonicError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case GetWalletKeychain(KeychainError
    )
    case NotAvailable(WalletId
    )
    case UnknownWord(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_mnemonicerror_uniffi_trait_display(
            FfiConverterTypeMnemonicError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension MnemonicError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .GetWalletKeychain(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 2: return .NotAvailable(
            try FfiConverterTypeWalletId.read(from: &buf)
            )
        case 3: return .UnknownWord(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .GetWalletKeychain(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .NotAvailable(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .UnknownWord(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicError_lift(_ buf: RustBuffer) throws -> MnemonicError {
    return try FfiConverterTypeMnemonicError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicError_lower(_ value: MnemonicError) -> RustBuffer {
    return FfiConverterTypeMnemonicError.lower(value)
}


public enum MnemonicParseError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidMnemonic(String,String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_mnemonicparseerror_uniffi_trait_display(
            FfiConverterTypeMnemonicParseError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension MnemonicParseError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicParseError: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMnemonic(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidMnemonic(v1,v2):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicParseError_lift(_ buf: RustBuffer) throws -> MnemonicParseError {
    return try FfiConverterTypeMnemonicParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicParseError_lower(_ value: MnemonicParseError) -> RustBuffer {
    return FfiConverterTypeMnemonicParseError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MultiFormat: Equatable {
    
    case address(AddressWithNetwork
    )
    case hardwareExport(HardwareExport
    )
    case mnemonic(Mnemonic
    )
    case transaction(BitcoinTransaction
    )
    case bip329Labels(Bip329Labels
    )
    /**
     * TAPSIGNER has not been initialized yet
     */
    case tapSignerReady(TapSigner
    )
    /**
     * TAPSIGNER has not been initialized yet
     */
    case tapSignerUnused(TapSigner
    )
    /**
     * A signed but un-finalized PSBT
     */
    case signedPsbt(Psbt
    )





// The local Rust `Eq` implementation - only `eq` is used.
public static func == (self: MultiFormat, other: MultiFormat) -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_cove_fn_method_multiformat_uniffi_trait_eq_eq(
            FfiConverterTypeMultiFormat_lower(self),
        FfiConverterTypeMultiFormat_lower(other),$0
    )
}
    )
}
}

#if compiler(>=6)
extension MultiFormat: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiFormat: FfiConverterRustBuffer {
    typealias SwiftType = MultiFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .address(try FfiConverterTypeAddressWithNetwork.read(from: &buf)
        )
        
        case 2: return .hardwareExport(try FfiConverterTypeHardwareExport.read(from: &buf)
        )
        
        case 3: return .mnemonic(try FfiConverterTypeMnemonic.read(from: &buf)
        )
        
        case 4: return .transaction(try FfiConverterTypeBitcoinTransaction.read(from: &buf)
        )
        
        case 5: return .bip329Labels(try FfiConverterTypeBip329Labels.read(from: &buf)
        )
        
        case 6: return .tapSignerReady(try FfiConverterTypeTapSigner.read(from: &buf)
        )
        
        case 7: return .tapSignerUnused(try FfiConverterTypeTapSigner.read(from: &buf)
        )
        
        case 8: return .signedPsbt(try FfiConverterTypePsbt.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .address(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddressWithNetwork.write(v1, into: &buf)
            
        
        case let .hardwareExport(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHardwareExport.write(v1, into: &buf)
            
        
        case let .mnemonic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMnemonic.write(v1, into: &buf)
            
        
        case let .transaction(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBitcoinTransaction.write(v1, into: &buf)
            
        
        case let .bip329Labels(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeBip329Labels.write(v1, into: &buf)
            
        
        case let .tapSignerReady(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            
        
        case let .tapSignerUnused(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            
        
        case let .signedPsbt(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypePsbt.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiFormat_lift(_ buf: RustBuffer) throws -> MultiFormat {
    return try FfiConverterTypeMultiFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiFormat_lower(_ value: MultiFormat) -> RustBuffer {
    return FfiConverterTypeMultiFormat.lower(value)
}



public enum MultiFormatError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidSeedQr(SeedQrError
    )
    case UnsupportedNetworkAddress
    case UnrecognizedFormat
    case InvalidTapSigner(TapCardParseError
    )
    case TaprootNotSupported

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_multiformaterror_uniffi_trait_display(
            FfiConverterTypeMultiFormatError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension MultiFormatError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiFormatError: FfiConverterRustBuffer {
    typealias SwiftType = MultiFormatError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiFormatError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSeedQr(
            try FfiConverterTypeSeedQrError.read(from: &buf)
            )
        case 2: return .UnsupportedNetworkAddress
        case 3: return .UnrecognizedFormat
        case 4: return .InvalidTapSigner(
            try FfiConverterTypeTapCardParseError.read(from: &buf)
            )
        case 5: return .TaprootNotSupported

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiFormatError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidSeedQr(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSeedQrError.write(v1, into: &buf)
            
        
        case .UnsupportedNetworkAddress:
            writeInt(&buf, Int32(2))
        
        
        case .UnrecognizedFormat:
            writeInt(&buf, Int32(3))
        
        
        case let .InvalidTapSigner(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTapCardParseError.write(v1, into: &buf)
            
        
        case .TaprootNotSupported:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiFormatError_lift(_ buf: RustBuffer) throws -> MultiFormatError {
    return try FfiConverterTypeMultiFormatError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiFormatError_lower(_ value: MultiFormatError) -> RustBuffer {
    return FfiConverterTypeMultiFormatError.lower(value)
}


public enum MultiQrError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case ParseError(String
    )
    case InvalidUtf8
    case RequiresStringData
    case InvalidSeedQr(SeedQrError
    )
    case Ur(UrError
    )
    case BbqrCborNotSupported

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_multiqrerror_uniffi_trait_display(
            FfiConverterTypeMultiQrError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension MultiQrError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMultiQrError: FfiConverterRustBuffer {
    typealias SwiftType = MultiQrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiQrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidUtf8
        case 3: return .RequiresStringData
        case 4: return .InvalidSeedQr(
            try FfiConverterTypeSeedQrError.read(from: &buf)
            )
        case 5: return .Ur(
            try FfiConverterTypeUrError.read(from: &buf)
            )
        case 6: return .BbqrCborNotSupported

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MultiQrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidUtf8:
            writeInt(&buf, Int32(2))
        
        
        case .RequiresStringData:
            writeInt(&buf, Int32(3))
        
        
        case let .InvalidSeedQr(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSeedQrError.write(v1, into: &buf)
            
        
        case let .Ur(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeUrError.write(v1, into: &buf)
            
        
        case .BbqrCborNotSupported:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiQrError_lift(_ buf: RustBuffer) throws -> MultiQrError {
    return try FfiConverterTypeMultiQrError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMultiQrError_lower(_ value: MultiQrError) -> RustBuffer {
    return FfiConverterTypeMultiQrError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NewWalletRoute: Equatable, Hashable {
    
    case select
    case hotWallet(HotWalletRoute
    )
    case coldWallet(ColdWalletRoute
    )





}

#if compiler(>=6)
extension NewWalletRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewWalletRoute: FfiConverterRustBuffer {
    typealias SwiftType = NewWalletRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewWalletRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .select
        
        case 2: return .hotWallet(try FfiConverterTypeHotWalletRoute.read(from: &buf)
        )
        
        case 3: return .coldWallet(try FfiConverterTypeColdWalletRoute.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NewWalletRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .select:
            writeInt(&buf, Int32(1))
        
        
        case let .hotWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHotWalletRoute.write(v1, into: &buf)
            
        
        case let .coldWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeColdWalletRoute.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewWalletRoute_lift(_ buf: RustBuffer) throws -> NewWalletRoute {
    return try FfiConverterTypeNewWalletRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewWalletRoute_lower(_ value: NewWalletRoute) -> RustBuffer {
    return FfiConverterTypeNewWalletRoute.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NodeSelection: Equatable, Hashable {
    
    case preset(Node
    )
    case custom(Node
    )





}

#if compiler(>=6)
extension NodeSelection: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeSelection: FfiConverterRustBuffer {
    typealias SwiftType = NodeSelection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .preset(try FfiConverterTypeNode.read(from: &buf)
        )
        
        case 2: return .custom(try FfiConverterTypeNode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeSelection, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .preset(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        
        case let .custom(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNode.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelection_lift(_ buf: RustBuffer) throws -> NodeSelection {
    return try FfiConverterTypeNodeSelection.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelection_lower(_ value: NodeSelection) -> RustBuffer {
    return FfiConverterTypeNodeSelection.lower(value)
}



public enum NodeSelectorError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case NodeNotFound(String
    )
    case SetSelectedNodeError(String
    )
    case NodeAccessError(String
    )
    case ParseNodeUrlError(String
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension NodeSelectorError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeSelectorError: FfiConverterRustBuffer {
    typealias SwiftType = NodeSelectorError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeSelectorError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NodeNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .SetSelectedNodeError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .NodeAccessError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .ParseNodeUrlError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeSelectorError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .NodeNotFound(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SetSelectedNodeError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NodeAccessError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ParseNodeUrlError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelectorError_lift(_ buf: RustBuffer) throws -> NodeSelectorError {
    return try FfiConverterTypeNodeSelectorError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeSelectorError_lower(_ value: NodeSelectorError) -> RustBuffer {
    return FfiConverterTypeNodeSelectorError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NumberOfBip39Words: Equatable, Hashable {
    
    case twelve
    case twentyFour





}

#if compiler(>=6)
extension NumberOfBip39Words: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNumberOfBip39Words: FfiConverterRustBuffer {
    typealias SwiftType = NumberOfBip39Words

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NumberOfBip39Words {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .twelve
        
        case 2: return .twentyFour
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NumberOfBip39Words, into buf: inout [UInt8]) {
        switch value {
        
        
        case .twelve:
            writeInt(&buf, Int32(1))
        
        
        case .twentyFour:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNumberOfBip39Words_lift(_ buf: RustBuffer) throws -> NumberOfBip39Words {
    return try FfiConverterTypeNumberOfBip39Words.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNumberOfBip39Words_lower(_ value: NumberOfBip39Words) -> RustBuffer {
    return FfiConverterTypeNumberOfBip39Words.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingOrConfirmed: Equatable, Hashable {
    
    case pending(PendingDetails
    )
    case confirmed(ConfirmedDetails
    )





}

#if compiler(>=6)
extension PendingOrConfirmed: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingOrConfirmed: FfiConverterRustBuffer {
    typealias SwiftType = PendingOrConfirmed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingOrConfirmed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending(try FfiConverterTypePendingDetails.read(from: &buf)
        )
        
        case 2: return .confirmed(try FfiConverterTypeConfirmedDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingOrConfirmed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pending(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypePendingDetails.write(v1, into: &buf)
            
        
        case let .confirmed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConfirmedDetails.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingOrConfirmed_lift(_ buf: RustBuffer) throws -> PendingOrConfirmed {
    return try FfiConverterTypePendingOrConfirmed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingOrConfirmed_lower(_ value: PendingOrConfirmed) -> RustBuffer {
    return FfiConverterTypePendingOrConfirmed.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletManagerAction: Equatable, Hashable {
    
    case updateWords(NumberOfBip39Words
    )





}

#if compiler(>=6)
extension PendingWalletManagerAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateWords(try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateWords(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerAction_lift(_ buf: RustBuffer) throws -> PendingWalletManagerAction {
    return try FfiConverterTypePendingWalletManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerAction_lower(_ value: PendingWalletManagerAction) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerAction.lower(value)
}



public enum PendingWalletManagerError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case BdkError(String
    )
    case Creation(WalletCreationError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_pendingwalletmanagererror_uniffi_trait_display(
            FfiConverterTypePendingWalletManagerError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension PendingWalletManagerError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerError: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BdkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Creation(
            try FfiConverterTypeWalletCreationError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Creation(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletCreationError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerError_lift(_ buf: RustBuffer) throws -> PendingWalletManagerError {
    return try FfiConverterTypePendingWalletManagerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerError_lower(_ value: PendingWalletManagerError) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingWalletManagerReconcileMessage: Equatable, Hashable {
    
    case words(NumberOfBip39Words
    )





}

#if compiler(>=6)
extension PendingWalletManagerReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = PendingWalletManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingWalletManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .words(try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingWalletManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .words(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNumberOfBip39Words.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> PendingWalletManagerReconcileMessage {
    return try FfiConverterTypePendingWalletManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingWalletManagerReconcileMessage_lower(_ value: PendingWalletManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypePendingWalletManagerReconcileMessage.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Route {
    
    case loadAndReset(resetTo: [BoxedRoute], afterMillis: UInt32
    )
    case selectedWallet(WalletId
    )
    case newWallet(NewWalletRoute
    )
    case settings(SettingsRoute
    )
    case secretWords(WalletId
    )
    case transactionDetails(id: WalletId, details: TransactionDetails
    )
    case send(SendRoute
    )
    case coinControl(CoinControlRoute
    )





}

#if compiler(>=6)
extension Route: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = Route

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Route {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loadAndReset(resetTo: try FfiConverterSequenceTypeBoxedRoute.read(from: &buf), afterMillis: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .selectedWallet(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        case 3: return .newWallet(try FfiConverterTypeNewWalletRoute.read(from: &buf)
        )
        
        case 4: return .settings(try FfiConverterTypeSettingsRoute.read(from: &buf)
        )
        
        case 5: return .secretWords(try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        case 6: return .transactionDetails(id: try FfiConverterTypeWalletId.read(from: &buf), details: try FfiConverterTypeTransactionDetails.read(from: &buf)
        )
        
        case 7: return .send(try FfiConverterTypeSendRoute.read(from: &buf)
        )
        
        case 8: return .coinControl(try FfiConverterTypeCoinControlRoute.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Route, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .loadAndReset(resetTo,afterMillis):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeBoxedRoute.write(resetTo, into: &buf)
            FfiConverterUInt32.write(afterMillis, into: &buf)
            
        
        case let .selectedWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .newWallet(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNewWalletRoute.write(v1, into: &buf)
            
        
        case let .settings(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSettingsRoute.write(v1, into: &buf)
            
        
        case let .secretWords(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .transactionDetails(id,details):
            writeInt(&buf, Int32(6))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeTransactionDetails.write(details, into: &buf)
            
        
        case let .send(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSendRoute.write(v1, into: &buf)
            
        
        case let .coinControl(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeCoinControlRoute.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoute_lift(_ buf: RustBuffer) throws -> Route {
    return try FfiConverterTypeRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoute_lower(_ value: Route) -> RustBuffer {
    return FfiConverterTypeRoute.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Progress information for multi-part QR scans
 */

public enum ScanProgress: Equatable, Hashable {
    
    /**
     * BBQR progress with scanned/total parts
     */
    case bbqr(scanned: UInt32, total: UInt32
    )
    /**
     * UR progress as percentage (0.0 to 1.0)
     */
    case ur(percentage: Double
    )



    /**
     * Detail text for the progress (e.g., "7 parts left"), or None for UR
     */
public func detailText() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_cove_fn_method_scanprogress_detail_text(
            FfiConverterTypeScanProgress_lower(self),$0
    )
})
}

    /**
     * Display text for the progress (e.g., "Scanned 3 of 10" or "Scanned 45%")
     */
public func displayText() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_method_scanprogress_display_text(
            FfiConverterTypeScanProgress_lower(self),$0
    )
})
}



}

#if compiler(>=6)
extension ScanProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanProgress: FfiConverterRustBuffer {
    typealias SwiftType = ScanProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bbqr(scanned: try FfiConverterUInt32.read(from: &buf), total: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .ur(percentage: try FfiConverterDouble.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScanProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bbqr(scanned,total):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(scanned, into: &buf)
            FfiConverterUInt32.write(total, into: &buf)
            
        
        case let .ur(percentage):
            writeInt(&buf, Int32(2))
            FfiConverterDouble.write(percentage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanProgress_lift(_ buf: RustBuffer) throws -> ScanProgress {
    return try FfiConverterTypeScanProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanProgress_lower(_ value: ScanProgress) -> RustBuffer {
    return FfiConverterTypeScanProgress.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of a QR scan - either complete with parsed data or in progress
 */

public enum ScanResult {
    
    /**
     * Scan complete - here's the parsed data
     */
    case complete(data: MultiFormat, 
        /**
         * Haptic feedback to trigger
         */haptic: HapticFeedback
    )
    /**
     * Multi-part scan in progress
     */
    case inProgress(progress: ScanProgress, 
        /**
         * Haptic feedback to trigger
         */haptic: HapticFeedback
    )





}

#if compiler(>=6)
extension ScanResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanResult: FfiConverterRustBuffer {
    typealias SwiftType = ScanResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .complete(data: try FfiConverterTypeMultiFormat.read(from: &buf), haptic: try FfiConverterTypeHapticFeedback.read(from: &buf)
        )
        
        case 2: return .inProgress(progress: try FfiConverterTypeScanProgress.read(from: &buf), haptic: try FfiConverterTypeHapticFeedback.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScanResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .complete(data,haptic):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMultiFormat.write(data, into: &buf)
            FfiConverterTypeHapticFeedback.write(haptic, into: &buf)
            
        
        case let .inProgress(progress,haptic):
            writeInt(&buf, Int32(2))
            FfiConverterTypeScanProgress.write(progress, into: &buf)
            FfiConverterTypeHapticFeedback.write(haptic, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanResult_lift(_ buf: RustBuffer) throws -> ScanResult {
    return try FfiConverterTypeScanResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanResult_lower(_ value: ScanResult) -> RustBuffer {
    return FfiConverterTypeScanResult.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ScanState: Equatable, Hashable {
    
    case notStarted
    case scanning(ScanningInfo
    )
    case completed





}

#if compiler(>=6)
extension ScanState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScanState: FfiConverterRustBuffer {
    typealias SwiftType = ScanState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notStarted
        
        case 2: return .scanning(try FfiConverterTypeScanningInfo.read(from: &buf)
        )
        
        case 3: return .completed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScanState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notStarted:
            writeInt(&buf, Int32(1))
        
        
        case let .scanning(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeScanningInfo.write(v1, into: &buf)
            
        
        case .completed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanState_lift(_ buf: RustBuffer) throws -> ScanState {
    return try FfiConverterTypeScanState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScanState_lower(_ value: ScanState) -> RustBuffer {
    return FfiConverterTypeScanState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ScannerResponse: Equatable, Hashable {
    
    case foundAddresses([FoundAddress]
    )
    case noneFound





}

#if compiler(>=6)
extension ScannerResponse: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeScannerResponse: FfiConverterRustBuffer {
    typealias SwiftType = ScannerResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScannerResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .foundAddresses(try FfiConverterSequenceTypeFoundAddress.read(from: &buf)
        )
        
        case 2: return .noneFound
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScannerResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .foundAddresses(v1):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeFoundAddress.write(v1, into: &buf)
            
        
        case .noneFound:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScannerResponse_lift(_ buf: RustBuffer) throws -> ScannerResponse {
    return try FfiConverterTypeScannerResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeScannerResponse_lower(_ value: ScannerResponse) -> RustBuffer {
    return FfiConverterTypeScannerResponse.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * What alert to show for validation messages
 */

public enum SecurityAlertState: Equatable, Hashable {
    
    case unverifiedWallets(walletId: WalletId
    )
    case confirmEnableWipeMePin
    case confirmDecoyPin
    case noteNoFaceIdWhenTrickPins
    case noteNoFaceIdWhenWipeMePin
    case noteNoFaceIdWhenDecoyPin
    case notePinRequired
    /**
     * Disabling biometric, then show confirm for wipe me PIN
     */
    case noteFaceIdDisablingForWipeMePin
    /**
     * Disabling biometric, then show confirm for decoy PIN
     */
    case noteFaceIdDisablingForDecoyPin
    case extraSetPinError(message: String
    )





}

#if compiler(>=6)
extension SecurityAlertState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityAlertState: FfiConverterRustBuffer {
    typealias SwiftType = SecurityAlertState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityAlertState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unverifiedWallets(walletId: try FfiConverterTypeWalletId.read(from: &buf)
        )
        
        case 2: return .confirmEnableWipeMePin
        
        case 3: return .confirmDecoyPin
        
        case 4: return .noteNoFaceIdWhenTrickPins
        
        case 5: return .noteNoFaceIdWhenWipeMePin
        
        case 6: return .noteNoFaceIdWhenDecoyPin
        
        case 7: return .notePinRequired
        
        case 8: return .noteFaceIdDisablingForWipeMePin
        
        case 9: return .noteFaceIdDisablingForDecoyPin
        
        case 10: return .extraSetPinError(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityAlertState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unverifiedWallets(walletId):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletId.write(walletId, into: &buf)
            
        
        case .confirmEnableWipeMePin:
            writeInt(&buf, Int32(2))
        
        
        case .confirmDecoyPin:
            writeInt(&buf, Int32(3))
        
        
        case .noteNoFaceIdWhenTrickPins:
            writeInt(&buf, Int32(4))
        
        
        case .noteNoFaceIdWhenWipeMePin:
            writeInt(&buf, Int32(5))
        
        
        case .noteNoFaceIdWhenDecoyPin:
            writeInt(&buf, Int32(6))
        
        
        case .notePinRequired:
            writeInt(&buf, Int32(7))
        
        
        case .noteFaceIdDisablingForWipeMePin:
            writeInt(&buf, Int32(8))
        
        
        case .noteFaceIdDisablingForDecoyPin:
            writeInt(&buf, Int32(9))
        
        
        case let .extraSetPinError(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityAlertState_lift(_ buf: RustBuffer) throws -> SecurityAlertState {
    return try FfiConverterTypeSecurityAlertState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityAlertState_lower(_ value: SecurityAlertState) -> RustBuffer {
    return FfiConverterTypeSecurityAlertState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Action the user wants to take on security settings
 */

public enum SecuritySettingsAction: Equatable, Hashable {
    
    case toggleBiometric(enable: Bool
    )
    case togglePin(enable: Bool
    )
    case toggleWipeDataPin(enable: Bool
    )
    case toggleDecoyPin(enable: Bool
    )
    case changePin





}

#if compiler(>=6)
extension SecuritySettingsAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecuritySettingsAction: FfiConverterRustBuffer {
    typealias SwiftType = SecuritySettingsAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuritySettingsAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toggleBiometric(enable: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .togglePin(enable: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .toggleWipeDataPin(enable: try FfiConverterBool.read(from: &buf)
        )
        
        case 4: return .toggleDecoyPin(enable: try FfiConverterBool.read(from: &buf)
        )
        
        case 5: return .changePin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecuritySettingsAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .toggleBiometric(enable):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(enable, into: &buf)
            
        
        case let .togglePin(enable):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(enable, into: &buf)
            
        
        case let .toggleWipeDataPin(enable):
            writeInt(&buf, Int32(3))
            FfiConverterBool.write(enable, into: &buf)
            
        
        case let .toggleDecoyPin(enable):
            writeInt(&buf, Int32(4))
            FfiConverterBool.write(enable, into: &buf)
            
        
        case .changePin:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuritySettingsAction_lift(_ buf: RustBuffer) throws -> SecuritySettingsAction {
    return try FfiConverterTypeSecuritySettingsAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuritySettingsAction_lower(_ value: SecuritySettingsAction) -> RustBuffer {
    return FfiConverterTypeSecuritySettingsAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of validating a security settings action
 */

public enum SecuritySettingsResult: Equatable, Hashable {
    
    /**
     * Proceed to show a sheet for PIN entry
     */
    case proceedToSheet(SecuritySheetState
    )
    /**
     * Show an alert dialog
     */
    case showAlert(SecurityAlertState
    )
    /**
     * Decoy mode - just update local UI, don't persist
     */
    case decoyModeLocalUpdate





}

#if compiler(>=6)
extension SecuritySettingsResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecuritySettingsResult: FfiConverterRustBuffer {
    typealias SwiftType = SecuritySettingsResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuritySettingsResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .proceedToSheet(try FfiConverterTypeSecuritySheetState.read(from: &buf)
        )
        
        case 2: return .showAlert(try FfiConverterTypeSecurityAlertState.read(from: &buf)
        )
        
        case 3: return .decoyModeLocalUpdate
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecuritySettingsResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .proceedToSheet(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecuritySheetState.write(v1, into: &buf)
            
        
        case let .showAlert(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurityAlertState.write(v1, into: &buf)
            
        
        case .decoyModeLocalUpdate:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuritySettingsResult_lift(_ buf: RustBuffer) throws -> SecuritySettingsResult {
    return try FfiConverterTypeSecuritySettingsResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuritySettingsResult_lower(_ value: SecuritySettingsResult) -> RustBuffer {
    return FfiConverterTypeSecuritySettingsResult.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * What sheet to show for PIN entry flows
 */

public enum SecuritySheetState: Equatable, Hashable {
    
    case none
    case newPin
    case removePin
    case changePin
    case enableBiometric
    case disableBiometric
    case enableWipeDataPin
    case removeWipeDataPin
    /**
     * Remove wipe data PIN, then enable biometric
     */
    case removeWipeDataPinThenEnableBiometric
    case enableDecoyPin
    case removeDecoyPin
    /**
     * Remove decoy PIN, then enable biometric
     */
    case removeDecoyPinThenEnableBiometric
    case removeAllTrickPins





}

#if compiler(>=6)
extension SecuritySheetState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecuritySheetState: FfiConverterRustBuffer {
    typealias SwiftType = SecuritySheetState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuritySheetState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .newPin
        
        case 3: return .removePin
        
        case 4: return .changePin
        
        case 5: return .enableBiometric
        
        case 6: return .disableBiometric
        
        case 7: return .enableWipeDataPin
        
        case 8: return .removeWipeDataPin
        
        case 9: return .removeWipeDataPinThenEnableBiometric
        
        case 10: return .enableDecoyPin
        
        case 11: return .removeDecoyPin
        
        case 12: return .removeDecoyPinThenEnableBiometric
        
        case 13: return .removeAllTrickPins
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecuritySheetState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .newPin:
            writeInt(&buf, Int32(2))
        
        
        case .removePin:
            writeInt(&buf, Int32(3))
        
        
        case .changePin:
            writeInt(&buf, Int32(4))
        
        
        case .enableBiometric:
            writeInt(&buf, Int32(5))
        
        
        case .disableBiometric:
            writeInt(&buf, Int32(6))
        
        
        case .enableWipeDataPin:
            writeInt(&buf, Int32(7))
        
        
        case .removeWipeDataPin:
            writeInt(&buf, Int32(8))
        
        
        case .removeWipeDataPinThenEnableBiometric:
            writeInt(&buf, Int32(9))
        
        
        case .enableDecoyPin:
            writeInt(&buf, Int32(10))
        
        
        case .removeDecoyPin:
            writeInt(&buf, Int32(11))
        
        
        case .removeDecoyPinThenEnableBiometric:
            writeInt(&buf, Int32(12))
        
        
        case .removeAllTrickPins:
            writeInt(&buf, Int32(13))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuritySheetState_lift(_ buf: RustBuffer) throws -> SecuritySheetState {
    return try FfiConverterTypeSecuritySheetState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuritySheetState_lower(_ value: SecuritySheetState) -> RustBuffer {
    return FfiConverterTypeSecuritySheetState.lower(value)
}



public enum SeedQrError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case ContainsNonNumericChars
    case IndexOutOfBounds(UInt16
    )
    case IncorrectWordLength(UInt16
    )
    case InvalidMnemonic(Bip39Error
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_seedqrerror_uniffi_trait_display(
            FfiConverterTypeSeedQrError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SeedQrError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSeedQrError: FfiConverterRustBuffer {
    typealias SwiftType = SeedQrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedQrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ContainsNonNumericChars
        case 2: return .IndexOutOfBounds(
            try FfiConverterUInt16.read(from: &buf)
            )
        case 3: return .IncorrectWordLength(
            try FfiConverterUInt16.read(from: &buf)
            )
        case 4: return .InvalidMnemonic(
            try FfiConverterTypeBip39Error.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SeedQrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ContainsNonNumericChars:
            writeInt(&buf, Int32(1))
        
        
        case let .IndexOutOfBounds(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(v1, into: &buf)
            
        
        case let .IncorrectWordLength(v1):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(v1, into: &buf)
            
        
        case let .InvalidMnemonic(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBip39Error.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedQrError_lift(_ buf: RustBuffer) throws -> SeedQrError {
    return try FfiConverterTypeSeedQrError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSeedQrError_lower(_ value: SeedQrError) -> RustBuffer {
    return FfiConverterTypeSeedQrError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendFlowAlertState: Equatable, Hashable {
    
    case error(SendFlowError
    )
    case general(title: String, message: String
    )





}

#if compiler(>=6)
extension SendFlowAlertState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowAlertState: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowAlertState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowAlertState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error(try FfiConverterTypeSendFlowError.read(from: &buf)
        )
        
        case 2: return .general(title: try FfiConverterString.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowAlertState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .error(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSendFlowError.write(v1, into: &buf)
            
        
        case let .general(title,message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(title, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowAlertState_lift(_ buf: RustBuffer) throws -> SendFlowAlertState {
    return try FfiConverterTypeSendFlowAlertState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowAlertState_lower(_ value: SendFlowAlertState) -> RustBuffer {
    return FfiConverterTypeSendFlowAlertState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendFlowEnterMode {
    
    case setAmount
    case coinControl(SendFlowCoinControlMode
    )





}

#if compiler(>=6)
extension SendFlowEnterMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowEnterMode: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowEnterMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowEnterMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setAmount
        
        case 2: return .coinControl(try FfiConverterTypeSendFlowCoinControlMode.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowEnterMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .setAmount:
            writeInt(&buf, Int32(1))
        
        
        case let .coinControl(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSendFlowCoinControlMode.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowEnterMode_lift(_ buf: RustBuffer) throws -> SendFlowEnterMode {
    return try FfiConverterTypeSendFlowEnterMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowEnterMode_lower(_ value: SendFlowEnterMode) -> RustBuffer {
    return FfiConverterTypeSendFlowEnterMode.lower(value)
}



public enum SendFlowError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case EmptyAddress
    case InvalidNumber
    case InvalidAddress(String
    )
    case WrongNetwork(address: String, validFor: Network, current: Network
    )
    case NoBalance
    case ZeroAmount
    case UnableToGetMaxSend(String
    )
    case InsufficientFunds
    case SendAmountToLow
    case UnableToGetFeeRate
    case UnableToBuildTxn(String
    )
    case UnableToSaveUnsignedTransaction(String
    )
    case WalletManager(WalletManagerError
    )
    case UnableToGetFeeDetails(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_sendflowerror_uniffi_trait_display(
            FfiConverterTypeSendFlowError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SendFlowError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowError: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .EmptyAddress
        case 2: return .InvalidNumber
        case 3: return .InvalidAddress(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .WrongNetwork(
            address: try FfiConverterString.read(from: &buf), 
            validFor: try FfiConverterTypeNetwork.read(from: &buf), 
            current: try FfiConverterTypeNetwork.read(from: &buf)
            )
        case 5: return .NoBalance
        case 6: return .ZeroAmount
        case 7: return .UnableToGetMaxSend(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .InsufficientFunds
        case 9: return .SendAmountToLow
        case 10: return .UnableToGetFeeRate
        case 11: return .UnableToBuildTxn(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .UnableToSaveUnsignedTransaction(
            try FfiConverterString.read(from: &buf)
            )
        case 13: return .WalletManager(
            try FfiConverterTypeWalletManagerError.read(from: &buf)
            )
        case 14: return .UnableToGetFeeDetails(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .EmptyAddress:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidNumber:
            writeInt(&buf, Int32(2))
        
        
        case let .InvalidAddress(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WrongNetwork(address,validFor,current):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(address, into: &buf)
            FfiConverterTypeNetwork.write(validFor, into: &buf)
            FfiConverterTypeNetwork.write(current, into: &buf)
            
        
        case .NoBalance:
            writeInt(&buf, Int32(5))
        
        
        case .ZeroAmount:
            writeInt(&buf, Int32(6))
        
        
        case let .UnableToGetMaxSend(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InsufficientFunds:
            writeInt(&buf, Int32(8))
        
        
        case .SendAmountToLow:
            writeInt(&buf, Int32(9))
        
        
        case .UnableToGetFeeRate:
            writeInt(&buf, Int32(10))
        
        
        case let .UnableToBuildTxn(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnableToSaveUnsignedTransaction(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WalletManager(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeWalletManagerError.write(v1, into: &buf)
            
        
        case let .UnableToGetFeeDetails(v1):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowError_lift(_ buf: RustBuffer) throws -> SendFlowError {
    return try FfiConverterTypeSendFlowError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowError_lower(_ value: SendFlowError) -> RustBuffer {
    return FfiConverterTypeSendFlowError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendFlowErrorAlert: Equatable, Hashable {
    
    case signAndBroadcast(String
    )
    case confirmDetails(String
    )





}

#if compiler(>=6)
extension SendFlowErrorAlert: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowErrorAlert: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowErrorAlert

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowErrorAlert {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .signAndBroadcast(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .confirmDetails(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowErrorAlert, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .signAndBroadcast(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .confirmDetails(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowErrorAlert_lift(_ buf: RustBuffer) throws -> SendFlowErrorAlert {
    return try FfiConverterTypeSendFlowErrorAlert.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowErrorAlert_lower(_ value: SendFlowErrorAlert) -> RustBuffer {
    return FfiConverterTypeSendFlowErrorAlert.lower(value)
}



public enum SendFlowFiatOnChangeError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidFiatAmount(error: String, input: String
    )
    case Converter(ConverterError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_sendflowfiatonchangeerror_uniffi_trait_display(
            FfiConverterTypeSendFlowFiatOnChangeError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SendFlowFiatOnChangeError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowFiatOnChangeError: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowFiatOnChangeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowFiatOnChangeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidFiatAmount(
            error: try FfiConverterString.read(from: &buf), 
            input: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Converter(
            try FfiConverterTypeConverterError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowFiatOnChangeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidFiatAmount(error,input):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)
            FfiConverterString.write(input, into: &buf)
            
        
        case let .Converter(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeConverterError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowFiatOnChangeError_lift(_ buf: RustBuffer) throws -> SendFlowFiatOnChangeError {
    return try FfiConverterTypeSendFlowFiatOnChangeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowFiatOnChangeError_lower(_ value: SendFlowFiatOnChangeError) -> RustBuffer {
    return FfiConverterTypeSendFlowFiatOnChangeError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendFlowManagerAction {
    
    case changeEnteringAddress(String
    )
    case changeSetAmountFocusField(SetAmountFocusField?
    )
    case selectMaxSend
    case clearSendAmount
    case clearAddress
    case setCoinControlMode([Utxo]
    )
    case disableCoinControlMode
    case selectFeeRate(FeeRateOptionWithTotalFee
    )
    case notifyEnteringBtcAmountChanged(String
    )
    case notifyEnteringFiatAmountChanged(String
    )
    case notifyEnteringAddressChanged(String
    )
    case notifySelectedUnitedChanged(old: BitcoinUnit, new: BitcoinUnit
    )
    case notifyBtcOrFiatChanged(old: FiatOrBtc, new: FiatOrBtc
    )
    case notifyScanCodeChanged(old: String, new: String
    )
    case notifyPricesChanged(PriceResponse
    )
    case notifyFocusFieldChanged(old: SetAmountFocusField?, new: SetAmountFocusField?
    )
    case notifyAddressChanged(Address
    )
    case notifyAmountChanged(Amount
    )
    case notifyCoinControlAmountChanged(Double
    )
    case notifyCoinControlEnteredAmountChanged(String,Bool
    )
    case changeFeeRateOptions(FeeRateOptionsWithTotalFee
    )
    case finalizeAndGoToNextScreen





}

#if compiler(>=6)
extension SendFlowManagerAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .changeEnteringAddress(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .changeSetAmountFocusField(try FfiConverterOptionTypeSetAmountFocusField.read(from: &buf)
        )
        
        case 3: return .selectMaxSend
        
        case 4: return .clearSendAmount
        
        case 5: return .clearAddress
        
        case 6: return .setCoinControlMode(try FfiConverterSequenceTypeUtxo.read(from: &buf)
        )
        
        case 7: return .disableCoinControlMode
        
        case 8: return .selectFeeRate(try FfiConverterTypeFeeRateOptionWithTotalFee.read(from: &buf)
        )
        
        case 9: return .notifyEnteringBtcAmountChanged(try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .notifyEnteringFiatAmountChanged(try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .notifyEnteringAddressChanged(try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .notifySelectedUnitedChanged(old: try FfiConverterTypeBitcoinUnit.read(from: &buf), new: try FfiConverterTypeBitcoinUnit.read(from: &buf)
        )
        
        case 13: return .notifyBtcOrFiatChanged(old: try FfiConverterTypeFiatOrBtc.read(from: &buf), new: try FfiConverterTypeFiatOrBtc.read(from: &buf)
        )
        
        case 14: return .notifyScanCodeChanged(old: try FfiConverterString.read(from: &buf), new: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .notifyPricesChanged(try FfiConverterTypePriceResponse.read(from: &buf)
        )
        
        case 16: return .notifyFocusFieldChanged(old: try FfiConverterOptionTypeSetAmountFocusField.read(from: &buf), new: try FfiConverterOptionTypeSetAmountFocusField.read(from: &buf)
        )
        
        case 17: return .notifyAddressChanged(try FfiConverterTypeAddress.read(from: &buf)
        )
        
        case 18: return .notifyAmountChanged(try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 19: return .notifyCoinControlAmountChanged(try FfiConverterDouble.read(from: &buf)
        )
        
        case 20: return .notifyCoinControlEnteredAmountChanged(try FfiConverterString.read(from: &buf), try FfiConverterBool.read(from: &buf)
        )
        
        case 21: return .changeFeeRateOptions(try FfiConverterTypeFeeRateOptionsWithTotalFee.read(from: &buf)
        )
        
        case 22: return .finalizeAndGoToNextScreen
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .changeEnteringAddress(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .changeSetAmountFocusField(v1):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeSetAmountFocusField.write(v1, into: &buf)
            
        
        case .selectMaxSend:
            writeInt(&buf, Int32(3))
        
        
        case .clearSendAmount:
            writeInt(&buf, Int32(4))
        
        
        case .clearAddress:
            writeInt(&buf, Int32(5))
        
        
        case let .setCoinControlMode(v1):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeUtxo.write(v1, into: &buf)
            
        
        case .disableCoinControlMode:
            writeInt(&buf, Int32(7))
        
        
        case let .selectFeeRate(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeFeeRateOptionWithTotalFee.write(v1, into: &buf)
            
        
        case let .notifyEnteringBtcAmountChanged(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .notifyEnteringFiatAmountChanged(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .notifyEnteringAddressChanged(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .notifySelectedUnitedChanged(old,new):
            writeInt(&buf, Int32(12))
            FfiConverterTypeBitcoinUnit.write(old, into: &buf)
            FfiConverterTypeBitcoinUnit.write(new, into: &buf)
            
        
        case let .notifyBtcOrFiatChanged(old,new):
            writeInt(&buf, Int32(13))
            FfiConverterTypeFiatOrBtc.write(old, into: &buf)
            FfiConverterTypeFiatOrBtc.write(new, into: &buf)
            
        
        case let .notifyScanCodeChanged(old,new):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(old, into: &buf)
            FfiConverterString.write(new, into: &buf)
            
        
        case let .notifyPricesChanged(v1):
            writeInt(&buf, Int32(15))
            FfiConverterTypePriceResponse.write(v1, into: &buf)
            
        
        case let .notifyFocusFieldChanged(old,new):
            writeInt(&buf, Int32(16))
            FfiConverterOptionTypeSetAmountFocusField.write(old, into: &buf)
            FfiConverterOptionTypeSetAmountFocusField.write(new, into: &buf)
            
        
        case let .notifyAddressChanged(v1):
            writeInt(&buf, Int32(17))
            FfiConverterTypeAddress.write(v1, into: &buf)
            
        
        case let .notifyAmountChanged(v1):
            writeInt(&buf, Int32(18))
            FfiConverterTypeAmount.write(v1, into: &buf)
            
        
        case let .notifyCoinControlAmountChanged(v1):
            writeInt(&buf, Int32(19))
            FfiConverterDouble.write(v1, into: &buf)
            
        
        case let .notifyCoinControlEnteredAmountChanged(v1,v2):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterBool.write(v2, into: &buf)
            
        
        case let .changeFeeRateOptions(v1):
            writeInt(&buf, Int32(21))
            FfiConverterTypeFeeRateOptionsWithTotalFee.write(v1, into: &buf)
            
        
        case .finalizeAndGoToNextScreen:
            writeInt(&buf, Int32(22))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowManagerAction_lift(_ buf: RustBuffer) throws -> SendFlowManagerAction {
    return try FfiConverterTypeSendFlowManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowManagerAction_lower(_ value: SendFlowManagerAction) -> RustBuffer {
    return FfiConverterTypeSendFlowManagerAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendFlowManagerReconcileMessage {
    
    case updateEnteringBtcAmount(String
    )
    case updateEnteringFiatAmount(String
    )
    case updateEnteringAddress(String
    )
    case updateAddress(Address?
    )
    case setMaxSelected(Amount
    )
    case unsetMaxSelected
    case updateAmountSats(UInt64
    )
    case updateAmountFiat(Double
    )
    case updateFocusField(SetAmountFocusField?
    )
    case updateSelectedFeeRate(FeeRateOptionWithTotalFee
    )
    case updateFeeRateOptions(FeeRateOptionsWithTotalFee
    )
    case refreshPresenters
    case setAlert(SendFlowAlertState
    )
    case clearAlert





}

#if compiler(>=6)
extension SendFlowManagerReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendFlowManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = SendFlowManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFlowManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateEnteringBtcAmount(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .updateEnteringFiatAmount(try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .updateEnteringAddress(try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .updateAddress(try FfiConverterOptionTypeAddress.read(from: &buf)
        )
        
        case 5: return .setMaxSelected(try FfiConverterTypeAmount.read(from: &buf)
        )
        
        case 6: return .unsetMaxSelected
        
        case 7: return .updateAmountSats(try FfiConverterUInt64.read(from: &buf)
        )
        
        case 8: return .updateAmountFiat(try FfiConverterDouble.read(from: &buf)
        )
        
        case 9: return .updateFocusField(try FfiConverterOptionTypeSetAmountFocusField.read(from: &buf)
        )
        
        case 10: return .updateSelectedFeeRate(try FfiConverterTypeFeeRateOptionWithTotalFee.read(from: &buf)
        )
        
        case 11: return .updateFeeRateOptions(try FfiConverterTypeFeeRateOptionsWithTotalFee.read(from: &buf)
        )
        
        case 12: return .refreshPresenters
        
        case 13: return .setAlert(try FfiConverterTypeSendFlowAlertState.read(from: &buf)
        )
        
        case 14: return .clearAlert
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendFlowManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateEnteringBtcAmount(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .updateEnteringFiatAmount(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .updateEnteringAddress(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .updateAddress(v1):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypeAddress.write(v1, into: &buf)
            
        
        case let .setMaxSelected(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAmount.write(v1, into: &buf)
            
        
        case .unsetMaxSelected:
            writeInt(&buf, Int32(6))
        
        
        case let .updateAmountSats(v1):
            writeInt(&buf, Int32(7))
            FfiConverterUInt64.write(v1, into: &buf)
            
        
        case let .updateAmountFiat(v1):
            writeInt(&buf, Int32(8))
            FfiConverterDouble.write(v1, into: &buf)
            
        
        case let .updateFocusField(v1):
            writeInt(&buf, Int32(9))
            FfiConverterOptionTypeSetAmountFocusField.write(v1, into: &buf)
            
        
        case let .updateSelectedFeeRate(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeFeeRateOptionWithTotalFee.write(v1, into: &buf)
            
        
        case let .updateFeeRateOptions(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeFeeRateOptionsWithTotalFee.write(v1, into: &buf)
            
        
        case .refreshPresenters:
            writeInt(&buf, Int32(12))
        
        
        case let .setAlert(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSendFlowAlertState.write(v1, into: &buf)
            
        
        case .clearAlert:
            writeInt(&buf, Int32(14))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> SendFlowManagerReconcileMessage {
    return try FfiConverterTypeSendFlowManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendFlowManagerReconcileMessage_lower(_ value: SendFlowManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeSendFlowManagerReconcileMessage.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SendRoute {
    
    case setAmount(id: WalletId, address: Address?, amount: Amount?
    )
    case coinControlSetAmount(id: WalletId, utxos: [Utxo]
    )
    case hardwareExport(id: WalletId, details: ConfirmDetails
    )
    case confirm(SendRouteConfirmArgs
    )





}

#if compiler(>=6)
extension SendRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendRoute: FfiConverterRustBuffer {
    typealias SwiftType = SendRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setAmount(id: try FfiConverterTypeWalletId.read(from: &buf), address: try FfiConverterOptionTypeAddress.read(from: &buf), amount: try FfiConverterOptionTypeAmount.read(from: &buf)
        )
        
        case 2: return .coinControlSetAmount(id: try FfiConverterTypeWalletId.read(from: &buf), utxos: try FfiConverterSequenceTypeUtxo.read(from: &buf)
        )
        
        case 3: return .hardwareExport(id: try FfiConverterTypeWalletId.read(from: &buf), details: try FfiConverterTypeConfirmDetails.read(from: &buf)
        )
        
        case 4: return .confirm(try FfiConverterTypeSendRouteConfirmArgs.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .setAmount(id,address,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterOptionTypeAddress.write(address, into: &buf)
            FfiConverterOptionTypeAmount.write(amount, into: &buf)
            
        
        case let .coinControlSetAmount(id,utxos):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterSequenceTypeUtxo.write(utxos, into: &buf)
            
        
        case let .hardwareExport(id,details):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeConfirmDetails.write(details, into: &buf)
            
        
        case let .confirm(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSendRouteConfirmArgs.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendRoute_lift(_ buf: RustBuffer) throws -> SendRoute {
    return try FfiConverterTypeSendRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendRoute_lower(_ value: SendRoute) -> RustBuffer {
    return FfiConverterTypeSendRoute.lower(value)
}



public enum SerdeError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case SerializationError(String
    )
    case DeserializationError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_serdeerror_uniffi_trait_display(
            FfiConverterTypeSerdeError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SerdeError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSerdeError: FfiConverterRustBuffer {
    typealias SwiftType = SerdeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SerdeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializationError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .DeserializationError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SerdeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SerializationError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DeserializationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSerdeError_lift(_ buf: RustBuffer) throws -> SerdeError {
    return try FfiConverterTypeSerdeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSerdeError_lower(_ value: SerdeError) -> RustBuffer {
    return FfiConverterTypeSerdeError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SetAmountFocusField: Equatable, Hashable {
    
    case amount
    case address





}

#if compiler(>=6)
extension SetAmountFocusField: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetAmountFocusField: FfiConverterRustBuffer {
    typealias SwiftType = SetAmountFocusField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetAmountFocusField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount
        
        case 2: return .address
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SetAmountFocusField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .amount:
            writeInt(&buf, Int32(1))
        
        
        case .address:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetAmountFocusField_lift(_ buf: RustBuffer) throws -> SetAmountFocusField {
    return try FfiConverterTypeSetAmountFocusField.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetAmountFocusField_lower(_ value: SetAmountFocusField) -> RustBuffer {
    return FfiConverterTypeSetAmountFocusField.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SettingsRoute: Equatable, Hashable {
    
    case main
    case network
    case appearance
    case node
    case fiatCurrency
    case wallet(id: WalletId, route: WalletSettingsRoute
    )
    case allWallets





}

#if compiler(>=6)
extension SettingsRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSettingsRoute: FfiConverterRustBuffer {
    typealias SwiftType = SettingsRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SettingsRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        case 2: return .network
        
        case 3: return .appearance
        
        case 4: return .node
        
        case 5: return .fiatCurrency
        
        case 6: return .wallet(id: try FfiConverterTypeWalletId.read(from: &buf), route: try FfiConverterTypeWalletSettingsRoute.read(from: &buf)
        )
        
        case 7: return .allWallets
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SettingsRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        
        case .network:
            writeInt(&buf, Int32(2))
        
        
        case .appearance:
            writeInt(&buf, Int32(3))
        
        
        case .node:
            writeInt(&buf, Int32(4))
        
        
        case .fiatCurrency:
            writeInt(&buf, Int32(5))
        
        
        case let .wallet(id,route):
            writeInt(&buf, Int32(6))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterTypeWalletSettingsRoute.write(route, into: &buf)
            
        
        case .allWallets:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSettingsRoute_lift(_ buf: RustBuffer) throws -> SettingsRoute {
    return try FfiConverterTypeSettingsRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSettingsRoute_lower(_ value: SettingsRoute) -> RustBuffer {
    return FfiConverterTypeSettingsRoute.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SetupCmdResponse {
    
    case continueFromInit(ContinueFromInit
    )
    case continueFromBackup(ContinueFromBackup
    )
    case continueFromDerive(ContinueFromDerive
    )
    case complete(TapSignerSetupComplete
    )





}

#if compiler(>=6)
extension SetupCmdResponse: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetupCmdResponse: FfiConverterRustBuffer {
    typealias SwiftType = SetupCmdResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetupCmdResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .continueFromInit(try FfiConverterTypeContinueFromInit.read(from: &buf)
        )
        
        case 2: return .continueFromBackup(try FfiConverterTypeContinueFromBackup.read(from: &buf)
        )
        
        case 3: return .continueFromDerive(try FfiConverterTypeContinueFromDerive.read(from: &buf)
        )
        
        case 4: return .complete(try FfiConverterTypeTapSignerSetupComplete.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SetupCmdResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .continueFromInit(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeContinueFromInit.write(v1, into: &buf)
            
        
        case let .continueFromBackup(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeContinueFromBackup.write(v1, into: &buf)
            
        
        case let .continueFromDerive(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeContinueFromDerive.write(v1, into: &buf)
            
        
        case let .complete(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTapSignerSetupComplete.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetupCmdResponse_lift(_ buf: RustBuffer) throws -> SetupCmdResponse {
    return try FfiConverterTypeSetupCmdResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSetupCmdResponse_lower(_ value: SetupCmdResponse) -> RustBuffer {
    return FfiConverterTypeSetupCmdResponse.lower(value)
}



public enum SignedImportError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case HexDecodeError(message: String)
    
    case Base64DecodeError(message: String)
    
    case PsbtParseError(message: String)
    
    case UnrecognizedFormat(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SignedImportError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedImportError: FfiConverterRustBuffer {
    typealias SwiftType = SignedImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HexDecodeError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Base64DecodeError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .PsbtParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .UnrecognizedFormat(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignedImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .HexDecodeError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Base64DecodeError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .PsbtParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .UnrecognizedFormat(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedImportError_lift(_ buf: RustBuffer) throws -> SignedImportError {
    return try FfiConverterTypeSignedImportError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedImportError_lower(_ value: SignedImportError) -> RustBuffer {
    return FfiConverterTypeSignedImportError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of parsing a signed transaction import
 *
 * Hardware wallets may return either a signed PSBT or a finalized transaction.
 * This enum allows callers to handle both cases appropriately.
 */

public enum SignedTransactionOrPsbt {
    
    /**
     * A finalized raw Bitcoin transaction
     */
    case transaction(BitcoinTransaction
    )
    /**
     * A signed but un-finalized PSBT (requires finalization before broadcast)
     */
    case signedPsbt(Psbt
    )



    /**
     * Returns true if this is a signed PSBT
     */
public func isPsbt() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_signedtransactionorpsbt_ispsbt(
            FfiConverterTypeSignedTransactionOrPsbt_lower(self),$0
    )
})
}

    /**
     * Returns true if this is a finalized transaction
     */
public func isTransaction() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_method_signedtransactionorpsbt_istransaction(
            FfiConverterTypeSignedTransactionOrPsbt_lower(self),$0
    )
})
}

    /**
     * Get the inner PSBT (returns None if Transaction)
     */
public func psbt() -> Psbt?  {
    return try!  FfiConverterOptionTypePsbt.lift(try! rustCall() {
    uniffi_cove_fn_method_signedtransactionorpsbt_psbt(
            FfiConverterTypeSignedTransactionOrPsbt_lower(self),$0
    )
})
}

    /**
     * Get the inner transaction (returns None if PSBT)
     */
public func transaction() -> BitcoinTransaction?  {
    return try!  FfiConverterOptionTypeBitcoinTransaction.lift(try! rustCall() {
    uniffi_cove_fn_method_signedtransactionorpsbt_transaction(
            FfiConverterTypeSignedTransactionOrPsbt_lower(self),$0
    )
})
}

    /**
     * Get the transaction ID
     */
public func txId() -> TxId  {
    return try!  FfiConverterTypeTxId_lift(try! rustCall() {
    uniffi_cove_fn_method_signedtransactionorpsbt_txid(
            FfiConverterTypeSignedTransactionOrPsbt_lower(self),$0
    )
})
}



}

#if compiler(>=6)
extension SignedTransactionOrPsbt: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedTransactionOrPsbt: FfiConverterRustBuffer {
    typealias SwiftType = SignedTransactionOrPsbt

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedTransactionOrPsbt {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .transaction(try FfiConverterTypeBitcoinTransaction.read(from: &buf)
        )
        
        case 2: return .signedPsbt(try FfiConverterTypePsbt.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignedTransactionOrPsbt, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .transaction(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinTransaction.write(v1, into: &buf)
            
        
        case let .signedPsbt(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePsbt.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedTransactionOrPsbt_lift(_ buf: RustBuffer) throws -> SignedTransactionOrPsbt {
    return try FfiConverterTypeSignedTransactionOrPsbt.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedTransactionOrPsbt_lower(_ value: SignedTransactionOrPsbt) -> RustBuffer {
    return FfiConverterTypeSignedTransactionOrPsbt.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum StoreType: Equatable, Hashable {
    
    case sqlite
    case fileStore





}

#if compiler(>=6)
extension StoreType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStoreType: FfiConverterRustBuffer {
    typealias SwiftType = StoreType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StoreType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sqlite
        
        case 2: return .fileStore
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StoreType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sqlite:
            writeInt(&buf, Int32(1))
        
        
        case .fileStore:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStoreType_lift(_ buf: RustBuffer) throws -> StoreType {
    return try FfiConverterTypeStoreType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStoreType_lower(_ value: StoreType) -> RustBuffer {
    return FfiConverterTypeStoreType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A string or data, could be a string or data (bytes)
 */

public enum StringOrData: Equatable, Hashable {
    
    case string(String
    )
    case data(Data
    )





}

#if compiler(>=6)
extension StringOrData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStringOrData: FfiConverterRustBuffer {
    typealias SwiftType = StringOrData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StringOrData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .data(try FfiConverterData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StringOrData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .data(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStringOrData_lift(_ buf: RustBuffer) throws -> StringOrData {
    return try FfiConverterTypeStringOrData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStringOrData_lower(_ value: StringOrData) -> RustBuffer {
    return FfiConverterTypeStringOrData.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TapSignerCmd {
    
    case setup(SetupCmd
    )
    case backup(pin: String
    )
    case derive(pin: String
    )
    case change(currentPin: String, newPin: String
    )
    case sign(psbt: Psbt, pin: String
    )





}

#if compiler(>=6)
extension TapSignerCmd: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerCmd: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerCmd

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerCmd {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setup(try FfiConverterTypeSetupCmd.read(from: &buf)
        )
        
        case 2: return .backup(pin: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .derive(pin: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .change(currentPin: try FfiConverterString.read(from: &buf), newPin: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .sign(psbt: try FfiConverterTypePsbt.read(from: &buf), pin: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapSignerCmd, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .setup(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSetupCmd.write(v1, into: &buf)
            
        
        case let .backup(pin):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(pin, into: &buf)
            
        
        case let .derive(pin):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(pin, into: &buf)
            
        
        case let .change(currentPin,newPin):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(currentPin, into: &buf)
            FfiConverterString.write(newPin, into: &buf)
            
        
        case let .sign(psbt,pin):
            writeInt(&buf, Int32(5))
            FfiConverterTypePsbt.write(psbt, into: &buf)
            FfiConverterString.write(pin, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerCmd_lift(_ buf: RustBuffer) throws -> TapSignerCmd {
    return try FfiConverterTypeTapSignerCmd.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerCmd_lower(_ value: TapSignerCmd) -> RustBuffer {
    return FfiConverterTypeTapSignerCmd.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * When the user goes through entering the PIN and setting a new one, they are either setting up a new tapsigner
 * or changing the PIN on an existing one
 */

public enum TapSignerPinAction: Equatable, Hashable {
    
    case setup
    case change





}

#if compiler(>=6)
extension TapSignerPinAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerPinAction: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerPinAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerPinAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setup
        
        case 2: return .change
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapSignerPinAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .setup:
            writeInt(&buf, Int32(1))
        
        
        case .change:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerPinAction_lift(_ buf: RustBuffer) throws -> TapSignerPinAction {
    return try FfiConverterTypeTapSignerPinAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerPinAction_lower(_ value: TapSignerPinAction) -> RustBuffer {
    return FfiConverterTypeTapSignerPinAction.lower(value)
}



public enum TapSignerReaderError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case TapSignerError(TransportError
    )
    case PsbtSignError(String
    )
    case ExtractTxError(String
    )
    case UnknownCardType(String
    )
    case NoCommand
    case InvalidPinLength(UInt8
    )
    case NonNumericPin(String
    )
    case SetupAlreadyComplete
    case InvalidChainCodeLength(UInt32
    )
    case Unknown(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_tapsignerreadererror_uniffi_trait_display(
            FfiConverterTypeTapSignerReaderError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension TapSignerReaderError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerReaderError: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerReaderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerReaderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .TapSignerError(
            try FfiConverterTypeTransportError.read(from: &buf)
            )
        case 2: return .PsbtSignError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .ExtractTxError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .UnknownCardType(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .NoCommand
        case 6: return .InvalidPinLength(
            try FfiConverterUInt8.read(from: &buf)
            )
        case 7: return .NonNumericPin(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .SetupAlreadyComplete
        case 9: return .InvalidChainCodeLength(
            try FfiConverterUInt32.read(from: &buf)
            )
        case 10: return .Unknown(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapSignerReaderError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .TapSignerError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTransportError.write(v1, into: &buf)
            
        
        case let .PsbtSignError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ExtractTxError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnknownCardType(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NoCommand:
            writeInt(&buf, Int32(5))
        
        
        case let .InvalidPinLength(v1):
            writeInt(&buf, Int32(6))
            FfiConverterUInt8.write(v1, into: &buf)
            
        
        case let .NonNumericPin(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .SetupAlreadyComplete:
            writeInt(&buf, Int32(8))
        
        
        case let .InvalidChainCodeLength(v1):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(v1, into: &buf)
            
        
        case let .Unknown(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerReaderError_lift(_ buf: RustBuffer) throws -> TapSignerReaderError {
    return try FfiConverterTypeTapSignerReaderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerReaderError_lower(_ value: TapSignerReaderError) -> RustBuffer {
    return FfiConverterTypeTapSignerReaderError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TapSignerResponse {
    
    case setup(SetupCmdResponse
    )
    case backup(Data
    )
    case `import`(DeriveInfo
    )
    case change
    case sign(Psbt
    )





}

#if compiler(>=6)
extension TapSignerResponse: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerResponse: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .setup(try FfiConverterTypeSetupCmdResponse.read(from: &buf)
        )
        
        case 2: return .backup(try FfiConverterData.read(from: &buf)
        )
        
        case 3: return .`import`(try FfiConverterTypeDeriveInfo.read(from: &buf)
        )
        
        case 4: return .change
        
        case 5: return .sign(try FfiConverterTypePsbt.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapSignerResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .setup(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSetupCmdResponse.write(v1, into: &buf)
            
        
        case let .backup(v1):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(v1, into: &buf)
            
        
        case let .`import`(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDeriveInfo.write(v1, into: &buf)
            
        
        case .change:
            writeInt(&buf, Int32(4))
        
        
        case let .sign(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePsbt.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerResponse_lift(_ buf: RustBuffer) throws -> TapSignerResponse {
    return try FfiConverterTypeTapSignerResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerResponse_lower(_ value: TapSignerResponse) -> RustBuffer {
    return FfiConverterTypeTapSignerResponse.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TapSignerRoute {
    
    case initSelect(TapSigner
    )
    case initAdvanced(TapSigner
    )
    case startingPin(tapSigner: TapSigner, chainCode: String?
    )
    case newPin(TapSignerNewPinArgs
    )
    case confirmPin(TapSignerConfirmPinArgs
    )
    case setupSuccess(TapSigner,TapSignerSetupComplete
    )
    case setupRetry(TapSigner,SetupCmdResponse
    )
    case importSuccess(TapSigner,DeriveInfo
    )
    case importRetry(TapSigner
    )
    case enterPin(tapSigner: TapSigner, action: AfterPinAction
    )





}

#if compiler(>=6)
extension TapSignerRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTapSignerRoute: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TapSignerRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initSelect(try FfiConverterTypeTapSigner.read(from: &buf)
        )
        
        case 2: return .initAdvanced(try FfiConverterTypeTapSigner.read(from: &buf)
        )
        
        case 3: return .startingPin(tapSigner: try FfiConverterTypeTapSigner.read(from: &buf), chainCode: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .newPin(try FfiConverterTypeTapSignerNewPinArgs.read(from: &buf)
        )
        
        case 5: return .confirmPin(try FfiConverterTypeTapSignerConfirmPinArgs.read(from: &buf)
        )
        
        case 6: return .setupSuccess(try FfiConverterTypeTapSigner.read(from: &buf), try FfiConverterTypeTapSignerSetupComplete.read(from: &buf)
        )
        
        case 7: return .setupRetry(try FfiConverterTypeTapSigner.read(from: &buf), try FfiConverterTypeSetupCmdResponse.read(from: &buf)
        )
        
        case 8: return .importSuccess(try FfiConverterTypeTapSigner.read(from: &buf), try FfiConverterTypeDeriveInfo.read(from: &buf)
        )
        
        case 9: return .importRetry(try FfiConverterTypeTapSigner.read(from: &buf)
        )
        
        case 10: return .enterPin(tapSigner: try FfiConverterTypeTapSigner.read(from: &buf), action: try FfiConverterTypeAfterPinAction.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TapSignerRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .initSelect(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            
        
        case let .initAdvanced(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            
        
        case let .startingPin(tapSigner,chainCode):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTapSigner.write(tapSigner, into: &buf)
            FfiConverterOptionString.write(chainCode, into: &buf)
            
        
        case let .newPin(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTapSignerNewPinArgs.write(v1, into: &buf)
            
        
        case let .confirmPin(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeTapSignerConfirmPinArgs.write(v1, into: &buf)
            
        
        case let .setupSuccess(v1,v2):
            writeInt(&buf, Int32(6))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            FfiConverterTypeTapSignerSetupComplete.write(v2, into: &buf)
            
        
        case let .setupRetry(v1,v2):
            writeInt(&buf, Int32(7))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            FfiConverterTypeSetupCmdResponse.write(v2, into: &buf)
            
        
        case let .importSuccess(v1,v2):
            writeInt(&buf, Int32(8))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            FfiConverterTypeDeriveInfo.write(v2, into: &buf)
            
        
        case let .importRetry(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeTapSigner.write(v1, into: &buf)
            
        
        case let .enterPin(tapSigner,action):
            writeInt(&buf, Int32(10))
            FfiConverterTypeTapSigner.write(tapSigner, into: &buf)
            FfiConverterTypeAfterPinAction.write(action, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerRoute_lift(_ buf: RustBuffer) throws -> TapSignerRoute {
    return try FfiConverterTypeTapSignerRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTapSignerRoute_lower(_ value: TapSignerRoute) -> RustBuffer {
    return FfiConverterTypeTapSignerRoute.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Transaction {
    
    case confirmed(ConfirmedTransaction
    )
    case unconfirmed(UnconfirmedTransaction
    )





}

#if compiler(>=6)
extension Transaction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .confirmed(try FfiConverterTypeConfirmedTransaction.read(from: &buf)
        )
        
        case 2: return .unconfirmed(try FfiConverterTypeUnconfirmedTransaction.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .confirmed(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeConfirmedTransaction.write(v1, into: &buf)
            
        
        case let .unconfirmed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnconfirmedTransaction.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}



public enum TransactionDetailError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Fee(String
    )
    case FeeRate(String
    )
    case Address(AddressError
    )
    case FiatAmount(String
    )
    case ChangeAddress(String
    )
    case NotFound

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_transactiondetailerror_uniffi_trait_display(
            FfiConverterTypeTransactionDetailError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension TransactionDetailError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDetailError: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDetailError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetailError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Fee(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .FeeRate(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Address(
            try FfiConverterTypeAddressError.read(from: &buf)
            )
        case 4: return .FiatAmount(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .ChangeAddress(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .NotFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionDetailError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Fee(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .FeeRate(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Address(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAddressError.write(v1, into: &buf)
            
        
        case let .FiatAmount(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ChangeAddress(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NotFound:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetailError_lift(_ buf: RustBuffer) throws -> TransactionDetailError {
    return try FfiConverterTypeTransactionDetailError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetailError_lower(_ value: TransactionDetailError) -> RustBuffer {
    return FfiConverterTypeTransactionDetailError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionState: Equatable, Hashable {
    
    case pending
    case confirmed





}

#if compiler(>=6)
extension TransactionState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionState: FfiConverterRustBuffer {
    typealias SwiftType = TransactionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .confirmed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .confirmed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionState_lift(_ buf: RustBuffer) throws -> TransactionState {
    return try FfiConverterTypeTransactionState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionState_lower(_ value: TransactionState) -> RustBuffer {
    return FfiConverterTypeTransactionState.lower(value)
}



public enum TransportError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case CiborDe(String
    )
    case CiborValue(String
    )
    case CkTap(CkTapError
    )
    case IncorrectSignature(String
    )
    case UnknownCardType(String
    )
    case CvcChangeError(String
    )
    case UnknownError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_transporterror_uniffi_trait_display(
            FfiConverterTypeTransportError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension TransportError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransportError: FfiConverterRustBuffer {
    typealias SwiftType = TransportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CiborDe(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .CiborValue(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .CkTap(
            try FfiConverterTypeCkTapError.read(from: &buf)
            )
        case 4: return .IncorrectSignature(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnknownCardType(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .CvcChangeError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .UnknownError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransportError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .CiborDe(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CiborValue(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CkTap(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCkTapError.write(v1, into: &buf)
            
        
        case let .IncorrectSignature(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnknownCardType(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CvcChangeError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnknownError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransportError_lift(_ buf: RustBuffer) throws -> TransportError {
    return try FfiConverterTypeTransportError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransportError_lower(_ value: TransportError) -> RustBuffer {
    return FfiConverterTypeTransportError.lower(value)
}


public enum TrickPinError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * Unable to set trick PIN, because PIN is not enabled
     */
    case PinNotEnabled
    /**
     * Unable to set trick PIN, because its the same as the current pin
     */
    case SameAsCurrentPin
    /**
     * Unable to set trick PIN, its the same as another PIN
     */
    case SameAsAnotherPin
    /**
     * Unable to set trick PIN, because biometrics is enabled
     */
    case BiometricsEnabled

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension TrickPinError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrickPinError: FfiConverterRustBuffer {
    typealias SwiftType = TrickPinError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrickPinError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PinNotEnabled
        case 2: return .SameAsCurrentPin
        case 3: return .SameAsAnotherPin
        case 4: return .BiometricsEnabled

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TrickPinError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .PinNotEnabled:
            writeInt(&buf, Int32(1))
        
        
        case .SameAsCurrentPin:
            writeInt(&buf, Int32(2))
        
        
        case .SameAsAnotherPin:
            writeInt(&buf, Int32(3))
        
        
        case .BiometricsEnabled:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrickPinError_lift(_ buf: RustBuffer) throws -> TrickPinError {
    return try FfiConverterTypeTrickPinError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrickPinError_lower(_ value: TrickPinError) -> RustBuffer {
    return FfiConverterTypeTrickPinError.lower(value)
}


public enum UnsignedTransactionsTableError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Save(String
    )
    case Read(String
    )
    case NoRecordFound

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_unsignedtransactionstableerror_uniffi_trait_display(
            FfiConverterTypeUnsignedTransactionsTableError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension UnsignedTransactionsTableError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsignedTransactionsTableError: FfiConverterRustBuffer {
    typealias SwiftType = UnsignedTransactionsTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedTransactionsTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Save(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Read(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .NoRecordFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnsignedTransactionsTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Save(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NoRecordFound:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionsTableError_lift(_ buf: RustBuffer) throws -> UnsignedTransactionsTableError {
    return try FfiConverterTypeUnsignedTransactionsTableError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsignedTransactionsTableError_lower(_ value: UnsignedTransactionsTableError) -> RustBuffer {
    return FfiConverterTypeUnsignedTransactionsTableError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported UR types for Bitcoin operations
 */

public enum UrType: Equatable, Hashable {
    
    /**
     * crypto-psbt - Partially Signed Bitcoin Transaction
     */
    case cryptoPsbt
    /**
     * crypto-seed - BIP39 seed
     */
    case cryptoSeed
    /**
     * crypto-hdkey - HD key (xpub/xprv)
     */
    case cryptoHdkey
    /**
     * crypto-account - Account descriptor
     */
    case cryptoAccount
    /**
     * crypto-output - Output descriptor
     */
    case cryptoOutput
    /**
     * bytes - Raw bytes
     */
    case bytes
    /**
     * Unknown type with raw string
     */
    case unknown(String
    )





}

#if compiler(>=6)
extension UrType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrType: FfiConverterRustBuffer {
    typealias SwiftType = UrType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .cryptoPsbt
        
        case 2: return .cryptoSeed
        
        case 3: return .cryptoHdkey
        
        case 4: return .cryptoAccount
        
        case 5: return .cryptoOutput
        
        case 6: return .bytes
        
        case 7: return .unknown(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .cryptoPsbt:
            writeInt(&buf, Int32(1))
        
        
        case .cryptoSeed:
            writeInt(&buf, Int32(2))
        
        
        case .cryptoHdkey:
            writeInt(&buf, Int32(3))
        
        
        case .cryptoAccount:
            writeInt(&buf, Int32(4))
        
        
        case .cryptoOutput:
            writeInt(&buf, Int32(5))
        
        
        case .bytes:
            writeInt(&buf, Int32(6))
        
        
        case let .unknown(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrType_lift(_ buf: RustBuffer) throws -> UrType {
    return try FfiConverterTypeUrType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrType_lower(_ value: UrType) -> RustBuffer {
    return FfiConverterTypeUrType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletAddressType: Equatable, Hashable, CustomStringConvertible {
    
    case nativeSegwit
    case wrappedSegwit
    case legacy





// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletaddresstype_uniffi_trait_display(
            FfiConverterTypeWalletAddressType_lower(self),$0
    )
}
    )
}
}

#if compiler(>=6)
extension WalletAddressType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletAddressType: FfiConverterRustBuffer {
    typealias SwiftType = WalletAddressType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletAddressType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nativeSegwit
        
        case 2: return .wrappedSegwit
        
        case 3: return .legacy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletAddressType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nativeSegwit:
            writeInt(&buf, Int32(1))
        
        
        case .wrappedSegwit:
            writeInt(&buf, Int32(2))
        
        
        case .legacy:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletAddressType_lift(_ buf: RustBuffer) throws -> WalletAddressType {
    return try FfiConverterTypeWalletAddressType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletAddressType_lower(_ value: WalletAddressType) -> RustBuffer {
    return FfiConverterTypeWalletAddressType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletColor: Equatable, Hashable {
    
    case red
    case blue
    case green
    case yellow
    case orange
    case purple
    case pink
    case coolGray
    case custom(r: UInt8, g: UInt8, b: UInt8
    )
    case wAlmostGray
    case wAlmostWhite
    case wBeige
    case wPastelBlue
    case wPastelNavy
    case wPastelRed
    case wPastelYellow
    case wLightMint
    case wPastelTeal
    case wLightPastelYellow





}

#if compiler(>=6)
extension WalletColor: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletColor: FfiConverterRustBuffer {
    typealias SwiftType = WalletColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red
        
        case 2: return .blue
        
        case 3: return .green
        
        case 4: return .yellow
        
        case 5: return .orange
        
        case 6: return .purple
        
        case 7: return .pink
        
        case 8: return .coolGray
        
        case 9: return .custom(r: try FfiConverterUInt8.read(from: &buf), g: try FfiConverterUInt8.read(from: &buf), b: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 10: return .wAlmostGray
        
        case 11: return .wAlmostWhite
        
        case 12: return .wBeige
        
        case 13: return .wPastelBlue
        
        case 14: return .wPastelNavy
        
        case 15: return .wPastelRed
        
        case 16: return .wPastelYellow
        
        case 17: return .wLightMint
        
        case 18: return .wPastelTeal
        
        case 19: return .wLightPastelYellow
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case .red:
            writeInt(&buf, Int32(1))
        
        
        case .blue:
            writeInt(&buf, Int32(2))
        
        
        case .green:
            writeInt(&buf, Int32(3))
        
        
        case .yellow:
            writeInt(&buf, Int32(4))
        
        
        case .orange:
            writeInt(&buf, Int32(5))
        
        
        case .purple:
            writeInt(&buf, Int32(6))
        
        
        case .pink:
            writeInt(&buf, Int32(7))
        
        
        case .coolGray:
            writeInt(&buf, Int32(8))
        
        
        case let .custom(r,g,b):
            writeInt(&buf, Int32(9))
            FfiConverterUInt8.write(r, into: &buf)
            FfiConverterUInt8.write(g, into: &buf)
            FfiConverterUInt8.write(b, into: &buf)
            
        
        case .wAlmostGray:
            writeInt(&buf, Int32(10))
        
        
        case .wAlmostWhite:
            writeInt(&buf, Int32(11))
        
        
        case .wBeige:
            writeInt(&buf, Int32(12))
        
        
        case .wPastelBlue:
            writeInt(&buf, Int32(13))
        
        
        case .wPastelNavy:
            writeInt(&buf, Int32(14))
        
        
        case .wPastelRed:
            writeInt(&buf, Int32(15))
        
        
        case .wPastelYellow:
            writeInt(&buf, Int32(16))
        
        
        case .wLightMint:
            writeInt(&buf, Int32(17))
        
        
        case .wPastelTeal:
            writeInt(&buf, Int32(18))
        
        
        case .wLightPastelYellow:
            writeInt(&buf, Int32(19))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletColor_lift(_ buf: RustBuffer) throws -> WalletColor {
    return try FfiConverterTypeWalletColor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletColor_lower(_ value: WalletColor) -> RustBuffer {
    return FfiConverterTypeWalletColor.lower(value)
}



public enum WalletCreationError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Bdk(String
    )
    case Keychain(KeychainError
    )
    case Database(DatabaseError
    )
    case Persist(String
    )
    case Import(String
    )
    case MultiFormat(MultiFormatError
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletcreationerror_uniffi_trait_display(
            FfiConverterTypeWalletCreationError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension WalletCreationError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletCreationError: FfiConverterRustBuffer {
    typealias SwiftType = WalletCreationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletCreationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Bdk(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Keychain(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 3: return .Database(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 4: return .Persist(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Import(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .MultiFormat(
            try FfiConverterTypeMultiFormatError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletCreationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Bdk(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Keychain(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .Database(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .Persist(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Import(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .MultiFormat(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeMultiFormatError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletCreationError_lift(_ buf: RustBuffer) throws -> WalletCreationError {
    return try FfiConverterTypeWalletCreationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletCreationError_lower(_ value: WalletCreationError) -> RustBuffer {
    return FfiConverterTypeWalletCreationError.lower(value)
}


public enum WalletDataError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case DatabaseAccess(id: WalletId, error: String
    )
    case TableAccess(id: WalletId, error: String
    )
    case Read(String
    )
    case Save(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletdataerror_uniffi_trait_display(
            FfiConverterTypeWalletDataError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension WalletDataError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletDataError: FfiConverterRustBuffer {
    typealias SwiftType = WalletDataError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletDataError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DatabaseAccess(
            id: try FfiConverterTypeWalletId.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .TableAccess(
            id: try FfiConverterTypeWalletId.read(from: &buf), 
            error: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Read(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Save(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletDataError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DatabaseAccess(id,error):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .TableAccess(id,error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletId.write(id, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Read(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Save(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataError_lift(_ buf: RustBuffer) throws -> WalletDataError {
    return try FfiConverterTypeWalletDataError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataError_lower(_ value: WalletDataError) -> RustBuffer {
    return FfiConverterTypeWalletDataError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletDataKey: Equatable, Hashable {
    
    case scanState(WalletAddressType
    )





}

#if compiler(>=6)
extension WalletDataKey: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletDataKey: FfiConverterRustBuffer {
    typealias SwiftType = WalletDataKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletDataKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .scanState(try FfiConverterTypeWalletAddressType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletDataKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .scanState(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletAddressType.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataKey_lift(_ buf: RustBuffer) throws -> WalletDataKey {
    return try FfiConverterTypeWalletDataKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletDataKey_lower(_ value: WalletDataKey) -> RustBuffer {
    return FfiConverterTypeWalletDataKey.lower(value)
}



public enum WalletError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case BdkError(String
    )
    case UnsupportedWallet(String
    )
    case PersistError(String
    )
    case LoadError(String
    )
    case Keychain(KeychainError
    )
    case Database(DatabaseError
    )
    case WalletNotFound
    case MetadataNotFound
    case ParseXpubError(XpubError
    )
    case WalletAlreadyExists(WalletId
    )
    case MultiFormat(MultiFormatError
    )
    case DescriptorKeyParseError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walleterror_uniffi_trait_display(
            FfiConverterTypeWalletError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension WalletError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletError: FfiConverterRustBuffer {
    typealias SwiftType = WalletError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BdkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnsupportedWallet(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .PersistError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .LoadError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Keychain(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 6: return .Database(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 7: return .WalletNotFound
        case 8: return .MetadataNotFound
        case 9: return .ParseXpubError(
            try FfiConverterTypeXpubError.read(from: &buf)
            )
        case 10: return .WalletAlreadyExists(
            try FfiConverterTypeWalletId.read(from: &buf)
            )
        case 11: return .MultiFormat(
            try FfiConverterTypeMultiFormatError.read(from: &buf)
            )
        case 12: return .DescriptorKeyParseError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .BdkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnsupportedWallet(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PersistError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .LoadError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Keychain(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .Database(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case .WalletNotFound:
            writeInt(&buf, Int32(7))
        
        
        case .MetadataNotFound:
            writeInt(&buf, Int32(8))
        
        
        case let .ParseXpubError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeXpubError.write(v1, into: &buf)
            
        
        case let .WalletAlreadyExists(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        
        case let .MultiFormat(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeMultiFormatError.write(v1, into: &buf)
            
        
        case let .DescriptorKeyParseError(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletError_lift(_ buf: RustBuffer) throws -> WalletError {
    return try FfiConverterTypeWalletError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletError_lower(_ value: WalletError) -> RustBuffer {
    return FfiConverterTypeWalletError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletErrorAlert: Equatable, Hashable {
    
    case nodeConnectionFailed(String
    )
    case noBalance





}

#if compiler(>=6)
extension WalletErrorAlert: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletErrorAlert: FfiConverterRustBuffer {
    typealias SwiftType = WalletErrorAlert

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletErrorAlert {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nodeConnectionFailed(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .noBalance
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletErrorAlert, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .nodeConnectionFailed(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .noBalance:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletErrorAlert_lift(_ buf: RustBuffer) throws -> WalletErrorAlert {
    return try FfiConverterTypeWalletErrorAlert.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletErrorAlert_lower(_ value: WalletErrorAlert) -> RustBuffer {
    return FfiConverterTypeWalletErrorAlert.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletLoadState {
    
    case loading
    case scanning([Transaction]
    )
    case loaded([Transaction]
    )





}

#if compiler(>=6)
extension WalletLoadState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletLoadState: FfiConverterRustBuffer {
    typealias SwiftType = WalletLoadState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletLoadState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loading
        
        case 2: return .scanning(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 3: return .loaded(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletLoadState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .loading:
            writeInt(&buf, Int32(1))
        
        
        case let .scanning(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletLoadState_lift(_ buf: RustBuffer) throws -> WalletLoadState {
    return try FfiConverterTypeWalletLoadState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletLoadState_lower(_ value: WalletLoadState) -> RustBuffer {
    return FfiConverterTypeWalletLoadState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletManagerAction {
    
    case updateName(String
    )
    case updateColor(WalletColor
    )
    case updateUnit(BitcoinUnit
    )
    case updateFiatOrBtc(FiatOrBtc
    )
    case toggleSensitiveVisibility
    case toggleDetailsExpanded
    case toggleFiatOrBtc
    case toggleFiatBtcPrimarySecondary
    case toggleShowLabels
    case selectCurrentWalletAddressType
    case selectDifferentWalletAddressType(WalletAddressType
    )
    case selectedWalletDisappeared
    case startTransactionWatcher(TxId
    )





}

#if compiler(>=6)
extension WalletManagerAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletManagerAction: FfiConverterRustBuffer {
    typealias SwiftType = WalletManagerAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletManagerAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .updateName(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .updateColor(try FfiConverterTypeWalletColor.read(from: &buf)
        )
        
        case 3: return .updateUnit(try FfiConverterTypeBitcoinUnit.read(from: &buf)
        )
        
        case 4: return .updateFiatOrBtc(try FfiConverterTypeFiatOrBtc.read(from: &buf)
        )
        
        case 5: return .toggleSensitiveVisibility
        
        case 6: return .toggleDetailsExpanded
        
        case 7: return .toggleFiatOrBtc
        
        case 8: return .toggleFiatBtcPrimarySecondary
        
        case 9: return .toggleShowLabels
        
        case 10: return .selectCurrentWalletAddressType
        
        case 11: return .selectDifferentWalletAddressType(try FfiConverterTypeWalletAddressType.read(from: &buf)
        )
        
        case 12: return .selectedWalletDisappeared
        
        case 13: return .startTransactionWatcher(try FfiConverterTypeTxId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletManagerAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .updateName(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .updateColor(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletColor.write(v1, into: &buf)
            
        
        case let .updateUnit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBitcoinUnit.write(v1, into: &buf)
            
        
        case let .updateFiatOrBtc(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFiatOrBtc.write(v1, into: &buf)
            
        
        case .toggleSensitiveVisibility:
            writeInt(&buf, Int32(5))
        
        
        case .toggleDetailsExpanded:
            writeInt(&buf, Int32(6))
        
        
        case .toggleFiatOrBtc:
            writeInt(&buf, Int32(7))
        
        
        case .toggleFiatBtcPrimarySecondary:
            writeInt(&buf, Int32(8))
        
        
        case .toggleShowLabels:
            writeInt(&buf, Int32(9))
        
        
        case .selectCurrentWalletAddressType:
            writeInt(&buf, Int32(10))
        
        
        case let .selectDifferentWalletAddressType(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeWalletAddressType.write(v1, into: &buf)
            
        
        case .selectedWalletDisappeared:
            writeInt(&buf, Int32(12))
        
        
        case let .startTransactionWatcher(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeTxId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerAction_lift(_ buf: RustBuffer) throws -> WalletManagerAction {
    return try FfiConverterTypeWalletManagerAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerAction_lower(_ value: WalletManagerAction) -> RustBuffer {
    return FfiConverterTypeWalletManagerAction.lower(value)
}



public enum WalletManagerError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case GetSelectedWalletError(String
    )
    case WalletDoesNotExist
    case SecretRetrievalError(KeychainError
    )
    case MarkWalletAsVerifiedError(DatabaseError
    )
    case LoadWalletError(WalletError
    )
    case NodeConnectionFailed(String
    )
    case WalletScanError(String
    )
    case TransactionsRetrievalError(String
    )
    case WalletBalanceError(String
    )
    case NextAddressError(String
    )
    case GetHeightError
    case TransactionDetailsError(String
    )
    case ActorNotFound
    case UnableToSwitch(WalletAddressType,String
    )
    case FiatError(String
    )
    case FeesError(String
    )
    case BuildTxError(String
    )
    case InsufficientFunds(String
    )
    case GetConfirmDetailsError(String
    )
    case SignAndBroadcastError(String
    )
    case Converter(ConverterError
    )
    case UnknownError(String
    )
    case PsbtFinalizeError(String
    )
    case GetHistoricalPricesError(String
    )
    case CsvCreationError(String
    )
    case AddUtxosError(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletmanagererror_uniffi_trait_display(
            FfiConverterTypeWalletManagerError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension WalletManagerError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletManagerError: FfiConverterRustBuffer {
    typealias SwiftType = WalletManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .GetSelectedWalletError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .WalletDoesNotExist
        case 3: return .SecretRetrievalError(
            try FfiConverterTypeKeychainError.read(from: &buf)
            )
        case 4: return .MarkWalletAsVerifiedError(
            try FfiConverterTypeDatabaseError.read(from: &buf)
            )
        case 5: return .LoadWalletError(
            try FfiConverterTypeWalletError.read(from: &buf)
            )
        case 6: return .NodeConnectionFailed(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .WalletScanError(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .TransactionsRetrievalError(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .WalletBalanceError(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .NextAddressError(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .GetHeightError
        case 12: return .TransactionDetailsError(
            try FfiConverterString.read(from: &buf)
            )
        case 13: return .ActorNotFound
        case 14: return .UnableToSwitch(
            try FfiConverterTypeWalletAddressType.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 15: return .FiatError(
            try FfiConverterString.read(from: &buf)
            )
        case 16: return .FeesError(
            try FfiConverterString.read(from: &buf)
            )
        case 17: return .BuildTxError(
            try FfiConverterString.read(from: &buf)
            )
        case 18: return .InsufficientFunds(
            try FfiConverterString.read(from: &buf)
            )
        case 19: return .GetConfirmDetailsError(
            try FfiConverterString.read(from: &buf)
            )
        case 20: return .SignAndBroadcastError(
            try FfiConverterString.read(from: &buf)
            )
        case 21: return .Converter(
            try FfiConverterTypeConverterError.read(from: &buf)
            )
        case 22: return .UnknownError(
            try FfiConverterString.read(from: &buf)
            )
        case 23: return .PsbtFinalizeError(
            try FfiConverterString.read(from: &buf)
            )
        case 24: return .GetHistoricalPricesError(
            try FfiConverterString.read(from: &buf)
            )
        case 25: return .CsvCreationError(
            try FfiConverterString.read(from: &buf)
            )
        case 26: return .AddUtxosError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .GetSelectedWalletError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .WalletDoesNotExist:
            writeInt(&buf, Int32(2))
        
        
        case let .SecretRetrievalError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeKeychainError.write(v1, into: &buf)
            
        
        case let .MarkWalletAsVerifiedError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDatabaseError.write(v1, into: &buf)
            
        
        case let .LoadWalletError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeWalletError.write(v1, into: &buf)
            
        
        case let .NodeConnectionFailed(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WalletScanError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .TransactionsRetrievalError(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .WalletBalanceError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NextAddressError(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .GetHeightError:
            writeInt(&buf, Int32(11))
        
        
        case let .TransactionDetailsError(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .ActorNotFound:
            writeInt(&buf, Int32(13))
        
        
        case let .UnableToSwitch(v1,v2):
            writeInt(&buf, Int32(14))
            FfiConverterTypeWalletAddressType.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        
        case let .FiatError(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .FeesError(v1):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .BuildTxError(v1):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InsufficientFunds(v1):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .GetConfirmDetailsError(v1):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SignAndBroadcastError(v1):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Converter(v1):
            writeInt(&buf, Int32(21))
            FfiConverterTypeConverterError.write(v1, into: &buf)
            
        
        case let .UnknownError(v1):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PsbtFinalizeError(v1):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .GetHistoricalPricesError(v1):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CsvCreationError(v1):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .AddUtxosError(v1):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerError_lift(_ buf: RustBuffer) throws -> WalletManagerError {
    return try FfiConverterTypeWalletManagerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerError_lower(_ value: WalletManagerError) -> RustBuffer {
    return FfiConverterTypeWalletManagerError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletManagerReconcileMessage {
    
    case startedInitialFullScan
    case startedExpandedFullScan([Transaction]
    )
    case availableTransactions([Transaction]
    )
    case scanComplete([Transaction]
    )
    case updatedTransactions([Transaction]
    )
    case nodeConnectionFailed(String
    )
    case walletMetadataChanged(WalletMetadata
    )
    case walletBalanceChanged(Balance
    )
    case walletError(WalletManagerError
    )
    case unknownError(String
    )
    case walletScannerResponse(ScannerResponse
    )
    case unsignedTransactionsChanged
    case sendFlowError(SendFlowErrorAlert
    )





}

#if compiler(>=6)
extension WalletManagerReconcileMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = WalletManagerReconcileMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletManagerReconcileMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .startedInitialFullScan
        
        case 2: return .startedExpandedFullScan(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 3: return .availableTransactions(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 4: return .scanComplete(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 5: return .updatedTransactions(try FfiConverterSequenceTypeTransaction.read(from: &buf)
        )
        
        case 6: return .nodeConnectionFailed(try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .walletMetadataChanged(try FfiConverterTypeWalletMetadata.read(from: &buf)
        )
        
        case 8: return .walletBalanceChanged(try FfiConverterTypeBalance.read(from: &buf)
        )
        
        case 9: return .walletError(try FfiConverterTypeWalletManagerError.read(from: &buf)
        )
        
        case 10: return .unknownError(try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .walletScannerResponse(try FfiConverterTypeScannerResponse.read(from: &buf)
        )
        
        case 12: return .unsignedTransactionsChanged
        
        case 13: return .sendFlowError(try FfiConverterTypeSendFlowErrorAlert.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletManagerReconcileMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .startedInitialFullScan:
            writeInt(&buf, Int32(1))
        
        
        case let .startedExpandedFullScan(v1):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .availableTransactions(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .scanComplete(v1):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .updatedTransactions(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeTransaction.write(v1, into: &buf)
            
        
        case let .nodeConnectionFailed(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .walletMetadataChanged(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeWalletMetadata.write(v1, into: &buf)
            
        
        case let .walletBalanceChanged(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeBalance.write(v1, into: &buf)
            
        
        case let .walletError(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeWalletManagerError.write(v1, into: &buf)
            
        
        case let .unknownError(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .walletScannerResponse(v1):
            writeInt(&buf, Int32(11))
            FfiConverterTypeScannerResponse.write(v1, into: &buf)
            
        
        case .unsignedTransactionsChanged:
            writeInt(&buf, Int32(12))
        
        
        case let .sendFlowError(v1):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSendFlowErrorAlert.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerReconcileMessage_lift(_ buf: RustBuffer) throws -> WalletManagerReconcileMessage {
    return try FfiConverterTypeWalletManagerReconcileMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletManagerReconcileMessage_lower(_ value: WalletManagerReconcileMessage) -> RustBuffer {
    return FfiConverterTypeWalletManagerReconcileMessage.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletMode: Equatable, Hashable {
    
    case main
    case decoy





}

#if compiler(>=6)
extension WalletMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletMode: FfiConverterRustBuffer {
    typealias SwiftType = WalletMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        case 2: return .decoy
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        
        case .decoy:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletMode_lift(_ buf: RustBuffer) throws -> WalletMode {
    return try FfiConverterTypeWalletMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletMode_lower(_ value: WalletMode) -> RustBuffer {
    return FfiConverterTypeWalletMode.lower(value)
}



public enum WalletScannerError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case NoAddressTypes
    case WalletCreationError(WalletError
    )
    case NoMnemonicAvailable(WalletId
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_walletscannererror_uniffi_trait_display(
            FfiConverterTypeWalletScannerError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension WalletScannerError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletScannerError: FfiConverterRustBuffer {
    typealias SwiftType = WalletScannerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletScannerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NoAddressTypes
        case 2: return .WalletCreationError(
            try FfiConverterTypeWalletError.read(from: &buf)
            )
        case 3: return .NoMnemonicAvailable(
            try FfiConverterTypeWalletId.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletScannerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .NoAddressTypes:
            writeInt(&buf, Int32(1))
        
        
        case let .WalletCreationError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletError.write(v1, into: &buf)
            
        
        case let .NoMnemonicAvailable(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletId.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletScannerError_lift(_ buf: RustBuffer) throws -> WalletScannerError {
    return try FfiConverterTypeWalletScannerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletScannerError_lower(_ value: WalletScannerError) -> RustBuffer {
    return FfiConverterTypeWalletScannerError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletSettingsRoute: Equatable, Hashable {
    
    case main
    case changeName





}

#if compiler(>=6)
extension WalletSettingsRoute: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletSettingsRoute: FfiConverterRustBuffer {
    typealias SwiftType = WalletSettingsRoute

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletSettingsRoute {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        case 2: return .changeName
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletSettingsRoute, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        
        case .changeName:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletSettingsRoute_lift(_ buf: RustBuffer) throws -> WalletSettingsRoute {
    return try FfiConverterTypeWalletSettingsRoute.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletSettingsRoute_lower(_ value: WalletSettingsRoute) -> RustBuffer {
    return FfiConverterTypeWalletSettingsRoute.lower(value)
}



public enum WalletTableError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case SaveError(String
    )
    case ReadError(String
    )
    case WalletAlreadyExists

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_wallettableerror_uniffi_trait_display(
            FfiConverterTypeWalletTableError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension WalletTableError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletTableError: FfiConverterRustBuffer {
    typealias SwiftType = WalletTableError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletTableError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SaveError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ReadError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .WalletAlreadyExists

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletTableError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SaveError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ReadError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .WalletAlreadyExists:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletTableError_lift(_ buf: RustBuffer) throws -> WalletTableError {
    return try FfiConverterTypeWalletTableError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletTableError_lower(_ value: WalletTableError) -> RustBuffer {
    return FfiConverterTypeWalletTableError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletType: Equatable, Hashable, CustomStringConvertible {
    
    case hot
    case cold
    case xpubOnly
    /**
     * deprecated, use XpubOnly instead
     */
    case watchOnly





// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_wallettype_uniffi_trait_display(
            FfiConverterTypeWalletType_lower(self),$0
    )
}
    )
}
}

#if compiler(>=6)
extension WalletType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletType: FfiConverterRustBuffer {
    typealias SwiftType = WalletType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hot
        
        case 2: return .cold
        
        case 3: return .xpubOnly
        
        case 4: return .watchOnly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hot:
            writeInt(&buf, Int32(1))
        
        
        case .cold:
            writeInt(&buf, Int32(2))
        
        
        case .xpubOnly:
            writeInt(&buf, Int32(3))
        
        
        case .watchOnly:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletType_lift(_ buf: RustBuffer) throws -> WalletType {
    return try FfiConverterTypeWalletType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletType_lower(_ value: WalletType) -> RustBuffer {
    return FfiConverterTypeWalletType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The current state of the word verification check
 */

public enum WordCheckState: Equatable, Hashable {
    
    /**
     * No word is being checked
     */
    case none
    /**
     * User tapped a word, animating to target
     */
    case checking(word: String
    )
    /**
     * Word was correct, showing green
     */
    case correct(word: String
    )
    /**
     * Word was incorrect, showing red
     */
    case incorrect(word: String
    )
    /**
     * Returning to origin after incorrect
     */
    case returning(word: String
    )





}

#if compiler(>=6)
extension WordCheckState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordCheckState: FfiConverterRustBuffer {
    typealias SwiftType = WordCheckState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordCheckState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .checking(word: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .correct(word: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .incorrect(word: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .returning(word: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WordCheckState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .checking(word):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(word, into: &buf)
            
        
        case let .correct(word):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(word, into: &buf)
            
        
        case let .incorrect(word):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(word, into: &buf)
            
        
        case let .returning(word):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(word, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCheckState_lift(_ buf: RustBuffer) throws -> WordCheckState {
    return try FfiConverterTypeWordCheckState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCheckState_lower(_ value: WordCheckState) -> RustBuffer {
    return FfiConverterTypeWordCheckState.lower(value)
}



public enum XpubError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidDescriptor(DescriptorError
    )
    case InvalidJson(String
    )
    case InvalidDescriptorInJson
    case JsonNoDecriptor
    case MissingXpub(String
    )
    case InvalidXpub(String
    )

    

    
// The local Rust `Display` implementation.
public var description: String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_cove_fn_method_xpuberror_uniffi_trait_display(
            FfiConverterTypeXpubError_lower(self),$0
    )
}
    )
}

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension XpubError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeXpubError: FfiConverterRustBuffer {
    typealias SwiftType = XpubError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> XpubError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDescriptor(
            try FfiConverterTypeDescriptorError.read(from: &buf)
            )
        case 2: return .InvalidJson(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidDescriptorInJson
        case 4: return .JsonNoDecriptor
        case 5: return .MissingXpub(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .InvalidXpub(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: XpubError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidDescriptor(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDescriptorError.write(v1, into: &buf)
            
        
        case let .InvalidJson(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidDescriptorInJson:
            writeInt(&buf, Int32(3))
        
        
        case .JsonNoDecriptor:
            writeInt(&buf, Int32(4))
        
        
        case let .MissingXpub(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidXpub(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXpubError_lift(_ buf: RustBuffer) throws -> XpubError {
    return try FfiConverterTypeXpubError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeXpubError_lower(_ value: XpubError) -> RustBuffer {
    return FfiConverterTypeXpubError.lower(value)
}




public protocol AuthManagerReconciler: AnyObject, Sendable {
    
    /**
     * Tells the frontend to reconcile the manager changes
     */
    func reconcile(message: AuthManagerReconcileMessage) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAuthManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAuthManagerReconciler] = [UniffiVTableCallbackInterfaceAuthManagerReconciler(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceAuthManagerReconciler.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface AuthManagerReconciler: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceAuthManagerReconciler.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface AuthManagerReconciler: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAuthManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeAuthManagerReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitAuthManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_authmanagerreconciler(UniffiCallbackInterfaceAuthManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceAuthManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<AuthManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceAuthManagerReconciler : FfiConverter {
    typealias SwiftType = AuthManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAuthManagerReconciler_lift(_ handle: UInt64) throws -> AuthManagerReconciler {
    return try FfiConverterCallbackInterfaceAuthManagerReconciler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAuthManagerReconciler_lower(_ v: AuthManagerReconciler) -> UInt64 {
    return FfiConverterCallbackInterfaceAuthManagerReconciler.lower(v)
}




public protocol CoinControlManagerReconciler: AnyObject, Sendable {
    
    /**
     * Tells the frontend to reconcile the manager changes
     */
    func reconcile(message: CoinControlManagerReconcileMessage) 
    
    func reconcileMany(messages: [CoinControlManagerReconcileMessage]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCoinControlManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCoinControlManagerReconciler] = [UniffiVTableCallbackInterfaceCoinControlManagerReconciler(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceCoinControlManagerReconciler.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface CoinControlManagerReconciler: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceCoinControlManagerReconciler.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface CoinControlManagerReconciler: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoinControlManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeCoinControlManagerReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        reconcileMany: { (
            uniffiHandle: UInt64,
            messages: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoinControlManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcileMany(
                     messages: try FfiConverterSequenceTypeCoinControlManagerReconcileMessage.lift(messages)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitCoinControlManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_coincontrolmanagerreconciler(UniffiCallbackInterfaceCoinControlManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceCoinControlManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<CoinControlManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceCoinControlManagerReconciler : FfiConverter {
    typealias SwiftType = CoinControlManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCoinControlManagerReconciler_lift(_ handle: UInt64) throws -> CoinControlManagerReconciler {
    return try FfiConverterCallbackInterfaceCoinControlManagerReconciler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCoinControlManagerReconciler_lower(_ v: CoinControlManagerReconciler) -> UInt64 {
    return FfiConverterCallbackInterfaceCoinControlManagerReconciler.lower(v)
}




public protocol FfiReconcile: AnyObject, Sendable {
    
    /**
     * Essentially a callback to the frontend
     */
    func reconcile(message: AppStateReconcileMessage) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFfiReconcile {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFfiReconcile] = [UniffiVTableCallbackInterfaceFfiReconcile(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceFfiReconcile.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface FfiReconcile: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceFfiReconcile.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface FfiReconcile: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiReconcile.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeAppStateReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitFfiReconcile() {
    uniffi_cove_fn_init_callback_vtable_ffireconcile(UniffiCallbackInterfaceFfiReconcile.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceFfiReconcile {
    fileprivate static let handleMap = UniffiHandleMap<FfiReconcile>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceFfiReconcile : FfiConverter {
    typealias SwiftType = FfiReconcile
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceFfiReconcile_lift(_ handle: UInt64) throws -> FfiReconcile {
    return try FfiConverterCallbackInterfaceFfiReconcile.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceFfiReconcile_lower(_ v: FfiReconcile) -> UInt64 {
    return FfiConverterCallbackInterfaceFfiReconcile.lower(v)
}




public protocol ImportWalletManagerReconciler: AnyObject, Sendable {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: ImportWalletManagerReconcileMessage) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceImportWalletManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceImportWalletManagerReconciler] = [UniffiVTableCallbackInterfaceImportWalletManagerReconciler(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceImportWalletManagerReconciler.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface ImportWalletManagerReconciler: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceImportWalletManagerReconciler.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface ImportWalletManagerReconciler: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceImportWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeImportWalletManagerReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitImportWalletManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_importwalletmanagerreconciler(UniffiCallbackInterfaceImportWalletManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceImportWalletManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<ImportWalletManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceImportWalletManagerReconciler : FfiConverter {
    typealias SwiftType = ImportWalletManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceImportWalletManagerReconciler_lift(_ handle: UInt64) throws -> ImportWalletManagerReconciler {
    return try FfiConverterCallbackInterfaceImportWalletManagerReconciler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceImportWalletManagerReconciler_lower(_ v: ImportWalletManagerReconciler) -> UInt64 {
    return FfiConverterCallbackInterfaceImportWalletManagerReconciler.lower(v)
}




public protocol PendingWalletManagerReconciler: AnyObject, Sendable {
    
    /**
     * Tells the frontend to reconcile the view model changes
     */
    func reconcile(message: PendingWalletManagerReconcileMessage) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePendingWalletManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePendingWalletManagerReconciler] = [UniffiVTableCallbackInterfacePendingWalletManagerReconciler(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfacePendingWalletManagerReconciler.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface PendingWalletManagerReconciler: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfacePendingWalletManagerReconciler.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface PendingWalletManagerReconciler: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePendingWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypePendingWalletManagerReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitPendingWalletManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_pendingwalletmanagerreconciler(UniffiCallbackInterfacePendingWalletManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfacePendingWalletManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<PendingWalletManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfacePendingWalletManagerReconciler : FfiConverter {
    typealias SwiftType = PendingWalletManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePendingWalletManagerReconciler_lift(_ handle: UInt64) throws -> PendingWalletManagerReconciler {
    return try FfiConverterCallbackInterfacePendingWalletManagerReconciler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePendingWalletManagerReconciler_lower(_ v: PendingWalletManagerReconciler) -> UInt64 {
    return FfiConverterCallbackInterfacePendingWalletManagerReconciler.lower(v)
}




public protocol SendFlowManagerReconciler: AnyObject, Sendable {
    
    /**
     * tells the frontend to reconcile the manager changes
     */
    func reconcile(message: SendFlowManagerReconcileMessage) 
    
    func reconcileMany(messages: [SendFlowManagerReconcileMessage]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSendFlowManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSendFlowManagerReconciler] = [UniffiVTableCallbackInterfaceSendFlowManagerReconciler(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSendFlowManagerReconciler.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SendFlowManagerReconciler: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSendFlowManagerReconciler.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SendFlowManagerReconciler: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSendFlowManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeSendFlowManagerReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        reconcileMany: { (
            uniffiHandle: UInt64,
            messages: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSendFlowManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcileMany(
                     messages: try FfiConverterSequenceTypeSendFlowManagerReconcileMessage.lift(messages)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSendFlowManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_sendflowmanagerreconciler(UniffiCallbackInterfaceSendFlowManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSendFlowManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<SendFlowManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSendFlowManagerReconciler : FfiConverter {
    typealias SwiftType = SendFlowManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendFlowManagerReconciler_lift(_ handle: UInt64) throws -> SendFlowManagerReconciler {
    return try FfiConverterCallbackInterfaceSendFlowManagerReconciler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendFlowManagerReconciler_lower(_ v: SendFlowManagerReconciler) -> UInt64 {
    return FfiConverterCallbackInterfaceSendFlowManagerReconciler.lower(v)
}




public protocol TapcardTransportProtocol: AnyObject, Sendable {
    
    func setMessage(message: String) 
    
    func appendMessage(message: String) 
    
    func transmitApdu(commandApdu: Data) async throws  -> Data
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTapcardTransportProtocol {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceTapcardTransportProtocol] = [UniffiVTableCallbackInterfaceTapcardTransportProtocol(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceTapcardTransportProtocol.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface TapcardTransportProtocol: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceTapcardTransportProtocol.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface TapcardTransportProtocol: handle missing in uniffiClone")
            }
        },
        setMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTapcardTransportProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.setMessage(
                     message: try FfiConverterString.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        appendMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTapcardTransportProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.appendMessage(
                     message: try FfiConverterString.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        transmitApdu: { (
            uniffiHandle: UInt64,
            commandApdu: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutDroppedCallback: UnsafeMutablePointer<UniffiForeignFutureDroppedCallbackStruct>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTapcardTransportProtocol.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.transmitApdu(
                     commandApdu: try FfiConverterData.lift(commandApdu)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureResultRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureResultRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeTransportError_lower,
                droppedCallback: uniffiOutDroppedCallback
            )
        }
    )]
}

private func uniffiCallbackInitTapcardTransportProtocol() {
    uniffi_cove_fn_init_callback_vtable_tapcardtransportprotocol(UniffiCallbackInterfaceTapcardTransportProtocol.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceTapcardTransportProtocol {
    fileprivate static let handleMap = UniffiHandleMap<TapcardTransportProtocol>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceTapcardTransportProtocol : FfiConverter {
    typealias SwiftType = TapcardTransportProtocol
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTapcardTransportProtocol_lift(_ handle: UInt64) throws -> TapcardTransportProtocol {
    return try FfiConverterCallbackInterfaceTapcardTransportProtocol.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTapcardTransportProtocol_lower(_ v: TapcardTransportProtocol) -> UInt64 {
    return FfiConverterCallbackInterfaceTapcardTransportProtocol.lower(v)
}




public protocol WalletManagerReconciler: AnyObject, Sendable {
    
    func reconcile(message: WalletManagerReconcileMessage) 
    
    func reconcileMany(messages: [WalletManagerReconcileMessage]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWalletManagerReconciler {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceWalletManagerReconciler] = [UniffiVTableCallbackInterfaceWalletManagerReconciler(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceWalletManagerReconciler.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface WalletManagerReconciler: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceWalletManagerReconciler.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface WalletManagerReconciler: handle missing in uniffiClone")
            }
        },
        reconcile: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcile(
                     message: try FfiConverterTypeWalletManagerReconcileMessage_lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        reconcileMany: { (
            uniffiHandle: UInt64,
            messages: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceWalletManagerReconciler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.reconcileMany(
                     messages: try FfiConverterSequenceTypeWalletManagerReconcileMessage.lift(messages)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitWalletManagerReconciler() {
    uniffi_cove_fn_init_callback_vtable_walletmanagerreconciler(UniffiCallbackInterfaceWalletManagerReconciler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceWalletManagerReconciler {
    fileprivate static let handleMap = UniffiHandleMap<WalletManagerReconciler>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceWalletManagerReconciler : FfiConverter {
    typealias SwiftType = WalletManagerReconciler
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceWalletManagerReconciler_lift(_ handle: UInt64) throws -> WalletManagerReconciler {
    return try FfiConverterCallbackInterfaceWalletManagerReconciler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceWalletManagerReconciler_lower(_ v: WalletManagerReconciler) -> UInt64 {
    return FfiConverterCallbackInterfaceWalletManagerReconciler.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionFloat: FfiConverterRustBuffer {
    typealias SwiftType = Float?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterFloat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterFloat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBitcoinTransaction: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinTransaction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBitcoinTransaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBitcoinTransaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFingerprint: FfiConverterRustBuffer {
    typealias SwiftType = Fingerprint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFingerprint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFingerprint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnsignedTransactionRecord: FfiConverterRustBuffer {
    typealias SwiftType = UnsignedTransactionRecord?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnsignedTransactionRecord.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnsignedTransactionRecord.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAmount: FfiConverterRustBuffer {
    typealias SwiftType = Amount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePsbt: FfiConverterRustBuffer {
    typealias SwiftType = Psbt?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePsbt.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePsbt.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDeriveInfo: FfiConverterRustBuffer {
    typealias SwiftType = DeriveInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDeriveInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDeriveInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFeeResponse: FfiConverterRustBuffer {
    typealias SwiftType = FeeResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFiatAmount: FfiConverterRustBuffer {
    typealias SwiftType = FiatAmount?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFiatAmount.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFiatAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWalletMetadata: FfiConverterRustBuffer {
    typealias SwiftType = WalletMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAddressIndex: FfiConverterRustBuffer {
    typealias SwiftType = AddressIndex?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddressIndex.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddressIndex.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBlockSizeLast: FfiConverterRustBuffer {
    typealias SwiftType = BlockSizeLast?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockSizeLast.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockSizeLast.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeHardwareWalletMetadata: FfiConverterRustBuffer {
    typealias SwiftType = HardwareWalletMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHardwareWalletMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHardwareWalletMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNumberOfBip39Words: FfiConverterRustBuffer {
    typealias SwiftType = NumberOfBip39Words?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNumberOfBip39Words.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNumberOfBip39Words.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = Route?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoute.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoute.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSetAmountFocusField: FfiConverterRustBuffer {
    typealias SwiftType = SetAmountFocusField?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetAmountFocusField.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetAmountFocusField.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSetupCmdResponse: FfiConverterRustBuffer {
    typealias SwiftType = SetupCmdResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSetupCmdResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSetupCmdResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTapSignerCmd: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerCmd?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTapSignerCmd.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTapSignerCmd.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTapSignerResponse: FfiConverterRustBuffer {
    typealias SwiftType = TapSignerResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTapSignerResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTapSignerResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeUtxo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeUtxo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWalletId: FfiConverterRustBuffer {
    typealias SwiftType = WalletId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBoxedRoute: FfiConverterRustBuffer {
    typealias SwiftType = [BoxedRoute]

    public static func write(_ value: [BoxedRoute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBoxedRoute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BoxedRoute] {
        let len: Int32 = try readInt(&buf)
        var seq = [BoxedRoute]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBoxedRoute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnsignedTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [UnsignedTransaction]

    public static func write(_ value: [UnsignedTransaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnsignedTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnsignedTransaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnsignedTransaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnsignedTransaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]

    public static func write(_ value: [OutPoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutPoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutPoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutPoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFoundAddress: FfiConverterRustBuffer {
    typealias SwiftType = [FoundAddress]

    public static func write(_ value: [FoundAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFoundAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FoundAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [FoundAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFoundAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [GroupedWord]

    public static func write(_ value: [GroupedWord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GroupedWord] {
        let len: Int32 = try readInt(&buf)
        var seq = [GroupedWord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletMetadata: FfiConverterRustBuffer {
    typealias SwiftType = [WalletMetadata]

    public static func write(_ value: [WalletMetadata], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletMetadata.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletMetadata] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletMetadata]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletMetadata.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddressAndAmount: FfiConverterRustBuffer {
    typealias SwiftType = [AddressAndAmount]

    public static func write(_ value: [AddressAndAmount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressAndAmount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressAndAmount] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressAndAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddressAndAmount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [Utxo]

    public static func write(_ value: [Utxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUtxo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Utxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [Utxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUtxo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCoinControlManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = [CoinControlManagerReconcileMessage]

    public static func write(_ value: [CoinControlManagerReconcileMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCoinControlManagerReconcileMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CoinControlManagerReconcileMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [CoinControlManagerReconcileMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCoinControlManagerReconcileMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNodeSelection: FfiConverterRustBuffer {
    typealias SwiftType = [NodeSelection]

    public static func write(_ value: [NodeSelection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeSelection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeSelection] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeSelection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeSelection.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoute: FfiConverterRustBuffer {
    typealias SwiftType = [Route]

    public static func write(_ value: [Route], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Route] {
        let len: Int32 = try readInt(&buf)
        var seq = [Route]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSendFlowManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = [SendFlowManagerReconcileMessage]

    public static func write(_ value: [SendFlowManagerReconcileMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSendFlowManagerReconcileMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SendFlowManagerReconcileMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [SendFlowManagerReconcileMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSendFlowManagerReconcileMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletColor: FfiConverterRustBuffer {
    typealias SwiftType = [WalletColor]

    public static func write(_ value: [WalletColor], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletColor.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletColor] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletColor]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletColor.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletManagerReconcileMessage: FfiConverterRustBuffer {
    typealias SwiftType = [WalletManagerReconcileMessage]

    public static func write(_ value: [WalletManagerReconcileMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletManagerReconcileMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletManagerReconcileMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletManagerReconcileMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletManagerReconcileMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceTypeGroupedWord: FfiConverterRustBuffer {
    typealias SwiftType = [[GroupedWord]]

    public static func write(_ value: [[GroupedWord]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeGroupedWord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[GroupedWord]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[GroupedWord]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypeGroupedWord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletId: FfiConverterRustBuffer {
    typealias SwiftType = [WalletId]

    public static func write(_ value: [WalletId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletId] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletId.read(from: &buf))
        }
        return seq
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimestamp: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Timestamp {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Timestamp) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lift(_ value: UInt64) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> UInt64 {
    return FfiConverterTypeTimestamp.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_WAKE: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureCoveInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                { handle, pollResult in
                    uniffiFutureContinuationCallback(handle: handle, pollResult: pollResult)
                },
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    droppedCallback: UnsafeMutablePointer<UniffiForeignFutureDroppedCallbackStruct>
) {
    let task = Task {
        // Note: it's important we call either `handleSuccess` or `handleError` exactly once.  Each
        // call consumes an Arc reference, which means there should be no possibility of a double
        // call.  The following code is structured so that will will never call both `handleSuccess`
        // and `handleError`, even in the face of weird errors.
        //
        // On platforms that need extra machinery to make C-ABI calls, like JNA or ctypes, it's
        // possible that we fail to make either call.  However, it doesn't seem like this is
        // possible on Swift since swift can just make the C call directly.
        var callResult: T
        do {
            callResult = try await makeCall()
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
            return
        }
        handleSuccess(callResult)
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    droppedCallback.pointee = UniffiForeignFutureDroppedCallbackStruct(
        handle: handle,
        free: uniffiForeignFutureDroppedCallback
    )
}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer,
    droppedCallback: UnsafeMutablePointer<UniffiForeignFutureDroppedCallbackStruct>
) {
    let task = Task {
        // See the note in uniffiTraitInterfaceCallAsync for details on `handleSuccess` and
        // `handleError`.
        var callResult: T
        do {
            callResult = try await makeCall()
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
            return
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
            return
        }
        handleSuccess(callResult)
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    droppedCallback.pointee = UniffiForeignFutureDroppedCallbackStruct(
        handle: handle,
        free: uniffiForeignFutureDroppedCallback
    )
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureDroppedCallback(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureDroppedCallback: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountCove() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * set root data directory before any database access
 * required for Android to specify app-specific storage path
 */
public func setRootDataDir(path: String)throws   {try rustCallWithError(FfiConverterTypeInitError_lift) {
    uniffi_cove_fn_func_set_root_data_dir(
        FfiConverterString.lower(path),$0
    )
}
}
public func allFiatCurrencies() -> [FiatCurrency]  {
    return try!  FfiConverterSequenceTypeFiatCurrency.lift(try! rustCall() {
    uniffi_cove_fn_func_all_fiat_currencies($0
    )
})
}
public func fiatCurrencyEmoji(fiatCurrency: FiatCurrency) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_fiat_currency_emoji(
        FfiConverterTypeFiatCurrency_lower(fiatCurrency),$0
    )
})
}
public func fiatCurrencySuffix(fiatCurrency: FiatCurrency) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_fiat_currency_suffix(
        FfiConverterTypeFiatCurrency_lower(fiatCurrency),$0
    )
})
}
public func fiatCurrencySymbol(fiatCurrency: FiatCurrency) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_fiat_currency_symbol(
        FfiConverterTypeFiatCurrency_lower(fiatCurrency),$0
    )
})
}
public func fiatCurrencyToString(fiatCurrency: FiatCurrency) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_fiat_currency_to_string(
        FfiConverterTypeFiatCurrency_lower(fiatCurrency),$0
    )
})
}
public func isFiatCurrencySymbol(symbol: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_is_fiat_currency_symbol(
        FfiConverterString.lower(symbol),$0
    )
})
}
public func fiatAmountPreviewNew() -> FiatAmount  {
    return try!  FfiConverterTypeFiatAmount_lift(try! rustCall() {
    uniffi_cove_fn_func_fiat_amount_preview_new($0
    )
})
}
public func pricesAreEqual(lhs: PriceResponse, rhs: PriceResponse) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_prices_are_equal(
        FfiConverterTypePriceResponse_lower(lhs),
        FfiConverterTypePriceResponse_lower(rhs),$0
    )
})
}
public func updatePricesIfNeeded()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_func_updatepricesifneeded(
                )
            },
            pollFunc: ffi_cove_rust_future_poll_void,
            completeFunc: ffi_cove_rust_future_complete_void,
            freeFunc: ffi_cove_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
public func coinControlListSortKeyToString(key: CoinControlListSortKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_coin_control_list_sort_key_to_string(
        FfiConverterTypeCoinControlListSortKey_lower(key),$0
    )
})
}
public func addressErrorToAlertState(error: AddressError, address: String) -> SendFlowAlertState  {
    return try!  FfiConverterTypeSendFlowAlertState_lift(try! rustCall() {
    uniffi_cove_fn_func_address_error_to_alert_state(
        FfiConverterTypeAddressError_lower(error),
        FfiConverterString.lower(address),$0
    )
})
}
public func walletStateIsEqual(lhs: WalletLoadState, rhs: WalletLoadState) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_state_is_equal(
        FfiConverterTypeWalletLoadState_lower(lhs),
        FfiConverterTypeWalletLoadState_lower(rhs),$0
    )
})
}
public func groupedPlainWordsOf(mnemonic: String, groups: UInt8)throws  -> [[String]]  {
    return try  FfiConverterSequenceSequenceString.lift(try rustCallWithError(FfiConverterTypeMnemonicParseError_lift) {
    uniffi_cove_fn_func_grouped_plain_words_of(
        FfiConverterString.lower(mnemonic),
        FfiConverterUInt8.lower(groups),$0
    )
})
}
public func numberOfWordsInGroups(me: NumberOfBip39Words, of: UInt8) -> [[String]]  {
    return try!  FfiConverterSequenceSequenceString.lift(try! rustCall() {
    uniffi_cove_fn_func_numberofwordsingroups(
        FfiConverterTypeNumberOfBip39Words_lower(me),
        FfiConverterUInt8.lower(of),$0
    )
})
}
public func numberOfWordsToWordCount(me: NumberOfBip39Words) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_func_numberofwordstowordcount(
        FfiConverterTypeNumberOfBip39Words_lower(me),$0
    )
})
}
public func multiFormatTryFromNfcMessage(nfcMessage: NfcMessage)throws  -> MultiFormat  {
    return try  FfiConverterTypeMultiFormat_lift(try rustCallWithError(FfiConverterTypeMultiFormatError_lift) {
    uniffi_cove_fn_func_multi_format_try_from_nfc_message(
        FfiConverterTypeNfcMessage_lower(nfcMessage),$0
    )
})
}
public func stringOrDataTryIntoMultiFormat(stringOrData: StringOrData)throws  -> MultiFormat  {
    return try  FfiConverterTypeMultiFormat_lift(try rustCallWithError(FfiConverterTypeMultiFormatError_lift) {
    uniffi_cove_fn_func_string_or_data_try_into_multi_format(
        FfiConverterTypeStringOrData_lower(stringOrData),$0
    )
})
}
public func defaultNodeSelection() -> NodeSelection  {
    return try!  FfiConverterTypeNodeSelection_lift(try! rustCall() {
    uniffi_cove_fn_func_default_node_selection($0
    )
})
}
public func nodeSelectionToNode(node: NodeSelection) -> Node  {
    return try!  FfiConverterTypeNode_lift(try! rustCall() {
    uniffi_cove_fn_func_node_selection_to_node(
        FfiConverterTypeNodeSelection_lower(node),$0
    )
})
}
public func afterPinActionUserMessage(action: AfterPinAction) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_cove_fn_func_after_pin_action_user_message(
        FfiConverterTypeAfterPinAction_lower(action),$0
    )
})
}
public func hashRoute(route: Route) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_func_hash_route(
        FfiConverterTypeRoute_lower(route),$0
    )
})
}
public func isRouteEqual(route: Route, routeToCheck: Route) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_is_route_equal(
        FfiConverterTypeRoute_lower(route),
        FfiConverterTypeRoute_lower(routeToCheck),$0
    )
})
}
public func isTapSignerRouteEqual(lhs: TapSignerRoute, rhs: TapSignerRoute) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_is_tap_signer_route_equal(
        FfiConverterTypeTapSignerRoute_lower(lhs),
        FfiConverterTypeTapSignerRoute_lower(rhs),$0
    )
})
}
public func tapSignerConfirmPinArgsNewFromNewPin(args: TapSignerNewPinArgs, newPin: String) -> TapSignerConfirmPinArgs  {
    return try!  FfiConverterTypeTapSignerConfirmPinArgs_lift(try! rustCall() {
    uniffi_cove_fn_func_tap_signer_confirm_pin_args_new_from_new_pin(
        FfiConverterTypeTapSignerNewPinArgs_lower(args),
        FfiConverterString.lower(newPin),$0
    )
})
}
/**
 * Parse from raw bytes
 */
public func signedTransactionOrPsbtTryFromBytes(data: Data)throws  -> SignedTransactionOrPsbt  {
    return try  FfiConverterTypeSignedTransactionOrPsbt_lift(try rustCallWithError(FfiConverterTypeSignedImportError_lift) {
    uniffi_cove_fn_func_signedtransactionorpsbttryfrombytes(
        FfiConverterData.lower(data),$0
    )
})
}
/**
 * Parse from an NFC message
 */
public func signedTransactionOrPsbtTryFromNfcMessage(nfcMessage: NfcMessage)throws  -> SignedTransactionOrPsbt  {
    return try  FfiConverterTypeSignedTransactionOrPsbt_lift(try rustCallWithError(FfiConverterTypeSignedImportError_lift) {
    uniffi_cove_fn_func_signedtransactionorpsbttryfromnfcmessage(
        FfiConverterTypeNfcMessage_lower(nfcMessage),$0
    )
})
}
/**
 * Parse from string input (base64 or hex encoded)
 */
public func signedTransactionOrPsbtTryParse(input: String)throws  -> SignedTransactionOrPsbt  {
    return try  FfiConverterTypeSignedTransactionOrPsbt_lift(try rustCallWithError(FfiConverterTypeSignedImportError_lift) {
    uniffi_cove_fn_func_signedtransactionorpsbttryparse(
        FfiConverterString.lower(input),$0
    )
})
}
public func createTransportErrorFromCode(code: UInt16, message: String) -> TransportError  {
    return try!  FfiConverterTypeTransportError_lift(try! rustCall() {
    uniffi_cove_fn_func_create_transport_error_from_code(
        FfiConverterUInt16.lower(code),
        FfiConverterString.lower(message),$0
    )
})
}
public func isValidChainCode(chainCode: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_is_valid_chain_code(
        FfiConverterString.lower(chainCode),$0
    )
})
}
/**
 * Factory function to create a TapSignerReader instance
 * This is a workaround for UniFFI not generating async constructors for Kotlin
 * While iOS can use the async constructor directly, Android needs this factory function
 */
public func createTapSignerReader(transport: TapcardTransportProtocol, cmd: TapSignerCmd?)async throws  -> TapSignerReader  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_cove_fn_func_create_tap_signer_reader(FfiConverterCallbackInterfaceTapcardTransportProtocol_lower(transport),FfiConverterOptionTypeTapSignerCmd.lower(cmd)
                )
            },
            pollFunc: ffi_cove_rust_future_poll_u64,
            completeFunc: ffi_cove_rust_future_complete_u64,
            freeFunc: ffi_cove_rust_future_free_u64,
            liftFunc: FfiConverterTypeTapSignerReader_lift,
            errorHandler: FfiConverterTypeTapSignerReaderError_lift
        )
}
public func tapSignerErrorIsAuthError(error: TapSignerReaderError) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignererrorisautherror(
        FfiConverterTypeTapSignerReaderError_lower(error),$0
    )
})
}
public func tapSignerErrorIsNoBackupError(error: TapSignerReaderError) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignererrorisnobackuperror(
        FfiConverterTypeTapSignerReaderError_lower(error),$0
    )
})
}
public func tapSignerResponseBackupResponse(response: TapSignerResponse) -> Data?  {
    return try!  FfiConverterOptionData.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignerresponsebackupresponse(
        FfiConverterTypeTapSignerResponse_lower(response),$0
    )
})
}
public func tapSignerResponseChangeResponse(response: TapSignerResponse) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignerresponsechangeresponse(
        FfiConverterTypeTapSignerResponse_lower(response),$0
    )
})
}
public func tapSignerResponseDeriveResponse(response: TapSignerResponse) -> DeriveInfo?  {
    return try!  FfiConverterOptionTypeDeriveInfo.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignerresponsederiveresponse(
        FfiConverterTypeTapSignerResponse_lower(response),$0
    )
})
}
public func tapSignerResponseSetupResponse(response: TapSignerResponse) -> SetupCmdResponse?  {
    return try!  FfiConverterOptionTypeSetupCmdResponse.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignerresponsesetupresponse(
        FfiConverterTypeTapSignerResponse_lower(response),$0
    )
})
}
public func tapSignerResponseSignResponse(response: TapSignerResponse) -> Psbt?  {
    return try!  FfiConverterOptionTypePsbt.lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignerresponsesignresponse(
        FfiConverterTypeTapSignerResponse_lower(response),$0
    )
})
}
public func tapSignerSetupCompleteNew(preview: Bool) -> TapSignerSetupComplete  {
    return try!  FfiConverterTypeTapSignerSetupComplete_lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignersetupcompletenew(
        FfiConverterBool.lower(preview),$0
    )
})
}
public func tapSignerSetupRetryContinueCmd(preview: Bool) -> SetupCmdResponse  {
    return try!  FfiConverterTypeSetupCmdResponse_lift(try! rustCall() {
    uniffi_cove_fn_func_tapsignersetupretrycontinuecmd(
        FfiConverterBool.lower(preview),$0
    )
})
}
public func transactionPreviewConfirmedNew() -> Transaction  {
    return try!  FfiConverterTypeTransaction_lift(try! rustCall() {
    uniffi_cove_fn_func_transaction_preview_confirmed_new($0
    )
})
}
public func transactionPreviewUnconfirmedNew() -> Transaction  {
    return try!  FfiConverterTypeTransaction_lift(try! rustCall() {
    uniffi_cove_fn_func_transaction_preview_unconfirmed_new($0
    )
})
}
public func transactionsPreviewNew(confirmed: UInt8, unconfirmed: UInt8) -> [Transaction]  {
    return try!  FfiConverterSequenceTypeTransaction.lift(try! rustCall() {
    uniffi_cove_fn_func_transactions_preview_new(
        FfiConverterUInt8.lower(confirmed),
        FfiConverterUInt8.lower(unconfirmed),$0
    )
})
}
public func walletAddressTypeSortOrder(addressType: WalletAddressType) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_address_type_sort_order(
        FfiConverterTypeWalletAddressType_lower(addressType),$0
    )
})
}
public func ffiMinSendAmount() -> Amount  {
    return try!  FfiConverterTypeAmount_lift(try! rustCall() {
    uniffi_cove_fn_func_ffi_min_send_amount($0
    )
})
}
public func ffiMinSendSats() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_func_ffi_min_send_sats($0
    )
})
}
public func previewNewLegacyFoundAddress() -> FoundAddress  {
    return try!  FfiConverterTypeFoundAddress_lift(try! rustCall() {
    uniffi_cove_fn_func_preview_new_legacy_found_address($0
    )
})
}
public func previewNewWrappedFoundAddress() -> FoundAddress  {
    return try!  FfiConverterTypeFoundAddress_lift(try! rustCall() {
    uniffi_cove_fn_func_preview_new_wrapped_found_address($0
    )
})
}
public func defaultWalletColors() -> [WalletColor]  {
    return try!  FfiConverterSequenceTypeWalletColor.lift(try! rustCall() {
    uniffi_cove_fn_func_default_wallet_colors($0
    )
})
}
public func hardwareWalletIsTapSigner(hardwareWallet: HardwareWalletMetadata) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_hardware_wallet_is_tap_signer(
        FfiConverterTypeHardwareWalletMetadata_lower(hardwareWallet),$0
    )
})
}
public func walletMetadataHash(metadata: WalletMetadata) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_metadata_hash(
        FfiConverterTypeWalletMetadata_lower(metadata),$0
    )
})
}
public func walletMetadataIsEqual(lhs: WalletMetadata, rhs: WalletMetadata) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_metadata_is_equal(
        FfiConverterTypeWalletMetadata_lower(lhs),
        FfiConverterTypeWalletMetadata_lower(rhs),$0
    )
})
}
public func walletMetadataPreview() -> WalletMetadata  {
    return try!  FfiConverterTypeWalletMetadata_lift(try! rustCall() {
    uniffi_cove_fn_func_wallet_metadata_preview($0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_cove_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_cove_checksum_func_set_root_data_dir() != 56109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_all_fiat_currencies() != 53482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fiat_currency_emoji() != 42864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fiat_currency_suffix() != 43766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fiat_currency_symbol() != 15961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fiat_currency_to_string() != 47206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_is_fiat_currency_symbol() != 60129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_fiat_amount_preview_new() != 29492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_prices_are_equal() != 22419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_updatepricesifneeded() != 5753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_coin_control_list_sort_key_to_string() != 15603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_address_error_to_alert_state() != 44369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_state_is_equal() != 22901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_grouped_plain_words_of() != 51957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_numberofwordsingroups() != 45196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_numberofwordstowordcount() != 42516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_multi_format_try_from_nfc_message() != 63598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_string_or_data_try_into_multi_format() != 10759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_default_node_selection() != 32212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_node_selection_to_node() != 13406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_after_pin_action_user_message() != 30105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_hash_route() != 38756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_is_route_equal() != 13176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_is_tap_signer_route_equal() != 21746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tap_signer_confirm_pin_args_new_from_new_pin() != 4888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_signedtransactionorpsbttryfrombytes() != 36882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_signedtransactionorpsbttryfromnfcmessage() != 49359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_signedtransactionorpsbttryparse() != 7350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_create_transport_error_from_code() != 12205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_is_valid_chain_code() != 38380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_create_tap_signer_reader() != 39823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignererrorisautherror() != 54484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignererrorisnobackuperror() != 36431) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignerresponsebackupresponse() != 56452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignerresponsechangeresponse() != 16196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignerresponsederiveresponse() != 33262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignerresponsesetupresponse() != 13906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignerresponsesignresponse() != 8089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignersetupcompletenew() != 44793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_tapsignersetupretrycontinuecmd() != 55236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_transaction_preview_confirmed_new() != 46336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_transaction_preview_unconfirmed_new() != 27289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_transactions_preview_new() != 59467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_address_type_sort_order() != 21818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_ffi_min_send_amount() != 61138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_ffi_min_send_sats() != 550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_preview_new_legacy_found_address() != 25458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_preview_new_wrapped_found_address() != 22709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_default_wallet_colors() != 11354) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_hardware_wallet_is_tap_signer() != 49430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_metadata_hash() != 36015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_metadata_is_equal() != 16249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_func_wallet_metadata_preview() != 44605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_auth_type() != 36896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_can_go_back() != 19459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_dangerous_wipe_all_data() != 40843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_debug_or_release() != 2224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_dispatch() != 37137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_email_mailto() != 41824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_fees() != 5661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_find_tap_signer_wallet() != 57891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_get_tap_signer_backup() != 58844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_git_short_hash() != 52244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_go_to_selected_wallet() != 60903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_has_wallets() != 65260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_init_on_start() != 30417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_is_at_root() != 23036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_listen_for_updates() != 31459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route() != 12168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_load_and_reset_default_route_after() != 60004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_network() != 44430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_num_wallets() != 1649) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_prices() != 42098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_reset_after_loading() != 53361) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_reset_default_route_to() != 31408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_reset_nested_routes_to() != 59502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_save_tap_signer_backup() != 24217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_select_latest_or_new_wallet() != 31849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_select_wallet() != 51673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_state() != 49253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_unverified_wallet_ids() != 44634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffiapp_version() != 27942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_authpin_check() != 37111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_autocomplete_autocomplete() != 50983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_autocomplete_is_valid_word() != 305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39autocomplete_autocomplete() != 29231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39autocomplete_is_valid_word() != 48769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39autocomplete_next_field_number() != 51302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_autocomplete() != 40714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_bip39_word() != 47413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_is_valid_word() != 24260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bip39wordspecificautocomplete_next_field_number() != 62639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_converter_parse_fiat_str() != 21091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_converter_remove_fiat_suffix() != 41995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_dangerous_reset_all_data() != 25988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_global_config() != 34695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_global_flag() != 54391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_historical_prices() != 57298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_unsigned_transactions() != 55731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_database_wallets() != 16005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_authtype() != 62043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_clear_selected_wallet() != 50864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_colorscheme() != 59965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_delete() != 4239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_delete_hashed_pin_code() != 24897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_get() != 63339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_hashed_pin_code() != 59065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_is_in_decoy_mode() != 42237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_is_in_main_mode() != 25736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_select_wallet() != 60640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selectedfiatcurrency() != 11234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selected_network() != 17475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selected_node() != 230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_selected_wallet() != 6128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set() != 46117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_setcolorscheme() != 39030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set_hashed_pin_code() != 44857) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set_selected_network() != 47630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_set_selected_node() != 44882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalconfigtable_wallet_mode() != 27720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_get() != 10621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_get_bool_config() != 8824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_is_terms_accepted() != 22175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_set() != 45485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_set_bool_config() != 46453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_globalflagtable_toggle_bool_config() != 43871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_confirm_details() != 63212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_created_at() != 64486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_tx_id() != 11601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionrecord_wallet_id() != 45598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionstable_gettx() != 43509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransactionstable_gettxthrow() != 11583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_all() != 1090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_all_sorted_active() != 25765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_is_empty() != 59967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletstable_len() != 51436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_priceresponse_get() != 6552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_priceresponse_get_for_currency() != 944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_filehandler_read() != 12343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_delete_labels_for_txn() != 50691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_export() != 24203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_export_default_file_name() != 28880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_export_to_bbqr_with_density() != 50284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_has_labels() != 29517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_import() != 60353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_importlabels() != 36909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_insert_or_update_labels_for_txn() != 29934) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_labelmanager_transaction_label() != 50059) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_auth_type() != 16523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_checkdecoypin() != 46529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_checkwipedatapin() != 38200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_delete_decoy_pin() != 4703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_delete_wipe_data_pin() != 54055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_dispatch() != 9261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_is_decoy_pin_enabled() != 56755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_is_in_decoy_mode() != 2667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_is_wipe_data_pin_enabled() != 9487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_listen_for_updates() != 26735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_locked_at() != 56936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_send() != 44537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_set_auth_type() != 12110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_set_decoy_pin() != 17908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_set_locked_at() != 21515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_set_wipe_data_pin() != 16843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_switch_to_decoy_mode() != 59870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_switch_to_main_mode() != 36755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_validate_new_pin() != 2677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_validate_pin_settings() != 50929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustauthmanager_validate_security_action() != 4302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_button_presentation() != 24764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_dispatch() != 42057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_id() != 30707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_listen_for_updates() != 62581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_reload_labels() != 44692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_selected_utxos() != 30072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_unit() != 17965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustcoincontrolmanager_utxos() != 43520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustimportwalletmanager_dispatch() != 59923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustimportwalletmanager_import_wallet() != 19980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustimportwalletmanager_listen_for_updates() != 12813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words() != 13908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_bip_39_words_grouped() != 18565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_card_indexes() != 4104) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_dispatch() != 27062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_get_state() != 5102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_listen_for_updates() != 24629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_number_of_words_count() != 7796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustpendingwalletmanager_save_wallet() != 54348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_amount() != 50946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_amount_exceeds_balance() != 56944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_amount_sats() != 25668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_dispatch() != 4249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_display_fiat_amount() != 9610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_entering_fiat_amount() != 28644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_get_custom_fee_option() != 15013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_listen_for_updates() != 60412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_maxsendminusfees() != 19710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_maxsendminusfeesandsmallutxo() != 9326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_sanitize_btc_entering_amount() != 12659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_sanitize_fiat_entering_amount() != 54595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_send_amount_btc() != 26631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_send_amount_fiat() != 59936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_total_fee_string() != 32322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_total_spent_in_btc() != 56090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_total_spent_in_fiat() != 43357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_utxos() != 24447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_validate_address() != 64421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_validate_amount() != 34659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_validate_fee_percentage() != 54512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_wait_for_init() != 6400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustsendflowmanager_wallet_id() != 47057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_address_at() != 13093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_amount_in_fiat() != 61774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_balance() != 14970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_broadcast_transaction() != 63043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_convert_and_display_fiat() != 15439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_convert_from_fiat_string() != 4952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_convert_to_fiat() != 24905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_create_transactions_with_fiat_export() != 39040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_current_block_height() != 53869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_delete_unsigned_transaction() != 17810) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_delete_wallet() != 58138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_deletion_warning_message() != 57956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_dispatch() != 14781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_display_amount() != 42440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_display_fiat_amount() != 60595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_display_sent_and_received_amount() != 41756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_export_labels_for_qr() != 32503) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_export_labels_for_share() != 38081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_export_transactions_csv() != 27705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_export_xpub_for_qr() != 3466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_export_xpub_for_share() != 18121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_fee_rate_options() != 36497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_fees() != 63480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_finalize_psbt() != 51432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_first_address() != 34209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_force_update_height() != 37409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_force_wallet_scan() != 28212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_fee_options() != 42115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_transactions() != 27342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_get_unsigned_transactions() != 35895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_label_manager() != 23571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_listen_for_updates() != 19177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_mark_wallet_as_verified() != 27203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_master_fingerprint() != 64370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_new_coin_control_manager() != 11951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_new_send_flow_manager() != 21514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_next_address() != 38399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations() != 55676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_number_of_confirmations_fmt() != 32886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_required_deletion_confirmations() != 30427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_save_unsigned_transaction() != 43358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_selected_fiat_currency() != 2567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_sent_and_received_fiat() != 33144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_set_wallet_metadata() != 11441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_sign_and_broadcast_transaction() != 32531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_split_transaction_outputs() != 15558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_start_wallet_scan() != 1741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_switch_to_different_wallet_address_type() != 64255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_transaction_details() != 35364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_validate_metadata() != 36684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_wallet_metadata() != 23312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_rustwalletmanager_word_validator() != 7935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_mnemonic_all_words() != 24108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_mnemonic_to_seed_qr_string() != 24678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_mnemonic_words() != 8009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_check_and_save_node() != 9328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_check_selected_node() != 64855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_node_list() != 26686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_parse_custom_node() != 62414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_select_preset_node() != 59069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_nodeselector_selected_node() != 20791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_qrscanner_reset() != 17017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_qrscanner_scan() != 55003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_boxedroute_route() != 6095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_coin_control_send() != 46427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_cold_wallet_import() != 3114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_hot_wallet() != 59643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_hot_wallet_import_from_scan() != 39695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_is_same_parent_route() != 8524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_load_and_reset_nested_to() != 27109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_load_and_reset_to() != 35517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_load_and_reset_to_after() != 9407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_main_wallet_settings() != 27709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_nested_settings() != 45233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_nested_wallet_settings() != 8770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_new_hot_wallet() != 4033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_new_wallet_select() != 49216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_qr_import() != 52134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_secret_words() != 54666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send() != 47898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send_confirm() != 50845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send_hardware_export() != 49069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_send_set_amount() != 20072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_routefactory_wallet_settings() != 55243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_seedqr_get_words() != 37488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_seedqr_grouped_plain_words() != 45204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_headericonpresenter_background_color() != 25849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_headericonpresenter_icon_color() != 1536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_headericonpresenter_ring_color() != 38756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapsignerreader_continue_setup() != 49046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapsignerreader_last_response() != 10948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapsignerreader_run() != 41710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapsignerreader_setup() != 41951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapsignerreader_sign() != 52648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_block_height() != 51200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_block_height_fmt() != 48528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_confirmed_at() != 43978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt() != 50930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_confirmed_at_fmt_with_time() != 11516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_fiat_amount() != 22195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_id() != 39263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_label() != 38357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_label_opt() != 2357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_confirmedtransaction_sent_and_received() != 2538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_fiat_amount() != 6476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_id() != 59603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_label() != 18483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_last_seen() != 42072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unconfirmedtransaction_sent_and_received() != 7072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bitcointransaction_normalize_tx_id() != 57228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bitcointransaction_tx_id() != 33330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_bitcointransaction_tx_id_hash() != 59698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_address() != 1840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_address_spaced_out() != 38824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount() != 53012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fiat() != 45617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fiat_fmt() != 17226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fiat_fmt_cached() != 11182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_amount_fmt() != 13996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_block_number() != 37642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_block_number_fmt() != 8381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_confirmation_date_time() != 59432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_fee_fiat_fmt() != 57101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_fee_fiat_fmt_cached() != 1845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_fee_fmt() != 37631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_historical_fiat_fmt() != 9571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_historical_fiat_fmt_cached() != 37164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_is_confirmed() != 13728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_is_received() != 28034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_is_sent() != 49296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fiat_fmt() != 61624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fiat_fmt_cached() != 42399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_sent_sans_fee_fmt() != 64427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_transaction_label() != 53712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_transaction_url() != 42171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_transactiondetails_tx_id() != 32068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_details() != 3548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_id() != 48401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_label() != 49063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_sending_amount() != 9414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_unsignedtransaction_spending_amount() != 60073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_urresult_data() != 20992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_urresult_is_hdkey() != 16134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_urresult_is_psbt() != 29188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_urresult_is_seed() != 5310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_urresult_ur_type() != 33507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wallet_id() != 30585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_balance_spendable() != 31487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_fingerprint_as_lowercase() != 43161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_fingerprint_as_uppercase() != 45978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordvalidator_is_complete() != 16577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordvalidator_is_word_correct() != 20650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordvalidator_possible_words() != 58432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_animation_complete() != 38406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_config() != 39348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_dwell_complete() != 24167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_is_complete() != 19976) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_possible_words() != 5700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_reset_to_word() != 43945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_return_complete() != 53818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_select_word() != 45827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_state() != 57576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_wordverifystatemachine_word_number() != 36254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_ffiapp_new() != 32653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_authpin_new() != 65153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bip39autocomplete_new() != 13345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bip39wordspecificautocomplete_new() != 32688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_converter_new() != 60790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_database_new() != 1150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_filehandler_new() != 14514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_addressargs_new() != 7657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_labelmanager_new() != 53348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustauthmanager_new() != 54478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustcoincontrolmanager_preview_new() != 19053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_coincontrolmanagerstate_preview_new() != 11196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustimportwalletmanager_new() != 12433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustpendingwalletmanager_new() != 1933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_new() != 19482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet() != 39975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_preview_new_wallet_with_metadata() != 41631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_tap_signer() != 14372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_rustwalletmanager_try_new_from_xpub() != 15129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_mnemonic_new() != 40975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_mnemonic_preview() != 34768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_nodeselector_new() != 62365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_qrscanner_new() != 57573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_boxedroute_new() != 21632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_routefactory_new() != 29995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_seedqr_new_from_data() != 20096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_seedqr_new_from_str() != 17486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_headericonpresenter_new() != 27668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_setupcmd_try_new() != 28305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_tapsignerreader_new() != 47410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bitcointransaction_new() != 54413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bitcointransaction_tryfromdata() != 28556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bitcointransaction_tryfromnfcmessage() != 20549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_bitcointransaction_tryfromstringordata() != 37802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_received() != 42056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_confirmed_sent() != 33983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_new_confirmed() != 18691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_new_with_label() != 51427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_pending_received() != 18117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_transactiondetails_preview_pending_sent() != 26743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_unsignedtransaction_preview_new() != 60973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_urresult_new() != 34590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wallet_new_from_export() != 38500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wallet_new_from_xpub() != 12329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wallet_previewnewwallet() != 59961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_balance_zero() != 52590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_fingerprint_new() != 9042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wordvalidator_preview() != 63940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_constructor_wordverifystatemachine_new() != 16955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_ffireconcile_reconcile() != 36143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_authmanagerreconciler_reconcile() != 565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_coincontrolmanagerreconciler_reconcile() != 28640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_coincontrolmanagerreconciler_reconcile_many() != 14668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_importwalletmanagerreconciler_reconcile() != 13279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_pendingwalletmanagerreconciler_reconcile() != 54948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sendflowmanagerreconciler_reconcile() != 15254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_sendflowmanagerreconciler_reconcile_many() != 4799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletmanagerreconciler_reconcile() != 4887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_walletmanagerreconciler_reconcile_many() != 28999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapcardtransportprotocol_set_message() != 28436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapcardtransportprotocol_append_message() != 28952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_cove_checksum_method_tapcardtransportprotocol_transmit_apdu() != 31781) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAutoComplete()
    uniffiCallbackInitAuthManagerReconciler()
    uniffiCallbackInitCoinControlManagerReconciler()
    uniffiCallbackInitFfiReconcile()
    uniffiCallbackInitImportWalletManagerReconciler()
    uniffiCallbackInitPendingWalletManagerReconciler()
    uniffiCallbackInitSendFlowManagerReconciler()
    uniffiCallbackInitTapcardTransportProtocol()
    uniffiCallbackInitWalletManagerReconciler()
    uniffiEnsureCoveDeviceInitialized()
    uniffiEnsureCoveNfcInitialized()
    uniffiEnsureCoveTapCardInitialized()
    uniffiEnsureCoveTypesInitialized()
    uniffiEnsureCoveUrInitialized()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureCoveInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all